"use strict";
(self["webpackChunkrealgis"] = self["webpackChunkrealgis"] || []).push([["default-node_modules_arcgis_core_layers_support_rasterFunctions_vectorFieldUtils_js-node_modu-8bb3a8"],{

/***/ 53416:
/*!****************************************************************!*\
  !*** ./node_modules/@arcgis/core/layers/support/PixelBlock.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ u)
/* harmony export */ });
/* harmony import */ var _chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../chunks/tslib.es6.js */ 18100);
/* harmony import */ var _core_Error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/Error.js */ 32995);
/* harmony import */ var _core_JSONSupport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/JSONSupport.js */ 69237);
/* harmony import */ var _core_lang_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/lang.js */ 88684);
/* harmony import */ var _core_Logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/Logger.js */ 28191);
/* harmony import */ var _core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/accessorSupport/decorators/property.js */ 9497);
/* harmony import */ var _core_accessorSupport_decorators_cast_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/accessorSupport/decorators/cast.js */ 36734);
/* harmony import */ var _core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/accessorSupport/decorators/subclass.js */ 20891);
/* harmony import */ var _SimpleBandStatistics_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SimpleBandStatistics.js */ 84955);
/* harmony import */ var _rasterFormats_pixelRangeUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rasterFormats/pixelRangeUtils.js */ 79092);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/










var p;
let c = p = class extends _core_JSONSupport_js__WEBPACK_IMPORTED_MODULE_2__.JSONSupport {
  static createEmptyBand(t, e) {
    return new (p.getPixelArrayConstructor(t))(e);
  }
  static getPixelArrayConstructor(t) {
    let e;
    switch (t) {
      case "u1":
      case "u2":
      case "u4":
      case "u8":
        e = Uint8Array;
        break;
      case "u16":
        e = Uint16Array;
        break;
      case "u32":
        e = Uint32Array;
        break;
      case "s8":
        e = Int8Array;
        break;
      case "s16":
        e = Int16Array;
        break;
      case "s32":
        e = Int32Array;
        break;
      case "f32":
      case "c64":
      case "c128":
      case "unknown":
        e = Float32Array;
        break;
      case "f64":
        e = Float64Array;
    }
    return e;
  }
  constructor(t) {
    super(t), this.width = null, this.height = null, this.pixelType = "f32", this.validPixelCount = null, this.mask = null, this.maskIsAlpha = !1, this.premultiplyAlpha = !1, this.statistics = null, this.depthCount = 1;
  }
  castPixelType(t) {
    if (!t) return "f32";
    let e = t.toLowerCase();
    return ["u1", "u2", "u4"].includes(e) ? e = "u8" : ["unknown", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"].includes(e) || (e = "f32"), e;
  }
  getPlaneCount() {
    return this.pixels?.length;
  }
  addData(t) {
    if (!t.pixels || t.pixels.length !== this.width * this.height) throw new _core_Error_js__WEBPACK_IMPORTED_MODULE_1__["default"]("pixelblock:invalid-or-missing-pixels", "add data requires valid pixels array that has same length defined by pixel block width * height");
    this.pixels || (this.pixels = []), this.statistics || (this.statistics = []), this.pixels.push(t.pixels), this.statistics.push(t.statistics ?? new _SimpleBandStatistics_js__WEBPACK_IMPORTED_MODULE_8__.SimpleBandStatistics());
  }
  getAsRGBA() {
    const t = new ArrayBuffer(this.width * this.height * 4);
    switch (this.pixelType) {
      case "s8":
      case "s16":
      case "u16":
      case "s32":
      case "u32":
      case "f32":
      case "f64":
        this._fillFromNon8Bit(t);
        break;
      default:
        this._fillFrom8Bit(t);
    }
    return new Uint8ClampedArray(t);
  }
  getAsRGBAFloat() {
    const t = new Float32Array(this.width * this.height * 4);
    return this._fillFrom32Bit(t), t;
  }
  updateStatistics() {
    if (!this.pixels) return;
    this.statistics = this.pixels.map(t => this._calculateBandStatistics(t, this.mask));
    const t = this.mask;
    let e = 0;
    if (null != t) for (let s = 0; s < t.length; s++) t[s] && e++;else e = this.width * this.height;
    this.validPixelCount = e;
  }
  clamp(t) {
    if (!t || "f64" === t || "f32" === t || !this.pixels) return;
    const [e, s] = (0,_rasterFormats_pixelRangeUtils_js__WEBPACK_IMPORTED_MODULE_9__.getPixelValueRange)(t),
      i = this.pixels,
      l = this.width * this.height,
      r = i.length;
    let o, a, n;
    const c = [];
    for (let h = 0; h < r; h++) {
      n = p.createEmptyBand(t, l), o = i[h];
      for (let t = 0; t < l; t++) a = o[t], n[t] = a > s ? s : a < e ? e : a;
      c.push(n);
    }
    this.pixels = c, this.pixelType = t;
  }
  extractBands(t) {
    const {
      pixels: e,
      statistics: s
    } = this;
    if (null == t || 0 === t.length || !e || 0 === e.length) return this;
    const i = e.length,
      l = t.some(t => t >= e.length),
      r = i === t.length && !t.some((t, e) => t !== e);
    if (l || r) return this;
    const o = this.bandMasks?.length === i ? t.map(t => this.bandMasks[t]) : void 0;
    let {
      mask: a,
      validPixelCount: n
    } = this;
    const {
      width: h,
      height: c
    } = this;
    if (o) {
      if (1 === o.length) a = o[0];else {
        const t = h * c;
        a = new Uint8Array(t).fill(255);
        for (let e = 0; e < o.length; e++) {
          const s = o[e];
          for (let e = 0; e < t; e++) s[e] || (a[e] = 0);
        }
      }
      n = a.filter(t => !!t).length;
    }
    return new p({
      pixelType: this.pixelType,
      width: h,
      height: c,
      mask: a,
      bandMasks: o,
      validPixelCount: n,
      maskIsAlpha: this.maskIsAlpha,
      pixels: t.map(t => e[t]),
      statistics: s && t.map(t => s[t])
    });
  }
  clone() {
    const t = new p({
      width: this.width,
      height: this.height,
      pixelType: this.pixelType,
      maskIsAlpha: this.maskIsAlpha,
      validPixelCount: this.validPixelCount
    });
    let e;
    null != this.mask && (this.mask instanceof Uint8Array ? t.mask = new Uint8Array(this.mask) : t.mask = this.mask.slice(0)), this.bandMasks && (t.bandMasks = this.bandMasks.map(t => new Uint8Array(t)));
    const s = p.getPixelArrayConstructor(this.pixelType);
    if (this.pixels && this.pixels.length > 0) {
      t.pixels = [];
      const i = !!this.pixels[0].slice;
      for (e = 0; e < this.pixels.length; e++) t.pixels[e] = i ? this.pixels[e].slice(0, this.pixels[e].length) : new s(this.pixels[e]);
    }
    if (this.statistics) for (t.statistics = [], e = 0; e < this.statistics.length; e++) t.statistics[e] = (0,_core_lang_js__WEBPACK_IMPORTED_MODULE_3__.clone)(this.statistics[e]);
    return t.premultiplyAlpha = this.premultiplyAlpha, t;
  }
  _fillFrom8Bit(t) {
    const {
      mask: e,
      maskIsAlpha: s,
      premultiplyAlpha: i,
      pixels: r
    } = this;
    if (!t || !r?.length) return void _core_Logger_js__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    let o, a, n, h;
    o = a = n = r[0], r.length >= 3 ? (a = r[1], n = r[2]) : 2 === r.length && (a = r[1]);
    const p = new Uint32Array(t),
      c = this.width * this.height;
    if (o.length === c) {
      if (null != e && e.length === c) {
        if (s) for (h = 0; h < c; h++) {
          const t = e[h];
          if (t) {
            const e = t / 255;
            p[h] = i ? t << 24 | n[h] * e << 16 | a[h] * e << 8 | o[h] * e : t << 24 | n[h] << 16 | a[h] << 8 | o[h];
          }
        } else for (h = 0; h < c; h++) e[h] && (p[h] = 255 << 24 | n[h] << 16 | a[h] << 8 | o[h]);
      } else for (h = 0; h < c; h++) p[h] = 255 << 24 | n[h] << 16 | a[h] << 8 | o[h];
    } else _core_Logger_js__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
  }
  _fillFromNon8Bit(t) {
    const {
      pixels: e,
      mask: s,
      statistics: i
    } = this;
    if (!t || !e?.length) return void _core_Logger_js__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    const r = this.pixelType;
    let o = 1,
      a = 0,
      n = 1;
    if (i && i.length > 0) {
      for (const t of i) if (null != t.minValue && (a = Math.min(a, t.minValue)), null != t.maxValue && null != t.minValue) {
        const e = t.maxValue - t.minValue;
        n = Math.max(n, e);
      }
      o = 255 / n;
    } else {
      let t = 255;
      "s8" === r ? (a = -128, t = 127) : "u16" === r ? t = 65535 : "s16" === r ? (a = -32768, t = 32767) : "u32" === r ? t = 4294967295 : "s32" === r ? (a = -2147483648, t = 2147483647) : "f32" === r ? (a = -34e38, t = 34e38) : "f64" === r && (a = -Number.MAX_VALUE, t = Number.MAX_VALUE), o = 255 / (t - a);
    }
    const h = new Uint32Array(t),
      p = this.width * this.height;
    let c, u, g, f, m;
    if (c = u = g = e[0], c.length !== p) return _core_Logger_js__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
    if (e.length >= 2) {
      if (u = e[1], e.length >= 3 && (g = e[2]), null != s && s.length === p) for (f = 0; f < p; f++) s[f] && (h[f] = 255 << 24 | (g[f] - a) * o << 16 | (u[f] - a) * o << 8 | (c[f] - a) * o);else for (f = 0; f < p; f++) h[f] = 255 << 24 | (g[f] - a) * o << 16 | (u[f] - a) * o << 8 | (c[f] - a) * o;
    } else if (null != s && s.length === p) for (f = 0; f < p; f++) m = (c[f] - a) * o, s[f] && (h[f] = 255 << 24 | m << 16 | m << 8 | m);else for (f = 0; f < p; f++) m = (c[f] - a) * o, h[f] = 255 << 24 | m << 16 | m << 8 | m;
  }
  _fillFrom32Bit(t) {
    const {
      pixels: e,
      mask: s
    } = this;
    if (!t || !e?.length) return _core_Logger_js__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The input pixel block is empty.");
    let i, r, o, a;
    i = r = o = e[0], e.length >= 3 ? (r = e[1], o = e[2]) : 2 === e.length && (r = e[1]);
    const n = this.width * this.height;
    if (i.length !== n) return _core_Logger_js__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The pixelblock is invalid.");
    let h = 0;
    if (null != s && s.length === n) for (a = 0; a < n; a++) t[h++] = i[a], t[h++] = r[a], t[h++] = o[a], t[h++] = 1 & s[a];else for (a = 0; a < n; a++) t[h++] = i[a], t[h++] = r[a], t[h++] = o[a], t[h++] = 1;
  }
  _calculateBandStatistics(t, e) {
    let s = 1 / 0,
      i = -1 / 0;
    const l = t.length;
    let r,
      o = 0;
    if (null != e) for (r = 0; r < l; r++) e[r] && (o = t[r], s = o < s ? o : s, i = o > i ? o : i);else for (r = 0; r < l; r++) o = t[r], s = o < s ? o : s, i = o > i ? o : i;
    return new _SimpleBandStatistics_js__WEBPACK_IMPORTED_MODULE_8__.SimpleBandStatistics(s, i);
  }
};
(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "width", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "height", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "pixelType", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_cast_js__WEBPACK_IMPORTED_MODULE_6__.cast)("pixelType")], c.prototype, "castPixelType", null), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "validPixelCount", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "mask", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "maskIsAlpha", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "pixels", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)()], c.prototype, "premultiplyAlpha", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "statistics", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "depthCount", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "noDataValues", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_5__.property)({
  json: {
    write: !0
  }
})], c.prototype, "bandMasks", void 0), c = p = (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_7__.subclass)("esri.layers.support.PixelBlock")], c);
const u = c;


/***/ }),

/***/ 84955:
/*!**************************************************************************!*\
  !*** ./node_modules/@arcgis/core/layers/support/SimpleBandStatistics.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleBandStatistics": () => (/* binding */ l)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
class l {
  constructor(l = null, a = null, t = null) {
    this.minValue = l, this.maxValue = a, this.noDataValue = t;
  }
}


/***/ }),

/***/ 26890:
/*!********************************************************************************!*\
  !*** ./node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MissingBandAction": () => (/* binding */ l),
/* harmony export */   "NoDataInterpretation": () => (/* binding */ n),
/* harmony export */   "approximateTransform": () => (/* binding */ R),
/* harmony export */   "clip": () => (/* binding */ P),
/* harmony export */   "colorize": () => (/* binding */ h),
/* harmony export */   "compositeBands": () => (/* binding */ r),
/* harmony export */   "createColormapLUT": () => (/* binding */ a),
/* harmony export */   "createMaskLUT": () => (/* binding */ w),
/* harmony export */   "createRemapLUT": () => (/* binding */ y),
/* harmony export */   "extractBands": () => (/* binding */ s),
/* harmony export */   "getClipBounds": () => (/* binding */ k),
/* harmony export */   "getLocalArithmeticNorthRotations": () => (/* binding */ I),
/* harmony export */   "interpolateOffsets": () => (/* binding */ E),
/* harmony export */   "isValidPixelBlock": () => (/* binding */ o),
/* harmony export */   "lookupBandValues": () => (/* binding */ c),
/* harmony export */   "lookupPixels": () => (/* binding */ f),
/* harmony export */   "mask": () => (/* binding */ g),
/* harmony export */   "maxMapSizeGpu": () => (/* binding */ i),
/* harmony export */   "mosaic": () => (/* binding */ U),
/* harmony export */   "mosaicPixelData": () => (/* binding */ M),
/* harmony export */   "remap": () => (/* binding */ p),
/* harmony export */   "remapColor": () => (/* binding */ u),
/* harmony export */   "resampleByMajority": () => (/* binding */ v),
/* harmony export */   "setValidBoundary": () => (/* binding */ T),
/* harmony export */   "split": () => (/* binding */ W)
/* harmony export */ });
/* harmony import */ var _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PixelBlock.js */ 53416);
/* harmony import */ var _rasterFormats_pixelRangeUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rasterFormats/pixelRangeUtils.js */ 79092);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/


var n, l;
!function (t) {
  t[t.matchAny = 0] = "matchAny", t[t.matchAll = 1] = "matchAll";
}(n || (n = {})), function (t) {
  t[t.bestMatch = 0] = "bestMatch", t[t.fail = 1] = "fail";
}(l || (l = {}));
const i = 6;
function o(t) {
  return null != t && "esri.layers.support.PixelBlock" === t.declaredClass && t.pixels && t.pixels.length > 0;
}
function s(t, e) {
  return e?.length && o(t) ? t.extractBands(e) : t;
}
function r(e) {
  if (!e?.length || e.some(t => !o(t))) return null;
  if (1 === e.length) return e[0]?.clone() ?? null;
  const n = e,
    {
      width: l,
      height: i,
      pixelType: s
    } = n[0];
  if (n.some(t => t.width !== l || t.height !== i)) return null;
  const r = n.map(({
    mask: t
  }) => t).filter(t => null != t);
  let a = null;
  r.length && (a = new Uint8Array(l * i), a.set(r[0]), r.length > 1 && m(r.slice(1), a));
  const h = [];
  n.forEach(({
    pixels: t
  }) => h.push(...t));
  const f = n.map(({
      statistics: t
    }) => t).filter(t => t?.length),
    c = [];
  return f.forEach(t => c.push(...t)), new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    pixelType: s,
    width: l,
    height: i,
    mask: a,
    pixels: h,
    statistics: c.length ? c : null
  });
}
function a(t) {
  if (!t) return;
  const e = t.colormap;
  if (!e || 0 === e.length) return;
  const n = e.sort((t, e) => t[0] - e[0]);
  let l = 0;
  n[0][0] < 0 && (l = n[0][0]);
  const i = Math.max(256, n[n.length - 1][0] - l + 1),
    o = new Uint8Array(4 * i),
    s = [];
  let r,
    a = 0,
    h = 0;
  const f = 5 === n[0].length;
  if (i > 65536) return n.forEach(t => {
    s[t[0] - l] = f ? t.slice(1) : t.slice(1).concat([255]);
  }), {
    indexed2DColormap: s,
    offset: l,
    alphaSpecified: f
  };
  if (t.fillUnspecified) for (r = n[h], a = r[0] - l; a < i; a++) o[4 * a] = r[1], o[4 * a + 1] = r[2], o[4 * a + 2] = r[3], o[4 * a + 3] = f ? r[4] : 255, a === r[0] - l && (r = h === n.length - 1 ? r : n[++h]);else for (a = 0; a < n.length; a++) r = n[a], h = 4 * (r[0] - l), o[h] = r[1], o[h + 1] = r[2], o[h + 2] = r[3], o[h + 3] = f ? r[4] : 255;
  return {
    indexedColormap: o,
    offset: l,
    alphaSpecified: f
  };
}
function h(t, e) {
  if (!o(t)) return t;
  if (!e || !e.indexedColormap && !e.indexed2DColormap) return t;
  const n = t.clone(),
    l = n.pixels;
  let i = n.mask;
  const s = n.width * n.height;
  if (1 !== l.length) return t;
  const {
    indexedColormap: r,
    indexed2DColormap: a,
    offset: h,
    alphaSpecified: f
  } = e;
  let c = 0;
  const u = l[0],
    p = new Uint8Array(u.length),
    x = new Uint8Array(u.length),
    d = new Uint8Array(u.length);
  let m,
    g = 0;
  if (r) {
    const t = r.length - 1;
    if (null != i) for (c = 0; c < s; c++) i[c] && (g = 4 * (u[c] - h), g < h || g > t ? i[c] = 0 : (p[c] = r[g], x[c] = r[g + 1], d[c] = r[g + 2], i[c] = r[g + 3]));else {
      for (i = new Uint8Array(s), c = 0; c < s; c++) g = 4 * (u[c] - h), g < h || g > t ? i[c] = 0 : (p[c] = r[g], x[c] = r[g + 1], d[c] = r[g + 2], i[c] = r[g + 3]);
      n.mask = i;
    }
  } else if (a) if (null != i) for (c = 0; c < s; c++) i[c] && (m = a[u[c]], p[c] = m[0], x[c] = m[1], d[c] = m[2], i[c] = m[3]);else {
    for (i = new Uint8Array(s), c = 0; c < s; c++) m = a[u[c]], p[c] = m[0], x[c] = m[1], d[c] = m[2], i[c] = m[3];
    n.mask = i;
  }
  return n.pixels = [p, x, d], n.statistics = null, n.pixelType = "u8", n.maskIsAlpha = f, n;
}
function f(e, n) {
  if (!o(e)) return null;
  const {
      pixels: l,
      mask: i
    } = e,
    s = l.length;
  let r = n.lut;
  const {
    offset: a
  } = n;
  r && 1 === r[0].length && (r = l.map(() => r));
  const h = [],
    f = n.outputPixelType || "u8";
  for (let t = 0; t < s; t++) {
    const e = c(l[t], i, r[t], a || 0, f);
    h.push(e);
  }
  const u = new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    width: e.width,
    height: e.height,
    pixels: h,
    mask: i,
    pixelType: f
  });
  return u.updateStatistics(), u;
}
function c(e, n, l, i, o) {
  const s = e.length,
    r = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"].createEmptyBand(o, s);
  if (n) for (let t = 0; t < s; t++) n[t] && (r[t] = l[e[t] - i]);else for (let t = 0; t < s; t++) r[t] = l[e[t] - i];
  return r;
}
function u(t, e) {
  if (!o(t)) return null;
  const n = t.clone(),
    {
      pixels: l
    } = n,
    i = n.width * n.height,
    s = e.length,
    r = Math.floor(s / 2),
    a = e[Math.floor(r)],
    h = l[0];
  let f,
    c,
    u,
    p,
    x,
    d,
    m = !1;
  const g = new Uint8Array(i),
    y = new Uint8Array(i),
    w = new Uint8Array(i);
  let k = n.mask;
  const M = 4 === e[0].mappedColor.length;
  for (k || (k = new Uint8Array(i), k.fill(M ? 255 : 1), n.mask = k), x = 0; x < i; x++) if (k[x]) {
    for (f = h[x], m = !1, d = r, c = a, u = 0, p = s - 1; p - u > 1;) {
      if (f === c.value) {
        m = !0;
        break;
      }
      f > c.value ? u = d : p = d, d = Math.floor((u + p) / 2), c = e[Math.floor(d)];
    }
    m || (f === e[u].value ? (c = e[u], m = !0) : f === e[p].value ? (c = e[p], m = !0) : f < e[u].value ? (m = !1, c = null) : f > e[u].value && (f < e[p].value ? (c = e[u], m = !0) : p === s - 1 ? (m = !1, c = null) : (c = e[p], m = !0))), m ? (g[x] = c.mappedColor[0], y[x] = c.mappedColor[1], w[x] = c.mappedColor[2], k[x] = c.mappedColor[3]) : g[x] = y[x] = w[x] = k[x] = 0;
  }
  return n.pixels = [g, y, w], n.mask = k, n.pixelType = "u8", n.maskIsAlpha = M, n;
}
function p(n, l) {
  if (!o(n)) return null;
  const {
      width: i,
      height: s
    } = n,
    {
      inputRanges: r,
      outputValues: a,
      outputPixelType: h,
      noDataRanges: f,
      allowUnmatched: c,
      isLastInputRangeInclusive: u
    } = l,
    p = n.pixels[0],
    x = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"].createEmptyBand(h, p.length),
    d = n.mask,
    m = new Uint8Array(i * s);
  d ? m.set(d) : m.fill(255);
  const g = n.pixelType.startsWith("f") ? 1e-6 : 0,
    y = r.map(t => t - g);
  y[0] = r[0], y[y.length - 1] = r[r.length - 1] + (u ? 1e-6 : 0);
  const w = r.length / 2,
    [k, M] = (0,_rasterFormats_pixelRangeUtils_js__WEBPACK_IMPORTED_MODULE_1__.getPixelValueRange)(h);
  for (let t = 0; t < s; t++) for (let e = 0; e < i; e++) {
    const n = t * i + e;
    if (m[n]) {
      const t = p[n];
      let e = !1;
      for (let l = w - 1; l >= 0; l--) if (t === y[2 * l] || t > y[2 * l] && t < y[2 * l + 1]) {
        x[n] = a[l], e = !0;
        break;
      }
      e || (c ? x[n] = t > M ? M : t < k ? k : t : m[n] = 0);
    }
  }
  const A = f?.length;
  if (A) for (let t = 0; t < s; t++) for (let e = 0; e < i; e++) {
    const n = t * i + e;
    if (!d || d[n]) {
      const t = p[n];
      for (let e = 0; e < A; e += 2) if (t >= f[e] && t <= f[e + 1]) {
        x[n] = 0, m[n] = 0;
        break;
      }
    }
  }
  return new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    width: i,
    height: s,
    pixelType: h,
    pixels: [x],
    mask: m
  });
}
function x(t, e, n, l) {
  const i = null != n && n.length >= 2 ? new Set(n) : null,
    o = 1 === n?.length ? n[0] : null,
    s = !!e?.length;
  for (let r = 0; r < t.length; r++) if (l[r]) {
    const n = t[r];
    if (s) {
      let t = !1;
      for (let l = 0; l < e.length; l += 2) if (n >= e[l] && n <= e[l + 1]) {
        t = !0;
        break;
      }
      t || (l[r] = 0);
    }
    l[r] && (n === o || i?.has(n)) && (l[r] = 0);
  }
}
function d(t, e) {
  const n = t[0].length;
  for (let l = 0; l < n; l++) if (e[l]) {
    let n = !1;
    for (let e = 0; e < t.length; e++) if (t[e][l]) {
      n = !0;
      break;
    }
    n || (e[l] = 0);
  }
}
function m(t, e) {
  const n = t[0].length;
  for (let l = 0; l < n; l++) if (e[l]) {
    let n = !1;
    for (let e = 0; e < t.length; e++) if (0 === t[e][l]) {
      n = !0;
      break;
    }
    n && (e[l] = 0);
  }
}
function g(e, n) {
  if (!o(e)) return null;
  const {
      width: l,
      height: i,
      pixels: s
    } = e,
    r = l * i,
    a = new Uint8Array(r);
  e.mask ? a.set(e.mask) : a.fill(255);
  const h = s.length,
    {
      includedRanges: f,
      noDataValues: u,
      outputPixelType: p,
      matchAll: g,
      lookups: y
    } = n;
  if (y) {
    const t = [];
    for (let e = 0; e < h; e++) {
      const n = y[e],
        l = c(s[e], a, n.lut, n.offset || 0, "u8");
      t.push(l);
    }
    1 === t.length ? a.set(t[0]) : g ? d(t, a) : m(t, a);
  } else if (g) {
    const t = [];
    for (let e = 0; e < h; e++) {
      const n = new Uint8Array(r);
      n.set(a), x(s[e], f?.slice(2 * e, 2 * e + 2), u?.[e], n), t.push(n);
    }
    1 === t.length ? a.set(t[0]) : d(t, a);
  } else for (let t = 0; t < h; t++) x(s[t], f?.slice(2 * t, 2 * t + 2), u?.[t], a);
  return new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    width: l,
    height: i,
    pixelType: p,
    pixels: s,
    mask: a
  });
}
function y(n) {
  const {
    srcPixelType: l,
    inputRanges: i,
    outputValues: o,
    allowUnmatched: s,
    noDataRanges: r,
    isLastInputRangeInclusive: a,
    outputPixelType: h
  } = n;
  if ("u8" !== l && "s8" !== l && "u16" !== l && "s16" !== l) return null;
  const f = l.includes("16") ? 65536 : 256,
    c = l.includes("s") ? -f / 2 : 0,
    u = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"].createEmptyBand(h, f),
    p = new Uint8Array(f);
  s && p.fill(255);
  const [x, d] = (0,_rasterFormats_pixelRangeUtils_js__WEBPACK_IMPORTED_MODULE_1__.getPixelValueRange)(h);
  if (i?.length && o?.length) {
    const t = 1e-6,
      e = i.map(e => e - t);
    e[0] = i[0], a && (e[e.length - 1] = i[i.length - 1]);
    for (let n = 0; n < e.length; n++) {
      const t = o[n] > d ? d : o[n] < x ? x : o[n],
        l = Math.ceil(e[2 * n] - c),
        i = Math.floor(e[2 * n + 1] - c);
      for (let e = l; e <= i; e++) u[e] = t, p[e] = 255;
    }
  }
  if (r?.length) for (let t = 0; t < r.length; t++) {
    const e = Math.ceil(r[2 * t] - c),
      n = Math.floor(r[2 * t + 1] - c);
    for (let t = e; t <= n; t++) p[t] = 0;
  }
  return {
    lut: u,
    offset: c,
    mask: p
  };
}
function w(t, e, n) {
  if ("u8" !== t && "s8" !== t && "u16" !== t && "s16" !== t) return null;
  const l = t.includes("16") ? 65536 : 256,
    i = t.includes("s") ? -l / 2 : 0,
    o = new Uint8Array(l);
  if (e) for (let s = 0; s < e.length; s++) {
    const t = Math.ceil(e[2 * s] - i),
      n = Math.floor(e[2 * s + 1] - i);
    for (let e = t; e <= n; e++) o[e] = 255;
  } else o.fill(255);
  if (n) for (let s = 0; s < n.length; s++) o[n[s] - i] = 0;
  return {
    lut: o,
    offset: i
  };
}
function k(t, e, n, l, i, o, s, r) {
  return {
    xmin: i <= n * t ? 0 : i < n * t + t ? i - n * t : t,
    ymin: o <= l * e ? 0 : o < l * e + e ? o - l * e : e,
    xmax: i + s <= n * t ? 0 : i + s < n * t + t ? i + s - n * t : t,
    ymax: o + r <= l * e ? 0 : o + r < l * e + e ? o + r - l * e : e
  };
}
function M(t, e) {
  if (!t || 0 === t.length) return null;
  const n = t.find(t => t.pixelBlock);
  if (null == n?.pixelBlock) return null;
  const l = (n.extent.xmax - n.extent.xmin) / n.pixelBlock.width,
    i = (n.extent.ymax - n.extent.ymin) / n.pixelBlock.height,
    o = .01 * Math.min(l, i),
    s = t.sort((t, e) => Math.abs(t.extent.ymax - e.extent.ymax) > o ? e.extent.ymax - t.extent.ymax : Math.abs(t.extent.xmin - e.extent.xmin) > o ? t.extent.xmin - e.extent.xmin : 0),
    r = Math.min.apply(null, s.map(t => t.extent.xmin)),
    a = Math.min.apply(null, s.map(t => t.extent.ymin)),
    h = Math.max.apply(null, s.map(t => t.extent.xmax)),
    f = Math.max.apply(null, s.map(t => t.extent.ymax)),
    c = {
      x: Math.round((e.xmin - r) / l),
      y: Math.round((f - e.ymax) / i)
    },
    u = {
      width: Math.round((h - r) / l),
      height: Math.round((f - a) / i)
    },
    p = {
      width: Math.round((e.xmax - e.xmin) / l),
      height: Math.round((e.ymax - e.ymin) / i)
    };
  if (Math.round(u.width / n.pixelBlock.width) * Math.round(u.height / n.pixelBlock.height) !== s.length || c.x < 0 || c.y < 0 || u.width < p.width || u.height < p.height) return null;
  return {
    extent: e,
    pixelBlock: U(s.map(t => t.pixelBlock), u, {
      clipOffset: c,
      clipSize: p
    })
  };
}
function A(t, e, n, l, i, o) {
  const {
      width: s,
      height: r
    } = n.block,
    {
      x: a,
      y: h
    } = n.offset,
    {
      width: f,
      height: c
    } = n.mosaic,
    u = k(s, r, l, i, a, h, f, c);
  let p = 0,
    x = 0;
  if (o) {
    const t = o.hasGCSSShiftTransform ? 360 : o.halfWorldWidth ?? 0,
      e = s * o.resolutionX,
      n = o.startX + l * e;
    n < t && n + e > t ? x = o.rightPadding : n >= t && (p = o.leftMargin - o.rightPadding, x = 0);
  }
  if (u.xmax -= x, "number" != typeof e) for (let d = u.ymin; d < u.ymax; d++) {
    const n = (i * r + d - h) * f + (l * s - a) + p,
      o = d * s;
    for (let l = u.xmin; l < u.xmax; l++) t[n + l] = e[o + l];
  } else for (let d = u.ymin; d < u.ymax; d++) {
    const n = (i * r + d - h) * f + (l * s - a) + p;
    for (let l = u.xmin; l < u.xmax; l++) t[n + l] = e;
  }
}
function U(e, n, l = {}) {
  const {
    clipOffset: i,
    clipSize: s,
    alignmentInfo: r,
    blockWidths: a
  } = l;
  if (a) return b(e, n, {
    blockWidths: a
  });
  const h = e.find(t => o(t));
  if (null == h) return null;
  const f = s ? s.width : n.width,
    c = s ? s.height : n.height,
    u = h.width,
    p = h.height,
    x = n.width / u,
    d = n.height / p,
    m = {
      offset: i || {
        x: 0,
        y: 0
      },
      mosaic: s || n,
      block: {
        width: u,
        height: p
      }
    },
    g = h.pixelType,
    y = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"].getPixelArrayConstructor(g),
    w = h.pixels.length,
    k = [];
  let M, U;
  for (let t = 0; t < w; t++) {
    U = new y(f * c);
    for (let n = 0; n < d; n++) for (let l = 0; l < x; l++) {
      const i = e[n * x + l];
      o(i) && (M = i.pixels[t], A(U, M, m, l, n, r));
    }
    k.push(U);
  }
  const T = e.some(t => null == t || null != t.mask && t.mask.length > 0),
    v = e.some(t => t?.bandMasks && t.bandMasks.length > 1),
    C = T ? new Uint8Array(f * c) : void 0,
    B = v ? [] : void 0;
  if (C) {
    for (let t = 0; t < d; t++) for (let n = 0; n < x; n++) {
      const l = e[t * x + n],
        i = null != l ? l.mask : null;
      A(C, null != i ? i : l ? 255 : 0, m, n, t, r);
    }
    if (B) for (let t = 0; t < w; t++) {
      const n = new Uint8Array(f * c);
      for (let l = 0; l < d; l++) for (let i = 0; i < x; i++) {
        const o = e[l * x + i],
          s = o?.bandMasks?.[t] ?? o?.mask;
        A(n, null != s ? s : o ? 255 : 0, m, i, l, r);
      }
      B.push(n);
    }
  }
  const S = new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    width: f,
    height: c,
    pixels: k,
    pixelType: g,
    bandMasks: B,
    mask: C
  });
  return S.updateStatistics(), S;
}
function b(e, n, l) {
  const i = e.find(t => null != t);
  if (null == i) return null;
  const s = e.some(t => null == t || !!t.mask),
    {
      width: r,
      height: a
    } = n,
    h = s ? new Uint8Array(r * a) : null,
    {
      blockWidths: f
    } = l,
    c = [],
    u = i.getPlaneCount(),
    p = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"].getPixelArrayConstructor(i.pixelType);
  if (s) for (let t = 0, y = 0; t < e.length; y += f[t], t++) {
    const n = e[t];
    if (!o(n)) continue;
    const l = n.mask;
    for (let e = 0; e < a; e++) for (let i = 0; i < f[t]; i++) h[e * r + i + y] = null == l ? 255 : l[e * n.width + i];
  }
  const x = e.some(t => t?.bandMasks && t.bandMasks.length > 1),
    d = x ? [] : void 0,
    m = r * a;
  for (let t = 0; t < u; t++) {
    const n = new p(m),
      l = x ? new Uint8Array(m) : void 0;
    for (let i = 0, s = 0; i < e.length; s += f[i], i++) {
      const h = e[i];
      if (!o(h)) continue;
      const c = h.pixels[t];
      if (null != c) {
        for (let t = 0; t < a; t++) for (let e = 0; e < f[i]; e++) n[t * r + e + s] = c[t * h.width + e];
        if (l) {
          const e = h.bandMasks?.[t] ?? h.mask;
          for (let t = 0; t < a; t++) for (let n = 0; n < f[i]; n++) l[t * r + n + s] = e ? e[t * h.width + n] : 255;
        }
      }
    }
    c.push(n), d && l && d.push(l);
  }
  const g = new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    width: r,
    height: a,
    mask: h,
    bandMasks: d,
    pixels: c,
    pixelType: i.pixelType
  });
  return g.updateStatistics(), g;
}
function T(t, e, n) {
  if (!o(t)) return null;
  const {
      width: l,
      height: i
    } = t,
    s = e.x,
    r = e.y,
    a = n.width + s,
    h = n.height + r;
  if (s < 0 || r < 0 || a > l || h > i) return t;
  if (0 === s && 0 === r && a === l && h === i) return t;
  t.mask || (t.mask = new Uint8Array(l * i));
  const f = t.mask;
  for (let o = 0; o < i; o++) {
    const t = o * l;
    for (let e = 0; e < l; e++) f[t + e] = o < r || o >= h || e < s || e >= a ? 0 : 1;
  }
  return t.updateStatistics(), t;
}
function v(t) {
  if (!o(t)) return null;
  const e = t.clone(),
    {
      width: n,
      height: l,
      pixels: i
    } = t,
    s = i[0],
    r = e.pixels[0],
    a = t.mask;
  for (let o = 2; o < l - 1; o++) {
    const t = new Map();
    for (let l = o - 2; l < o + 2; l++) for (let e = 0; e < 4; e++) {
      const i = l * n + e;
      S(t, s[i], a ? a[i] : 1);
    }
    r[o * n] = C(t), r[o * n + 1] = r[o * n + 2] = r[o * n];
    let e = 3;
    for (; e < n - 1; e++) {
      let l = (o - 2) * n + e + 1;
      S(t, s[l], a ? a[l] : 1), l = (o - 1) * n + e + 1, S(t, s[l], a ? a[l] : 1), l = o * n + e + 1, S(t, s[l], a ? a[l] : 1), l = (o + 1) * n + e + 1, S(t, s[l], a ? a[l] : 1), l = (o - 2) * n + e - 3, B(t, s[l], a ? a[l] : 1), l = (o - 1) * n + e - 3, B(t, s[l], a ? a[l] : 1), l = o * n + e - 3, B(t, s[l], a ? a[l] : 1), l = (o + 1) * n + e - 3, B(t, s[l], a ? a[l] : 1), r[o * n + e] = C(t);
    }
    r[o * n + e + 1] = r[o * n + e];
  }
  for (let o = 0; o < n; o++) r[o] = r[n + o] = r[2 * n + o], r[(l - 1) * n + o] = r[(l - 2) * n + o];
  return e.updateStatistics(), e;
}
function C(t) {
  if (0 === t.size) return 0;
  let e = 0,
    n = -1,
    l = 0;
  const i = t.keys();
  let o = i.next();
  for (; !o.done;) l = t.get(o.value), l > e && (n = o.value, e = l), o = i.next();
  return n;
}
function B(t, e, n) {
  if (0 === n) return;
  const l = t.get(e);
  1 === l ? t.delete(e) : t.set(e, l - 1);
}
function S(t, e, n) {
  0 !== n && t.set(e, t.has(e) ? t.get(e) + 1 : 1);
}
function P(e, n, l) {
  let {
    x: i,
    y: s
  } = n;
  const {
    width: r,
    height: a
  } = l;
  if (0 === i && 0 === s && a === e.height && r === e.width) return e;
  const {
      width: h,
      height: f
    } = e,
    c = Math.max(0, s),
    u = Math.max(0, i),
    p = Math.min(i + r, h),
    x = Math.min(s + a, f);
  if (p < 0 || x < 0 || !o(e)) return null;
  i = Math.max(0, -i), s = Math.max(0, -s);
  const {
      pixels: d
    } = e,
    m = r * a,
    g = d.length,
    y = [];
  for (let o = 0; o < g; o++) {
    const n = d[o],
      l = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"].createEmptyBand(e.pixelType, m);
    for (let t = c; t < x; t++) {
      const e = t * h;
      let o = (t + s - c) * r + i;
      for (let t = u; t < p; t++) l[o++] = n[e + t];
    }
    y.push(l);
  }
  const w = new Uint8Array(m),
    k = e.mask;
  for (let t = c; t < x; t++) {
    const e = t * h;
    let n = (t + s - c) * r + i;
    for (let t = u; t < p; t++) w[n++] = k ? k[e + t] : 1;
  }
  const M = new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    width: l.width,
    height: l.height,
    pixelType: e.pixelType,
    pixels: y,
    mask: w
  });
  return M.updateStatistics(), M;
}
function _(e, n = !0) {
  if (!o(e)) return null;
  const {
      pixels: l,
      width: i,
      height: s,
      mask: r,
      pixelType: a
    } = e,
    h = [],
    f = Math.round(i / 2),
    c = Math.round(s / 2),
    u = s - 1,
    p = i - 1;
  for (let o = 0; o < l.length; o++) {
    const e = l[o],
      r = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"].createEmptyBand(a, f * c);
    let x = 0;
    for (let t = 0; t < s; t += 2) for (let l = 0; l < i; l += 2) {
      const o = e[t * i + l];
      if (n) {
        const n = l === p ? o : e[t * i + l + 1],
          s = t === u ? o : e[t * i + l + i],
          a = l === p ? s : t === u ? n : e[t * i + l + i + 1];
        r[x++] = (o + n + s + a) / 4;
      } else r[x++] = o;
    }
    h.push(r);
  }
  let x = null;
  if (null != r) {
    x = new Uint8Array(f * c);
    let t = 0;
    for (let e = 0; e < s; e += 2) for (let l = 0; l < i; l += 2) {
      const o = r[e * i + l];
      if (n) {
        const n = l === p ? o : r[e * i + l + 1],
          s = e === u ? o : r[e * i + l + i],
          a = l === p ? s : e === u ? n : r[e * i + l + i + 1];
        x[t++] = o * n * s * a ? 1 : 0;
      } else x[t++] = o;
    }
  }
  return new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    width: f,
    height: c,
    pixelType: a,
    pixels: h,
    mask: x
  });
}
function W(t, e, n) {
  if (!o(t)) return null;
  const {
    width: l,
    height: i
  } = e;
  let {
    width: s,
    height: r
  } = t;
  const a = new Map(),
    h = {
      x: 0,
      y: 0
    },
    f = null == n ? 1 : 1 + n;
  let c = t;
  for (let o = 0; o < f; o++) {
    const t = Math.ceil(s / l),
      n = Math.ceil(r / i);
    for (let s = 0; s < n; s++) {
      h.y = s * i;
      for (let n = 0; n < t; n++) {
        h.x = n * l;
        const t = P(c, h, e);
        a.set(`${o}/${s}/${n}`, t);
      }
    }
    o < f - 1 && (c = _(c)), s = Math.round(s / 2), r = Math.round(r / 2);
  }
  return a;
}
function E(t, e, n, l, i = 0) {
  const {
      width: o,
      height: s
    } = t,
    {
      width: r,
      height: a
    } = e,
    h = l.cols,
    f = l.rows,
    c = Math.ceil(r / h - .1 / h),
    u = Math.ceil(a / f - .1 / f);
  let p, x, d, m, g, y, w;
  const k = c * h,
    M = k * u * f,
    A = new Float32Array(M),
    U = new Float32Array(M),
    b = new Uint32Array(M),
    T = new Uint32Array(M);
  let v,
    C,
    B = 0;
  for (let S = 0; S < u; S++) for (let t = 0; t < c; t++) {
    p = 12 * (S * c + t), x = n[p], d = n[p + 1], m = n[p + 2], g = n[p + 3], y = n[p + 4], w = n[p + 5];
    for (let e = 0; e < f; e++) {
      B = (S * f + e) * k + t * h, C = (e + .5) / f;
      for (let t = 0; t < e; t++) v = (t + .5) / h, A[B + t] = (x * v + d * C + m) * o + i, U[B + t] = (g * v + y * C + w) * s + i, b[B + t] = Math.floor(A[B + t]), T[B + t] = Math.floor(U[B + t]);
    }
    p += 6, x = n[p], d = n[p + 1], m = n[p + 2], g = n[p + 3], y = n[p + 4], w = n[p + 5];
    for (let e = 0; e < f; e++) {
      B = (S * f + e) * k + t * h, C = (e + .5) / f;
      for (let t = e; t < h; t++) v = (t + .5) / h, A[B + t] = (x * v + d * C + m) * o + i, U[B + t] = (g * v + y * C + w) * s + i, b[B + t] = Math.floor(A[B + t]), T[B + t] = Math.floor(U[B + t]);
    }
  }
  return {
    offsets_x: A,
    offsets_y: U,
    offsets_xi: b,
    offsets_yi: T,
    gridWidth: k
  };
}
function I(t, e) {
  const {
      coefficients: n,
      spacing: l
    } = e,
    {
      offsets_x: i,
      offsets_y: o,
      gridWidth: s
    } = E(t, t, n, {
      rows: l[0],
      cols: l[1]
    }),
    {
      width: r,
      height: a
    } = t,
    h = new Float32Array(r * a),
    f = 180 / Math.PI;
  for (let c = 0; c < a; c++) for (let t = 0; t < r; t++) {
    const e = c * s + t,
      n = 0 === c ? e : e - s,
      l = c === a - 1 ? e : e + s,
      u = i[n] - i[l],
      p = o[l] - o[n];
    if (isNaN(u) || isNaN(p)) h[c * r + t] = 90;else {
      let e = Math.atan2(p, u) * f;
      e = (360 + e) % 360, h[c * r + t] = e;
    }
  }
  return h;
}
function R(e, n, l, i, s = "nearest") {
  if (!o(e)) return null;
  "majority" === s && (e = v(e));
  const {
      pixels: r,
      mask: a,
      bandMasks: h,
      pixelType: f
    } = e,
    c = e.width,
    u = e.height,
    p = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"].getPixelArrayConstructor(f),
    x = r.length,
    {
      width: d,
      height: m
    } = n;
  let g = !1;
  for (let t = 0; t < l.length; t += 3) -1 === l[t] && -1 === l[t + 1] && -1 === l[t + 2] && (g = !0);
  const {
    offsets_x: y,
    offsets_y: w,
    offsets_xi: k,
    offsets_yi: M,
    gridWidth: A
  } = E({
    width: c,
    height: u
  }, n, l, i, "majority" === s ? .5 : 0);
  let U;
  const b = (t, e, n, l) => {
      const i = t instanceof Float32Array || t instanceof Float64Array ? 0 : .5;
      for (let o = 0; o < m; o++) {
        U = o * A;
        for (let s = 0; s < d; s++) {
          if (y[U] < 0 || w[U] < 0) t[o * d + s] = 0;else if (l) t[o * d + s] = e[k[U] + M[U] * c];else {
            const l = Math.floor(y[U]),
              r = Math.floor(w[U]),
              a = Math.ceil(y[U]),
              h = Math.ceil(w[U]),
              f = y[U] - l,
              u = w[U] - r;
            if (!n || n[l + r * c] && n[a + r * c] && n[l + h * c] && n[a + h * c]) {
              const n = (1 - f) * e[l + r * c] + f * e[a + r * c],
                p = (1 - f) * e[l + h * c] + f * e[a + h * c];
              t[o * d + s] = (1 - u) * n + u * p + i;
            } else t[o * d + s] = e[k[U] + M[U] * c];
          }
          U++;
        }
      }
    },
    T = [];
  let C;
  const B = h?.length === x,
    S = [];
  for (let t = 0; t < x; t++) {
    if (B) {
      const e = new Uint8Array(d * m);
      b(e, h[t], h[t], !0), S.push(e);
    }
    C = new p(d * m), b(C, r[t], B ? h[t] : a, "nearest" === s || "majority" === s), T.push(C);
  }
  const P = new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    width: d,
    height: m,
    pixelType: f,
    pixels: T,
    bandMasks: B ? S : void 0
  });
  if (null != a) P.mask = new Uint8Array(d * m), b(P.mask, a, a, !0);else if (g) {
    P.mask = new Uint8Array(d * m);
    for (let t = 0; t < d * m; t++) P.mask[t] = y[t] < 0 || w[t] < 0 ? 0 : 1;
  }
  return P.updateStatistics(), P;
}


/***/ }),

/***/ 62265:
/*!**************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertToLocalDirections": () => (/* binding */ u),
/* harmony export */   "convertVectorFieldData": () => (/* binding */ f),
/* harmony export */   "convertVectorFieldUnit": () => (/* binding */ p),
/* harmony export */   "createVFMesh": () => (/* binding */ U),
/* harmony export */   "createVFMeshScalar": () => (/* binding */ _),
/* harmony export */   "getUnitConversionFactor": () => (/* binding */ a),
/* harmony export */   "sampleVectorField": () => (/* binding */ S),
/* harmony export */   "snapImageToSymbolTile": () => (/* binding */ m),
/* harmony export */   "unitKebabDict": () => (/* binding */ s),
/* harmony export */   "uvComponentToVector": () => (/* binding */ l)
/* harmony export */ });
/* harmony import */ var _core_jsonMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/jsonMap.js */ 63321);
/* harmony import */ var _PixelBlock_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PixelBlock.js */ 53416);
/* harmony import */ var _pixelUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pixelUtils.js */ 26890);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/



const r = new Map();
r.set("meter-per-second", 1), r.set("kilometer-per-hour", .277778), r.set("knots", .514444), r.set("feet-per-second", .3048), r.set("mile-per-hour", .44704);
const o = 180 / Math.PI,
  i = 5,
  s = new _core_jsonMap_js__WEBPACK_IMPORTED_MODULE_0__.JSONMap({
    esriMetersPerSecond: "meter-per-second",
    esriKilometersPerHour: "kilometer-per-hour",
    esriKnots: "knots",
    esriFeetPerSecond: "feet-per-second",
    esriMilesPerHour: "mile-per-hour"
  });
function a(t, e) {
  return r.get(t) / r.get(e) || 1;
}
function h(t) {
  return (450 - t) % 360;
}
function l(t, e = "geographic") {
  const [n, r] = t,
    i = Math.sqrt(n * n + r * r);
  let s = Math.atan2(r, n) * o;
  return s = (360 + s) % 360, "geographic" === e && (s = h(s)), [i, s];
}
function c(t, e = "geographic") {
  let n = t[1];
  "geographic" === e && (n = h(n)), n %= 360;
  const r = t[0];
  return [r * Math.cos(n / o), r * Math.sin(n / o)];
}
function u(t, e, r, o = "geographic") {
  if (!(0,_pixelUtils_js__WEBPACK_IMPORTED_MODULE_2__.isValidPixelBlock)(t) || null == r) return t;
  const i = "vector-magdir" === e ? t.clone() : f(t, e),
    s = i.pixels[1];
  for (let n = 0; n < s.length; n++) s[n] = "geographic" === o ? (s[n] + r[n] + 270) % 360 : (s[n] + 360 - r[n]) % 360;
  return "vector-magdir" === e ? i : f(i, "vector-magdir");
}
function f(t, r, o = "geographic", i = 1) {
  if (!(0,_pixelUtils_js__WEBPACK_IMPORTED_MODULE_2__.isValidPixelBlock)(t)) return t;
  const {
      pixels: s,
      width: a,
      height: h
    } = t,
    u = a * h,
    f = s[0],
    p = s[1],
    m = t.pixelType.startsWith("f") ? t.pixelType : "f32",
    d = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_1__["default"].createEmptyBand(m, u),
    g = _PixelBlock_js__WEBPACK_IMPORTED_MODULE_1__["default"].createEmptyBand(m, u);
  let x = 0;
  for (let e = 0; e < h; e++) for (let t = 0; t < a; t++) "vector-uv" === r ? ([d[x], g[x]] = l([f[x], p[x]], o), d[x] *= i) : ([d[x], g[x]] = c([f[x], p[x]], o), d[x] *= i, g[x] *= i), x++;
  const M = new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
    pixelType: m,
    width: t.width,
    height: t.height,
    mask: t.mask,
    validPixelCount: t.validPixelCount,
    maskIsAlpha: t.maskIsAlpha,
    pixels: [d, g]
  });
  return M.updateStatistics(), M;
}
function p(t, e, r = 1) {
  if (1 === r || !(0,_pixelUtils_js__WEBPACK_IMPORTED_MODULE_2__.isValidPixelBlock)(t)) return t;
  const o = t.clone(),
    {
      pixels: i,
      width: s,
      height: a
    } = o,
    h = i[0],
    l = i[1];
  let c = 0;
  for (let n = 0; n < a; n++) for (let t = 0; t < s; t++) "vector-uv" === e ? (h[c] *= r, l[c] *= r) : h[c] *= r, c++;
  return o.updateStatistics(), o;
}
function m(t, e, n, r, o) {
  if (null == o || !o.spatialReference.equals(t.spatialReference)) return {
    extent: t,
    width: Math.round(e / r),
    height: Math.round(n / r),
    resolution: t.width / e
  };
  const i = o.xmin,
    s = o.ymax,
    a = (t.xmax - t.xmin) / e * r,
    h = (t.ymax - t.ymin) / n * r,
    l = (a + h) / 2;
  return t.xmin = i + Math.floor((t.xmin - i) / a) * a, t.xmax = i + Math.ceil((t.xmax - i) / a) * a, t.ymin = s + Math.floor((t.ymin - s) / h) * h, t.ymax = s + Math.ceil((t.ymax - s) / h) * h, {
    extent: t,
    width: Math.round(t.width / a),
    height: Math.round(t.height / h),
    resolution: l
  };
}
const d = g(0, 0, 0);
function g(t = 0, e = 0, n = Math.PI, r = !0) {
  r && (n = (2 * Math.PI - n) % (2 * Math.PI));
  const o = r ? -1 : 1,
    i = 13 * o,
    s = -7 * o,
    a = -2 * o,
    h = -16 * o,
    l = 21.75,
    [c, u] = M(0, e + i, n, l),
    [f, p] = M(t - 5.5, e + s, n, l),
    [m, d] = M(t + 5.5, e + s, n, l),
    [g, x] = M(t - 1.5, e + a, n, l),
    [k, w] = M(t + 1.5, e + a, n, l),
    [y, P] = M(t - 1.5, e + h, n, l),
    [b, v] = M(t + 1.5, e + h, n, l);
  return [c, u, f, p, g, x, k, w, m, d, y, P, b, v];
}
function x(t = 0, e = Math.PI, n = !0) {
  n && (e = (2 * Math.PI - e) % (2 * Math.PI));
  const r = 10,
    o = n ? -1 : 1,
    s = 5 * o,
    a = 20 * o,
    h = 25 * o,
    l = 45,
    c = 0,
    u = 0,
    f = 2,
    p = 0,
    m = f * o,
    d = n ? 1 : -1,
    g = r / 2 * d;
  let [x, k] = [c + g, u - a],
    [w, y] = [x + f * d, k],
    [P, b] = [w - p * d, y + m],
    [v, I] = [c - g, u - h],
    [A, _] = [v + p * d, I - m],
    U = Math.ceil(t / i),
    S = Math.floor(U / 10);
  U -= 8 * S;
  const D = [],
    F = [];
  for (let i = 0; i < U / 2; i++, S--) {
    S <= 0 && U % 2 == 1 && i === (U - 1) / 2 && (v = c, A = v + p * d, I = (I + k) / 2, _ = I - m);
    const [t, n] = M(v, I, e, l);
    if (S > 0) {
      const [r, o] = M(w, I, e, l),
        [i, s] = M(x, k, e, l);
      D.push(r), D.push(o), D.push(t), D.push(n), D.push(i), D.push(s);
    } else {
      const [r, o] = M(w, y, e, l),
        [i, s] = M(P, b, e, l),
        [a, h] = M(A, _, e, l);
      F.push(t), F.push(n), F.push(a), F.push(h), F.push(i), F.push(s), F.push(r), F.push(o);
    }
    I += s, k += s, y += s, b += s, _ += s;
  }
  const [N, j] = M(c + g, u + a, e, l),
    J = (r / 2 + f) * d,
    [O, q] = M(c + J, u + a, e, l),
    [B, E] = M(c + g, u - h, e, l),
    [T, C] = M(c + J, u - h, e, l);
  return {
    pennants: D,
    barbs: F,
    shaft: [N, j, O, q, B, E, T, C]
  };
}
function M(t, e, n, r = 1) {
  const o = Math.sqrt(t * t + e * e) / r,
    i = (2 * Math.PI + Math.atan2(e, t)) % (2 * Math.PI);
  return [o, (2 * Math.PI + i - n) % (2 * Math.PI)];
}
const k = [0, 1, 3, 6, 10, 16, 21, 27, 33, 40, 47, 55, 63],
  w = [0, .5, 1, 1.5, 2],
  y = [0, .25, .5, 1, 1.5, 2, 2.5, 3, 3.5, 4];
function P(t, e, n, r) {
  const o = a(r || "knots", n);
  let i;
  for (i = 1; i < e.length; i++) if (i === e.length - 1) {
    if (t < e[i] * o) break;
  } else if (t <= e[i] * o) break;
  return Math.min(i - 1, e.length - 2);
}
function b(t, e, n, r, o) {
  let i = 0;
  switch (e) {
    case "beaufort_kn":
      i = P(t, k, "knots", n);
      break;
    case "beaufort_km":
      i = P(t, k, "kilometer-per-hour", n);
      break;
    case "beaufort_ft":
      i = P(t, k, "feet-per-second", n);
      break;
    case "beaufort_m":
      i = P(t, k, "meter-per-second", n);
      break;
    case "classified_arrow":
      i = P(t, o ?? [], r, n);
      break;
    case "ocean_current_m":
      i = P(t, w, "meter-per-second", n);
      break;
    case "ocean_current_kn":
      i = P(t, y, "knots", n);
  }
  return i;
}
function v(t, e) {
  const {
      style: n,
      inputUnit: r,
      outputUnit: o,
      breakValues: i
    } = e,
    a = s.fromJSON(r),
    h = s.fromJSON(o),
    l = 7 * 6,
    c = 15;
  let u = 0,
    f = 0;
  const {
      width: p,
      height: m,
      mask: x
    } = t,
    M = t.pixels[0],
    k = t.pixels[1],
    w = null != x ? x.filter(t => t > 0).length : p * m,
    y = new Float32Array(w * l),
    P = new Uint32Array(c * w),
    v = e.invertDirection ? g(0, 0, 0, !1) : d;
  for (let s = 0; s < m; s++) for (let t = 0; t < p; t++) {
    const e = s * p + t;
    if (!x || x[s * p + t]) {
      const r = (k[e] + 360) % 360 / 180 * Math.PI,
        o = b(M[e], n, a, h, i);
      for (let n = 0; n < v.length; n += 2) y[u++] = (t + .5) / p, y[u++] = (s + .5) / m, y[u++] = v[n], y[u++] = v[n + 1] + r, y[u++] = o, y[u++] = M[e];
      const c = 7 * (u / l - 1);
      P[f++] = c, P[f++] = c + 1, P[f++] = c + 2, P[f++] = c + 0, P[f++] = c + 4, P[f++] = c + 3, P[f++] = c + 0, P[f++] = c + 2, P[f++] = c + 3, P[f++] = c + 2, P[f++] = c + 5, P[f++] = c + 3, P[f++] = c + 5, P[f++] = c + 6, P[f++] = c + 3;
    }
  }
  return {
    vertexData: y,
    indexData: P
  };
}
const I = [];
function A(t, e) {
  if (0 === I.length) for (let i = 0; i < 30; i++) I.push(x(5 * i, 0, !e.invertDirection));
  const n = a(s.fromJSON(e.inputUnit), "knots"),
    {
      width: r,
      height: o,
      mask: h
    } = t,
    l = t.pixels[0],
    c = t.pixels[1],
    u = 6,
    f = [],
    p = [];
  let m = 0,
    d = 0;
  for (let s = 0; s < o; s++) for (let t = 0; t < r; t++) {
    const e = s * r + t,
      a = l[e] * n;
    if ((!h || h[s * r + t]) && a >= i) {
      const n = (c[e] + 360) % 360 / 180 * Math.PI,
        {
          pennants: i,
          barbs: h,
          shaft: l
        } = I[Math.min(Math.floor(a / 5), 29)];
      if (i.length + h.length === 0) continue;
      let g = f.length / u;
      const x = (t + .5) / r,
        M = (s + .5) / o;
      for (let t = 0; t < i.length; t += 2) f[m++] = x, f[m++] = M, f[m++] = i[t], f[m++] = i[t + 1] + n, f[m++] = 0, f[m++] = a;
      for (let t = 0; t < h.length; t += 2) f[m++] = x, f[m++] = M, f[m++] = h[t], f[m++] = h[t + 1] + n, f[m++] = 0, f[m++] = a;
      for (let t = 0; t < l.length; t += 2) f[m++] = x, f[m++] = M, f[m++] = l[t], f[m++] = l[t + 1] + n, f[m++] = 0, f[m++] = a;
      for (let t = 0; t < i.length / 6; t++) p[d++] = g, p[d++] = g + 1, p[d++] = g + 2, g += 3;
      for (let t = 0; t < h.length / 8; t++) p[d++] = g, p[d++] = g + 1, p[d++] = g + 2, p[d++] = g + 1, p[d++] = g + 2, p[d++] = g + 3, g += 4;
      p[d++] = g + 0, p[d++] = g + 1, p[d++] = g + 2, p[d++] = g + 1, p[d++] = g + 3, p[d++] = g + 2, g += 4;
    }
  }
  return {
    vertexData: new Float32Array(f),
    indexData: new Uint32Array(p)
  };
}
function _(t, e) {
  const n = 4 * 6;
  let r = 0,
    o = 0;
  const {
      width: h,
      height: l,
      mask: c
    } = t,
    u = t.pixels[0],
    f = [],
    p = [],
    m = a(s.fromJSON(e.inputUnit), "knots"),
    d = "wind_speed" === e.style ? i : Number.MAX_VALUE;
  for (let i = 0; i < l; i++) for (let t = 0; t < h; t++) {
    const e = u[i * h + t] * m;
    if ((!c || c[i * h + t]) && e < d) {
      for (let n = 0; n < 4; n++) f[r++] = (t + .5) / h, f[r++] = (i + .5) / l, f[r++] = n < 2 ? -.5 : .5, f[r++] = n % 2 == 0 ? -.5 : .5, f[r++] = 0, f[r++] = e;
      const s = 4 * (r / n - 1);
      p[o++] = s, p[o++] = s + 1, p[o++] = s + 2, p[o++] = s + 1, p[o++] = s + 2, p[o++] = s + 3;
    }
  }
  return {
    vertexData: new Float32Array(f),
    indexData: new Uint32Array(p)
  };
}
function U(t, e) {
  return "simple_scalar" === e.style ? _(t, e) : "wind_speed" === e.style ? A(t, e) : v(t, e);
}
function S(t, n, r, o = [0, 0], i = .5) {
  const {
      width: s,
      height: a,
      mask: h
    } = t,
    [u, f] = t.pixels,
    [p, m] = o,
    d = Math.round((s - p) / r),
    g = Math.round((a - m) / r),
    x = d * g,
    M = new Float32Array(x),
    k = new Float32Array(x),
    w = new Uint8Array(x),
    y = "vector-uv" === n;
  for (let e = 0; e < g; e++) for (let t = 0; t < d; t++) {
    let n = 0;
    const o = e * d + t,
      g = Math.max(0, e * r + m),
      x = Math.max(0, t * r + p),
      P = Math.min(a, g + r),
      b = Math.min(s, x + r);
    for (let t = g; t < P; t++) for (let e = x; e < b; e++) {
      const r = t * s + e;
      if (!h || h[r]) {
        n++;
        const t = y ? [u[r], f[r]] : [u[r], (360 + f[r]) % 360],
          [e, i] = y ? t : c(t);
        M[o] += e, k[o] += i;
      }
    }
    if (n >= (P - g) * (b - x) * (1 - i)) {
      w[o] = 1;
      const [t, e] = l([M[o] / n, k[o] / n]);
      M[o] = t, k[o] = e;
    } else w[o] = 0, M[o] = 0, k[o] = 0;
  }
  const P = new _PixelBlock_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
    width: d,
    height: g,
    pixels: [M, k],
    mask: w
  });
  return P.updateStatistics(), P;
}


/***/ }),

/***/ 45809:
/*!*********************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAnimatedLinesData": () => (/* binding */ m),
/* harmony export */   "createFlowMesh": () => (/* binding */ s),
/* harmony export */   "createParticlesMesh": () => (/* binding */ w),
/* harmony export */   "createStreamlinesMesh": () => (/* binding */ d),
/* harmony export */   "loadImagery": () => (/* binding */ g)
/* harmony export */ });
/* harmony import */ var _home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _geometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../geometry.js */ 6010);
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../core/has.js */ 67087);
/* harmony import */ var _core_Logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../core/Logger.js */ 28191);
/* harmony import */ var _core_mathUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../core/mathUtils.js */ 93142);
/* harmony import */ var _core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../core/promiseUtils.js */ 30801);
/* harmony import */ var _core_RandomLCG_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../core/RandomLCG.js */ 37313);
/* harmony import */ var _geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../geometry/support/spatialReferenceUtils.js */ 53492);
/* harmony import */ var _geometry_Extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../geometry/Extent.js */ 10465);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/








const i = _core_Logger_js__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("esri.views.2d.engine.flow.dataUtils"),
  a = 10;
function s(_x, _x2, _x3, _x4) {
  return _s.apply(this, arguments);
}
function _s() {
  _s = (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (t, e, r, o) {
    const l = performance.now(),
      s = c(e, r),
      f = performance.now(),
      h = u(e, s, r.width, r.height),
      p = performance.now(),
      g = m(h, !0),
      y = performance.now(),
      x = "Streamlines" === t ? d(g, a) : w(g),
      M = performance.now();
    return (0,_core_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])("esri-2d-profiler") && (i.info("I.1", "_createFlowFieldFromData (ms)", Math.round(f - l)), i.info("I.2", "_getStreamlines (ms)", Math.round(p - f)), i.info("I.3", "createAnimatedLinesData (ms)", Math.round(y - p)), i.info("I.4", "create{Streamlines|Particles}Mesh (ms)", Math.round(M - y)), i.info("I.5", "createFlowMesh (ms)", Math.round(M - l)), i.info("I.6", "Mesh size (bytes)", x.vertexData.buffer.byteLength + x.indexData.buffer.byteLength)), yield Promise.resolve(), (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_5__.throwIfAborted)(o), x;
  });
  return _s.apply(this, arguments);
}
function c(t, e) {
  const n = h(e.data, e.width, e.height, t.smoothing);
  if (t.interpolate) {
    return (t, r) => {
      const o = Math.floor(t),
        l = Math.floor(r);
      if (o < 0 || o >= e.width) return [0, 0];
      if (l < 0 || l >= e.height) return [0, 0];
      const i = t - o,
        a = r - l,
        s = o,
        c = l,
        f = o < e.width - 1 ? o + 1 : o,
        u = l < e.height - 1 ? l + 1 : l,
        h = n[2 * (c * e.width + s)],
        m = n[2 * (c * e.width + f)],
        d = n[2 * (u * e.width + s)],
        w = n[2 * (u * e.width + f)],
        p = n[2 * (c * e.width + s) + 1],
        g = n[2 * (c * e.width + f) + 1];
      return [(h * (1 - a) + d * a) * (1 - i) + (m * (1 - a) + w * a) * i, (p * (1 - a) + n[2 * (u * e.width + s) + 1] * a) * (1 - i) + (g * (1 - a) + n[2 * (u * e.width + f) + 1] * a) * i];
    };
  }
  return (t, r) => {
    const o = Math.round(t),
      l = Math.round(r);
    return o < 0 || o >= e.width || l < 0 || l >= e.height ? [0, 0] : [n[2 * (l * e.width + o)], n[2 * (l * e.width + o) + 1]];
  };
}
function f(t, e, n, r, o, l, i, a, s) {
  const c = [];
  let f = n,
    u = r,
    h = 0,
    [m, d] = e(f, u);
  m *= t.velocityScale, d *= t.velocityScale;
  const w = Math.sqrt(m * m + d * d);
  let p, g;
  c.push({
    x: f,
    y: u,
    t: h,
    speed: w
  });
  for (let y = 0; y < t.verticesPerLine; y++) {
    let [n, r] = e(f, u);
    n *= t.velocityScale, r *= t.velocityScale;
    const m = Math.sqrt(n * n + r * r);
    if (m < t.minSpeedThreshold) return c;
    const d = n / m,
      w = r / m;
    f += d * t.segmentLength, u += w * t.segmentLength;
    if (h += t.segmentLength / m, Math.acos(d * p + w * g) > t.maxTurnAngle) return c;
    if (t.collisions) {
      const t = Math.round(f * s),
        e = Math.round(u * s);
      if (t < 0 || t > i - 1 || e < 0 || e > a - 1) return c;
      const n = l[e * i + t];
      if (-1 !== n && n !== o) return c;
      l[e * i + t] = o;
    }
    c.push({
      x: f,
      y: u,
      t: h,
      speed: m
    }), p = d, g = w;
  }
  return c;
}
function u(t, e, n, o) {
  const l = [],
    i = new _core_RandomLCG_js__WEBPACK_IMPORTED_MODULE_6__["default"](),
    a = 1 / Math.max(t.lineCollisionWidth, 1),
    s = Math.round(n * a),
    c = Math.round(o * a),
    u = new Int32Array(s * c);
  for (let r = 0; r < u.length; r++) u[r] = -1;
  const h = [];
  for (let r = 0; r < o; r += t.lineSpacing) for (let e = 0; e < n; e += t.lineSpacing) h.push({
    x: e,
    y: r,
    sort: i.getFloat()
  });
  h.sort((t, e) => t.sort - e.sort);
  for (const {
    x: r,
    y: m
  } of h) if (i.getFloat() < t.density) {
    const n = f(t, e, r, m, l.length, u, s, c, a);
    if (n.length < 2) continue;
    l.push(n);
  }
  return l;
}
function h(t, e, n, r) {
  if (0 === r) return t;
  const o = Math.round(3 * r),
    l = new Array(2 * o + 1);
  let i = 0;
  for (let c = -o; c <= o; c++) {
    const t = Math.exp(-c * c / (r * r));
    l[c + o] = t, i += t;
  }
  for (let c = -o; c <= o; c++) l[c + o] /= i;
  const a = new Float32Array(t.length);
  for (let c = 0; c < n; c++) for (let n = 0; n < e; n++) {
    let r = 0,
      i = 0;
    for (let a = -o; a <= o; a++) {
      if (n + a < 0 || n + a >= e) continue;
      const s = l[a + o];
      r += s * t[2 * (c * e + (n + a))], i += s * t[2 * (c * e + (n + a)) + 1];
    }
    a[2 * (c * e + n)] = r, a[2 * (c * e + n) + 1] = i;
  }
  const s = new Float32Array(t.length);
  for (let c = 0; c < e; c++) for (let t = 0; t < n; t++) {
    let r = 0,
      i = 0;
    for (let s = -o; s <= o; s++) {
      if (t + s < 0 || t + s >= n) continue;
      const f = l[s + o];
      r += f * a[2 * ((t + s) * e + c)], i += f * a[2 * ((t + s) * e + c) + 1];
    }
    s[2 * (t * e + c)] = r, s[2 * (t * e + c) + 1] = i;
  }
  return s;
}
function m(t, e) {
  const n = new _core_RandomLCG_js__WEBPACK_IMPORTED_MODULE_6__["default"](),
    o = t.reduce((t, e) => t + e.length, 0),
    l = new Float32Array(4 * o),
    i = new Array(t.length);
  let a = 0,
    s = 0;
  for (const r of t) {
    const t = a;
    for (const e of r) l[4 * a] = e.x, l[4 * a + 1] = e.y, l[4 * a + 2] = e.t, l[4 * a + 3] = e.speed, a++;
    i[s++] = {
      startVertex: t,
      numberOfVertices: r.length,
      totalTime: r[r.length - 1].t,
      timeSeed: e ? n.getFloat() : 0
    };
  }
  return {
    lineVertices: l,
    lineDescriptors: i
  };
}
function d(t, e) {
  const n = 9,
    {
      lineVertices: r,
      lineDescriptors: o
    } = t;
  let l = 0,
    i = 0;
  for (const m of o) {
    l += 2 * m.numberOfVertices;
    i += 6 * (m.numberOfVertices - 1);
  }
  const a = new Float32Array(l * n),
    s = new Uint32Array(i);
  let c = 0,
    f = 0;
  function u() {
    s[f++] = c - 2, s[f++] = c, s[f++] = c - 1, s[f++] = c, s[f++] = c + 1, s[f++] = c - 1;
  }
  function h(t, e, r, o, l, i, s, f) {
    const u = c * n;
    let h = 0;
    a[u + h++] = t, a[u + h++] = e, a[u + h++] = 1, a[u + h++] = r, a[u + h++] = i, a[u + h++] = s, a[u + h++] = o / 2, a[u + h++] = l / 2, a[u + h++] = f, c++, a[u + h++] = t, a[u + h++] = e, a[u + h++] = -1, a[u + h++] = r, a[u + h++] = i, a[u + h++] = s, a[u + h++] = -o / 2, a[u + h++] = -l / 2, a[u + h++] = f, c++;
  }
  for (const m of o) {
    const {
      totalTime: t,
      timeSeed: n
    } = m;
    let o = null,
      l = null,
      i = null,
      a = null,
      s = null,
      c = null;
    for (let f = 0; f < m.numberOfVertices; f++) {
      const d = r[4 * (m.startVertex + f)],
        w = r[4 * (m.startVertex + f) + 1],
        p = r[4 * (m.startVertex + f) + 2],
        g = r[4 * (m.startVertex + f) + 3];
      let y = null,
        x = null,
        M = null,
        A = null;
      if (f > 0) {
        y = d - o, x = w - l;
        const r = Math.sqrt(y * y + x * x);
        if (y /= r, x /= r, f > 1) {
          let t = y + s,
            n = x + c;
          const r = Math.sqrt(t * t + n * n);
          t /= r, n /= r;
          const o = Math.min(1 / (t * y + n * x), e);
          t *= o, n *= o, M = -n, A = t;
        } else M = -x, A = y;
        null !== M && null !== A && (h(o, l, i, M, A, t, n, g), u());
      }
      o = d, l = w, i = p, s = y, c = x, a = g;
    }
    h(o, l, i, -c, s, t, n, a);
  }
  return {
    vertexData: a,
    indexData: s
  };
}
function w(t) {
  const e = 16,
    n = 1,
    r = 2,
    {
      lineVertices: o,
      lineDescriptors: l
    } = t;
  let i = 0,
    a = 0;
  for (const U of l) {
    const t = U.numberOfVertices - 1;
    i += 4 * t * 2, a += 6 * t * 2;
  }
  const s = new Float32Array(i * e),
    c = new Uint32Array(a);
  let f,
    u,
    h,
    m,
    d,
    w,
    p,
    g,
    y,
    x,
    M,
    A,
    I,
    V,
    F = 0,
    v = 0;
  function D() {
    c[v++] = F - 8, c[v++] = F - 7, c[v++] = F - 6, c[v++] = F - 7, c[v++] = F - 5, c[v++] = F - 6, c[v++] = F - 4, c[v++] = F - 3, c[v++] = F - 2, c[v++] = F - 3, c[v++] = F - 1, c[v++] = F - 2;
  }
  function b(t, o, l, i, a, c, f, u, h, m, d, w, p, g) {
    const y = F * e;
    let x = 0;
    for (const e of [n, r]) for (const n of [1, 2, 3, 4]) s[y + x++] = t, s[y + x++] = o, s[y + x++] = l, s[y + x++] = i, s[y + x++] = f, s[y + x++] = u, s[y + x++] = h, s[y + x++] = m, s[y + x++] = e, s[y + x++] = n, s[y + x++] = p, s[y + x++] = g, s[y + x++] = a / 2, s[y + x++] = c / 2, s[y + x++] = d / 2, s[y + x++] = w / 2, F++;
  }
  function S(t, e) {
    let n = y + M,
      r = x + A;
    const o = Math.sqrt(n * n + r * r);
    n /= o, r /= o;
    const l = y * n + x * r;
    n /= l, r /= l;
    let i = M + I,
      a = A + V;
    const s = Math.sqrt(i * i + a * a);
    i /= s, a /= s;
    const c = M * i + A * a;
    i /= c, a /= c, b(f, u, h, m, -r, n, d, w, p, g, -a, i, t, e), D();
  }
  function k(t, e, n, r, o, l) {
    if (y = M, x = A, M = I, A = V, null == y && null == x && (y = M, x = A), null != d && null != w) {
      I = t - d, V = e - w;
      const n = Math.sqrt(I * I + V * V);
      I /= n, V /= n;
    }
    null != y && null != x && S(o, l), f = d, u = w, h = p, m = g, d = t, w = e, p = n, g = r;
  }
  function L(t, e) {
    y = M, x = A, M = I, A = V, null == y && null == x && (y = M, x = A), null != y && null != x && S(t, e);
  }
  for (const U of l) {
    f = null, u = null, h = null, m = null, d = null, w = null, p = null, g = null, y = null, x = null, M = null, A = null, I = null, V = null;
    const {
      totalTime: t,
      timeSeed: e
    } = U;
    for (let n = 0; n < U.numberOfVertices; n++) {
      k(o[4 * (U.startVertex + n)], o[4 * (U.startVertex + n) + 1], o[4 * (U.startVertex + n) + 2], o[4 * (U.startVertex + n) + 3], t, e);
    }
    L(t, e);
  }
  return {
    vertexData: s,
    indexData: c
  };
}
function p(t, n) {
  const r = n.pixels,
    {
      width: o,
      height: l
    } = n,
    i = new Float32Array(o * l * 2),
    a = n.mask || new Uint8Array(o * l * 2);
  if (n.mask || a.fill(255), "vector-uv" === t) for (let e = 0; e < o * l; e++) i[2 * e] = r[0][e], i[2 * e + 1] = -r[1][e];else if ("vector-magdir" === t) for (let s = 0; s < o * l; s++) {
    const t = r[0][s],
      n = (0,_core_mathUtils_js__WEBPACK_IMPORTED_MODULE_4__.deg2rad)(r[1][s]),
      o = Math.cos(n - Math.PI / 2),
      l = Math.sin(n - Math.PI / 2);
    i[2 * s] = o * t, i[2 * s + 1] = l * t;
  }
  return {
    data: i,
    mask: a,
    width: o,
    height: l
  };
}
function g(_x5, _x6, _x7, _x8, _x9, _x10) {
  return _g.apply(this, arguments);
}
function _g() {
  _g = (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (t, e, n, r, a, s) {
    const c = performance.now(),
      f = (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_7__.getInfo)(e.spatialReference);
    if (!f) {
      const o = yield y(t, e, n, r, a, s);
      return (0,_core_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])("esri-2d-profiler") && i.info("I.7", "loadImagery, early exit (ms)", Math.round(performance.now() - c)), (0,_core_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])("esri-2d-profiler") && i.info("I.9", "Number of parts", 1), o;
    }
    const [u, h] = f.valid,
      m = h - u,
      d = Math.ceil(e.width / m),
      w = e.width / d,
      p = Math.round(n / d);
    let g = e.xmin;
    const x = [],
      M = performance.now();
    for (let o = 0; o < d; o++) {
      const n = new _geometry_Extent_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
        xmin: g,
        xmax: g + w,
        ymin: e.ymin,
        ymax: e.ymax,
        spatialReference: e.spatialReference
      });
      x.push(y(t, n, p, r, a, s)), g += w;
    }
    const A = yield Promise.all(x);
    (0,_core_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])("esri-2d-profiler") && i.info("I.8", "All calls to _fetchPart (ms)", Math.round(performance.now() - M)), (0,_core_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])("esri-2d-profiler") && i.info("I.9", "Number of parts", A.length);
    const I = {
      data: new Float32Array(n * r * 2),
      mask: new Uint8Array(n * r),
      width: n,
      height: r
    };
    let V = 0;
    for (const o of A) {
      for (let t = 0; t < o.height; t++) for (let e = 0; e < o.width; e++) V + e >= n || (I.data[2 * (t * n + V + e)] = o.data[2 * (t * o.width + e)], I.data[2 * (t * n + V + e) + 1] = o.data[2 * (t * o.width + e) + 1], I.mask[t * n + V + e] = o.mask[t * o.width + e]);
      V += o.width;
    }
    return (0,_core_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])("esri-2d-profiler") && i.info("I.10", "loadImagery, general exit (ms)", Math.round(performance.now() - c)), I;
  });
  return _g.apply(this, arguments);
}
function y(_x11, _x12, _x13, _x14, _x15, _x16) {
  return _y.apply(this, arguments);
}
function _y() {
  _y = (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (t, e, n, r, o, l) {
    const i = {
      requestProjectedLocalDirections: !0,
      signal: l
    };
    if (null != o && (i.timeExtent = o), "imagery" === t.type) {
      yield t.load({
        signal: l
      });
      const o = t.rasterInfo.dataType,
        a = yield t.fetchImage(e, n, r, i);
      return null == a?.pixelData?.pixelBlock ? {
        data: new Float32Array(n * r * 2),
        mask: new Uint8Array(n * r),
        width: n,
        height: r
      } : p(o, a.pixelData.pixelBlock);
    }
    yield t.load({
      signal: l
    });
    const a = t.rasterInfo.dataType,
      s = yield t.fetchPixels(e, n, r, i);
    return null == s?.pixelBlock ? {
      data: new Float32Array(n * r * 2),
      mask: new Uint8Array(n * r),
      width: n,
      height: r
    } : p(a, s.pixelBlock);
  });
  return _y.apply(this, arguments);
}


/***/ })

}]);
//# sourceMappingURL=default-node_modules_arcgis_core_layers_support_rasterFunctions_vectorFieldUtils_js-node_modu-8bb3a8.js.map