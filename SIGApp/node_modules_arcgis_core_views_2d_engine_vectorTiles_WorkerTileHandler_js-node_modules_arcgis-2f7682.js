"use strict";
(self["webpackChunkrealgis"] = self["webpackChunkrealgis"] || []).push([["node_modules_arcgis_core_views_2d_engine_vectorTiles_WorkerTileHandler_js-node_modules_arcgis-2f7682"],{

/***/ 74617:
/*!***********************************************!*\
  !*** ./node_modules/@arcgis/core/core/pbf.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ r)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has.js */ 67087);
/* harmony import */ var _ObjectPool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectPool.js */ 5261);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/


var e;
!function (t) {
  t[t.varint = 0] = "varint", t[t.fixed64 = 1] = "fixed64", t[t.delimited = 2] = "delimited", t[t.fixed32 = 5] = "fixed32", t[t.unknown = 99] = "unknown";
}(e || (e = {}));
const i = 4294967296,
  s = new TextDecoder("utf-8"),
  n = (0,_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("safari") || (0,_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("ios") ? 6 : (0,_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("ff") ? 12 : 32;
class r {
  constructor(t, i, s = 0, n = t ? t.byteLength : 0) {
    this._tag = 0, this._dataType = e.unknown, this._init(t, i, s, n);
  }
  _init(t, e, i, s) {
    this._data = t, this._dataView = e, this._pos = i, this._end = s;
  }
  asUnsafe() {
    return this;
  }
  clone() {
    return new r(this._data, this._dataView, this._pos, this._end);
  }
  pos() {
    return this._pos;
  }
  move(t) {
    this._pos = t;
  }
  nextTag(t) {
    for (;;) {
      if (this._pos === this._end) return !1;
      const e = this._decodeVarint();
      if (this._tag = e >> 3, this._dataType = 7 & e, !t || t === this._tag) break;
      this.skip();
    }
    return !0;
  }
  next() {
    if (this._pos === this._end) return !1;
    const t = this._decodeVarint();
    return this._tag = t >> 3, this._dataType = 7 & t, !0;
  }
  empty() {
    return this._pos >= this._end;
  }
  tag() {
    return this._tag;
  }
  getInt32() {
    return this._decodeVarint();
  }
  getInt64() {
    return this._decodeVarint();
  }
  getUInt32() {
    let t = 4294967295;
    return t = (127 & this._data[this._pos]) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 7) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 14) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 21) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (15 & this._data[this._pos]) << 28) >>> 0, this._data[this._pos++] < 128 ? t : void 0))));
  }
  getUInt64() {
    return this._decodeVarint();
  }
  getSInt32() {
    const t = this.getUInt32();
    if (void 0 !== t) return t >>> 1 ^ -(1 & t) | 0;
  }
  getSInt64() {
    return this._decodeSVarint();
  }
  getBool() {
    const t = 0 !== this._data[this._pos];
    return this._skip(1), t;
  }
  getEnum() {
    return this._decodeVarint();
  }
  getFixed64() {
    const t = this._dataView,
      e = this._pos,
      s = t.getUint32(e, !0) + t.getUint32(e + 4, !0) * i;
    return this._skip(8), s;
  }
  getSFixed64() {
    const t = this._dataView,
      e = this._pos,
      s = t.getUint32(e, !0) + t.getInt32(e + 4, !0) * i;
    return this._skip(8), s;
  }
  getDouble() {
    const t = this._dataView.getFloat64(this._pos, !0);
    return this._skip(8), t;
  }
  getFixed32() {
    const t = this._dataView.getUint32(this._pos, !0);
    return this._skip(4), t;
  }
  getSFixed32() {
    const t = this._dataView.getInt32(this._pos, !0);
    return this._skip(4), t;
  }
  getFloat() {
    const t = this._dataView.getFloat32(this._pos, !0);
    return this._skip(4), t;
  }
  getString() {
    const t = this._getLength(),
      e = this._pos,
      i = this._toString(this._data, e, e + t);
    return this._skip(t), i;
  }
  getBytes() {
    const t = this._getLength(),
      e = this._pos,
      i = this._toBytes(this._data, e, e + t);
    return this._skip(t), i;
  }
  getLength() {
    return this._getLengthUnsafe();
  }
  processMessageWithArgs(t, e, i, s) {
    const n = this.getMessage(),
      r = t(n, e, i, s);
    return n.release(), r;
  }
  processMessage(t) {
    const e = this.getMessage(),
      i = t(e);
    return e.release(), i;
  }
  getMessage() {
    const t = this._getLength(),
      e = r.pool.acquire();
    return e._init(this._data, this._dataView, this._pos, this._pos + t), this._skip(t), e;
  }
  release() {
    r.pool.release(this);
  }
  dataType() {
    return this._dataType;
  }
  skip() {
    switch (this._dataType) {
      case e.varint:
        this._decodeVarint();
        break;
      case e.fixed64:
        this._skip(8);
        break;
      case e.delimited:
        this._skip(this._getLength());
        break;
      case e.fixed32:
        this._skip(4);
        break;
      default:
        throw new Error("Invalid data type!");
    }
  }
  skipLen(t) {
    this._skip(t);
  }
  _skip(t) {
    if (this._pos + t > this._end) throw new Error("Attempt to skip past the end of buffer!");
    this._pos += t;
  }
  _decodeVarint() {
    const t = this._data;
    let e = this._pos,
      i = 0,
      s = 0;
    if (this._end - e >= 10) do {
      if (s = t[e++], i |= 127 & s, 0 == (128 & s)) break;
      if (s = t[e++], i |= (127 & s) << 7, 0 == (128 & s)) break;
      if (s = t[e++], i |= (127 & s) << 14, 0 == (128 & s)) break;
      if (s = t[e++], i |= (127 & s) << 21, 0 == (128 & s)) break;
      if (s = t[e++], i += 268435456 * (127 & s), 0 == (128 & s)) break;
      if (s = t[e++], i += 34359738368 * (127 & s), 0 == (128 & s)) break;
      if (s = t[e++], i += 4398046511104 * (127 & s), 0 == (128 & s)) break;
      if (s = t[e++], i += 562949953421312 * (127 & s), 0 == (128 & s)) break;
      if (s = t[e++], i += 72057594037927940 * (127 & s), 0 == (128 & s)) break;
      if (s = t[e++], i += 0x8000000000000000 * (127 & s), 0 == (128 & s)) break;
      throw new Error("Varint too long!");
    } while (0);else {
      let n = 1;
      for (; e !== this._end && (s = t[e], 0 != (128 & s));) ++e, i += (127 & s) * n, n *= 128;
      if (e === this._end) throw new Error("Varint overrun!");
      ++e, i += s * n;
    }
    return this._pos = e, i;
  }
  _decodeSVarint() {
    const t = this._data;
    let e,
      i = 0,
      s = 0;
    const n = 1 & t[this._pos];
    if (s = t[this._pos++], i |= 127 & s, 0 == (128 & s)) return n ? -(i + 1) / 2 : i / 2;
    if (s = t[this._pos++], i |= (127 & s) << 7, 0 == (128 & s)) return n ? -(i + 1) / 2 : i / 2;
    if (s = t[this._pos++], i |= (127 & s) << 14, 0 == (128 & s)) return n ? -(i + 1) / 2 : i / 2;
    if (s = t[this._pos++], i |= (127 & s) << 21, 0 == (128 & s)) return n ? -(i + 1) / 2 : i / 2;
    if (s = t[this._pos++], i += 268435456 * (127 & s), 0 == (128 & s)) return n ? -(i + 1) / 2 : i / 2;
    if (s = t[this._pos++], i += 34359738368 * (127 & s), 0 == (128 & s)) return n ? -(i + 1) / 2 : i / 2;
    if (s = t[this._pos++], i += 4398046511104 * (127 & s), 0 == (128 & s)) return n ? -(i + 1) / 2 : i / 2;
    if (e = BigInt(i), s = t[this._pos++], e += 0x2000000000000n * BigInt(127 & s), 0 == (128 & s)) return Number(n ? -(e + 1n) / 2n : e / 2n);
    if (s = t[this._pos++], e += 0x100000000000000n * BigInt(127 & s), 0 == (128 & s)) return Number(n ? -(e + 1n) / 2n : e / 2n);
    if (s = t[this._pos++], e += 0x8000000000000000n * BigInt(127 & s), 0 == (128 & s)) return Number(n ? -(e + 1n) / 2n : e / 2n);
    throw new Error("Varint too long!");
  }
  _getLength() {
    if (this._dataType !== e.delimited) throw new Error("Not a delimited data type!");
    return this._decodeVarint();
  }
  _getLengthUnsafe() {
    return this.getUInt32();
  }
  _toString(t, e, i) {
    if ((i = Math.min(this._end, i)) - e > n) {
      const n = t.subarray(e, i);
      return s.decode(n);
    }
    let r = "",
      h = "";
    for (let s = e; s < i; ++s) {
      const e = t[s];
      128 & e ? h += "%" + e.toString(16) : (r += decodeURIComponent(h) + String.fromCharCode(e), h = "");
    }
    return h.length && (r += decodeURIComponent(h)), r;
  }
  _toBytes(t, e, i) {
    return i = Math.min(this._end, i), new Uint8Array(t.buffer, e, i - e);
  }
}
r.pool = new _ObjectPool_js__WEBPACK_IMPORTED_MODULE_1__["default"](r, void 0, t => {
  t._data = null, t._dataView = null;
});


/***/ }),

/***/ 15569:
/*!**************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/Feature.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ s)
/* harmony export */ });
/* harmony import */ var _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../geometry/support/TileClipper.js */ 99220);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/

var t;
!function (e) {
  e[e.moveTo = 1] = "moveTo", e[e.lineTo = 2] = "lineTo", e[e.close = 7] = "close";
}(t || (t = {}));
class s {
  constructor(e, t) {
    this.values = {}, this._geometry = void 0, this._pbfGeometry = null;
    const s = t.keys,
      o = t.values,
      r = e.asUnsafe();
    for (; r.next();) switch (r.tag()) {
      case 1:
        this.id = r.getUInt64();
        break;
      case 2:
        {
          const e = r.getMessage().asUnsafe(),
            t = this.values;
          for (; !e.empty();) {
            const r = e.getUInt32(),
              a = e.getUInt32();
            t[s[r]] = o[a];
          }
          e.release();
          break;
        }
      case 3:
        this.type = r.getUInt32();
        break;
      case 4:
        this._pbfGeometry = r.getMessage();
        break;
      default:
        r.skip();
    }
  }
  getGeometry(s) {
    if (void 0 !== this._geometry) return this._geometry;
    if (!this._pbfGeometry) return null;
    const o = this._pbfGeometry.asUnsafe();
    let r, a;
    this._pbfGeometry = null, s ? s.reset(this.type) : r = [];
    let n,
      i = t.moveTo,
      l = 0,
      c = 0,
      h = 0;
    for (; !o.empty();) {
      if (0 === l) {
        const e = o.getUInt32();
        i = 7 & e, l = e >> 3;
      }
      switch (l--, i) {
        case t.moveTo:
          c += o.getSInt32(), h += o.getSInt32(), s ? s.moveTo(c, h) : r && (a && r.push(a), a = [], a.push(new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(c, h)));
          break;
        case t.lineTo:
          c += o.getSInt32(), h += o.getSInt32(), s ? s.lineTo(c, h) : a && a.push(new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(c, h));
          break;
        case t.close:
          s ? s.close() : a && !a[0].equals(c, h) && a.push(a[0].clone());
          break;
        default:
          throw o.release(), new Error("Invalid path operation");
      }
    }
    return s ? n = s.result() : r && (a && r.push(a), n = r), o.release(), this._geometry = n, n;
  }
}


/***/ }),

/***/ 53508:
/*!************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/IndexMemoryBuffer.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointElementMemoryBuffer": () => (/* binding */ t),
/* harmony export */   "TriangleIndexBuffer": () => (/* binding */ r)
/* harmony export */ });
/* harmony import */ var _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MemoryBuffer.js */ 61760);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/

class r extends _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super(12);
  }
  add(s, r, t) {
    const e = this.array;
    e.push(s), e.push(r), e.push(t);
  }
}
class t extends _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super(4);
  }
  add(s) {
    this.array.push(s);
  }
}


/***/ }),

/***/ 93352:
/*!****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/Placement.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Anchor": () => (/* binding */ y),
/* harmony export */   "PlacedSymbol": () => (/* binding */ I),
/* harmony export */   "Placement": () => (/* binding */ u),
/* harmony export */   "PlacementEngine": () => (/* binding */ b),
/* harmony export */   "tileCoordSize": () => (/* binding */ x),
/* harmony export */   "tilePixelRatio": () => (/* binding */ p),
/* harmony export */   "tilePixelSize": () => (/* binding */ d)
/* harmony export */ });
/* harmony import */ var _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../geometry/support/TileClipper.js */ 99220);
/* harmony import */ var _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryUtils.js */ 12693);
/* harmony import */ var _TextShaping_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextShaping.js */ 49121);
/* harmony import */ var _decluttering_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decluttering/config.js */ 72157);
/* harmony import */ var _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style/StyleDefinition.js */ 37599);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/





const x = 4096,
  d = 512,
  p = 8,
  w = .5,
  T = 2;
class y {
  constructor(e, t, i = 0, n = -1, s = w) {
    this.x = e, this.y = t, this.angle = i, this.segment = n, this.minzoom = s;
  }
}
class f {
  constructor(e, t, i, s, o, a = w, l = _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cInfinity) {
    this.anchor = e, this.labelAngle = t, this.glyphAngle = i, this.page = s, this.alternateVerticalGlyph = o, this.minzoom = a, this.maxzoom = l;
  }
}
class I {
  constructor(e, t, i, n, s, o, a, l, h, r, c, g) {
    this.tl = e, this.tr = t, this.bl = i, this.br = n, this.mosaicRect = s, this.labelAngle = o, this.minAngle = a, this.maxAngle = l, this.anchor = h, this.minzoom = r, this.maxzoom = c, this.page = g;
  }
}
class u {
  constructor(e) {
    this.shapes = e;
  }
}
class b {
  getIconPlacement(n, s, o) {
    const a = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(n.x, n.y),
      l = o.rotationAlignment === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.RotationAlignment.MAP,
      h = o.keepUpright;
    let r = o.rotate * _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cDegToRad;
    l && (r += n.angle);
    const m = new u([]);
    return o.allowOverlap && o.ignorePlacement || !_decluttering_config_js__WEBPACK_IMPORTED_MODULE_3__.declutterTiles || (m.iconColliders = []), this._addIconPlacement(m, a, s, o, r), l && h && this._addIconPlacement(m, a, s, o, r + _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cPi), m;
  }
  _addIconPlacement(t, i, s, o, a) {
    const l = s.pixelRatio,
      h = s.width / l,
      r = s.height / l,
      g = o.offset;
    let x = g[0],
      d = g[1];
    switch (o.anchor) {
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.CENTER:
        x -= h / 2, d -= r / 2;
        break;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.LEFT:
        d -= r / 2;
        break;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.RIGHT:
        x -= h, d -= r / 2;
        break;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.TOP:
        x -= h / 2;
        break;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.BOTTOM:
        x -= h / 2, d -= r;
        break;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.TOP_LEFT:
        break;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.BOTTOM_LEFT:
        d -= r;
        break;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.TOP_RIGHT:
        x -= h;
        break;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.BOTTOM_RIGHT:
        x -= h, d -= r;
    }
    const p = s.rect,
      T = 2 / l,
      y = x - T,
      f = d - T,
      u = y + p.width / l,
      b = f + p.height / l,
      P = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(y, f),
      O = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(u, b),
      _ = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(y, b),
      k = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(u, f);
    if (0 !== a) {
      const e = Math.cos(a),
        t = Math.sin(a);
      P.rotate(e, t), O.rotate(e, t), _.rotate(e, t), k.rotate(e, t);
    }
    const M = new I(P, k, _, O, p, a, 0, 256, i, w, _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cInfinity, 0);
    if (t.shapes.push(M), (!o.allowOverlap || !o.ignorePlacement) && _decluttering_config_js__WEBPACK_IMPORTED_MODULE_3__.declutterTiles) {
      const e = o.size,
        s = o.padding,
        l = {
          xTile: i.x,
          yTile: i.y,
          dxPixels: x * e - s,
          dyPixels: d * e - s,
          hard: !o.optional,
          partIndex: 0,
          width: h * e + 2 * s,
          height: r * e + 2 * s,
          angle: a,
          minLod: w,
          maxLod: _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cInfinity
        };
      t.iconColliders.push(l);
    }
  }
  getTextPlacement(s, o, a, c) {
    const x = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(s.x, s.y),
      d = c.rotate * _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cDegToRad,
      y = c.rotationAlignment === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.RotationAlignment.MAP,
      b = c.keepUpright,
      P = c.padding;
    let O = w;
    const _ = !y ? 0 : s.angle,
      k = s.segment >= 0 && y,
      M = c.allowOverlap && c.ignorePlacement ? null : [],
      E = [],
      G = 4,
      N = !k;
    let A = Number.POSITIVE_INFINITY,
      L = Number.NEGATIVE_INFINITY,
      z = A,
      F = L;
    const v = (k || y) && b,
      R = c.size / _TextShaping_js__WEBPACK_IMPORTED_MODULE_2__.sdfGlyphSize;
    let B = !1;
    for (const e of o) if (e.vertical) {
      B = !0;
      break;
    }
    let H,
      V = 0,
      j = 0;
    if (!k && B) {
      const e = _TextShaping_js__WEBPACK_IMPORTED_MODULE_2__.TextShaping.getTextBox(o, c.lineHeight * _TextShaping_js__WEBPACK_IMPORTED_MODULE_2__.sdfGlyphSize);
      switch (c.anchor) {
        case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.LEFT:
          V = e.height / 2, j = -e.width / 2;
          break;
        case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.RIGHT:
          V = -e.height / 2, j = e.width / 2;
          break;
        case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.TOP:
          V = e.height / 2, j = e.width / 2;
          break;
        case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.BOTTOM:
          V = -e.height / 2, j = -e.width / 2;
          break;
        case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.TOP_LEFT:
          V = e.height;
          break;
        case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.BOTTOM_LEFT:
          j = -e.width;
          break;
        case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.TOP_RIGHT:
          j = e.width;
          break;
        case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_4__.SymbolAnchor.BOTTOM_RIGHT:
          V = -e.height;
      }
    }
    V += c.offset[0] * _TextShaping_js__WEBPACK_IMPORTED_MODULE_2__.sdfGlyphSize, j += c.offset[1] * _TextShaping_js__WEBPACK_IMPORTED_MODULE_2__.sdfGlyphSize;
    for (const t of o) {
      const o = t.glyphMosaicItem;
      if (!o || o.rect.isEmpty) continue;
      const l = o.rect,
        h = o.metrics,
        g = o.page;
      if (M && N) {
        if (void 0 !== H && H !== t.y) {
          let e, t, i, o;
          B ? (e = -F + V, t = A + j, i = F - z, o = L - A) : (e = A + V, t = z + j, i = L - A, o = F - z);
          const a = {
            xTile: s.x,
            yTile: s.y,
            dxPixels: e * R - P,
            dyPixels: t * R - P,
            hard: !c.optional,
            partIndex: 1,
            width: i * R + 2 * P,
            height: o * R + 2 * P,
            angle: d,
            minLod: w,
            maxLod: _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cInfinity
          };
          M.push(a), A = Number.POSITIVE_INFINITY, L = Number.NEGATIVE_INFINITY, z = A, F = L;
        }
        H = t.y;
      }
      const m = [];
      if (k) {
        const e = .5 * o.metrics.width,
          i = (t.x + h.left - G + e) * R * p;
        if (O = this._placeGlyph(s, O, i, a, s.segment, 1, t.vertical, g, m), b && (O = this._placeGlyph(s, O, i, a, s.segment, -1, t.vertical, g, m)), O >= T) break;
      } else m.push(new f(x, _, _, g, !1)), y && b && m.push(new f(x, _ + _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cPi, _ + _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cPi, g, !1));
      const u = t.x + h.left,
        C = t.y - _TextShaping_js__WEBPACK_IMPORTED_MODULE_2__.sdfGlyphBaseline - h.top,
        S = u + h.width,
        Y = C + h.height;
      let q, U, D, J, K, Q, W, X;
      if (!k && B) {
        if (t.vertical) {
          const t = (u + S) / 2 - h.height / 2,
            i = (C + Y) / 2 + h.width / 2;
          q = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(-i - G + V, t - G + j), U = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(q.x + l.width, q.y + l.height), D = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(q.x, U.y), J = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(U.x, q.y);
        } else q = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(-C + G + V, u - G + j), U = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(q.x - l.height, q.y + l.width), D = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(U.x, q.y), J = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(q.x, U.y);
      } else q = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(u - G + V, C - G + j), U = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(q.x + l.width, q.y + l.height), D = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(q.x, U.y), J = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(U.x, q.y);
      for (const i of m) {
        let n, o, a, r;
        if (i.alternateVerticalGlyph) {
          if (!K) {
            const t = (C + Y) / 2 + j;
            K = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point((u + S) / 2 + V - h.height / 2 - G, t + h.width / 2 + G), Q = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(K.x + l.height, K.y - l.width), W = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(Q.x, K.y), X = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(K.x, Q.y);
          }
          n = K, o = W, a = X, r = Q;
        } else n = q, o = D, a = J, r = U;
        const g = C,
          m = Y,
          x = i.glyphAngle + d;
        if (0 !== x) {
          const e = Math.cos(x),
            t = Math.sin(x);
          n = n.clone(), o = o?.clone(), a = a?.clone(), r = r?.clone(), n.rotate(e, t), r?.rotate(e, t), o?.rotate(e, t), a?.rotate(e, t);
        }
        let p = 0,
          w = 256;
        if (k && B ? t.vertical ? i.alternateVerticalGlyph ? (p = 32, w = 96) : (p = 224, w = 32) : (p = 224, w = 96) : (p = 192, w = 64), E.push(new I(n, a, o, r, l, i.labelAngle, p, w, i.anchor, i.minzoom, i.maxzoom, i.page)), M && (!v || this._legible(i.labelAngle))) if (N) u < A && (A = u), g < z && (z = g), S > L && (L = S), m > F && (F = m);else if (i.minzoom < T) {
          const e = {
            xTile: s.x,
            yTile: s.y,
            dxPixels: (u + V) * R - P,
            dyPixels: (g + V) * R - P,
            hard: !c.optional,
            partIndex: 1,
            width: (S - u) * R + 2 * P,
            height: (m - g) * R + 2 * P,
            angle: x,
            minLod: i.minzoom,
            maxLod: i.maxzoom
          };
          M.push(e);
        }
      }
    }
    if (O >= T) return null;
    if (M && N) {
      let e, t, i, o;
      B ? (e = -F + V, t = A + j, i = F - z, o = L - A) : (e = A + V, t = z + j, i = L - A, o = F - z);
      const a = {
        xTile: s.x,
        yTile: s.y,
        dxPixels: e * R - P,
        dyPixels: t * R - P,
        hard: !c.optional,
        partIndex: 1,
        width: i * R + 2 * P,
        height: o * R + 2 * P,
        angle: d,
        minLod: w,
        maxLod: _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cInfinity
      };
      M.push(a);
    }
    const C = new u(E);
    return M && M.length > 0 && (C.textColliders = M), C;
  }
  _legible(e) {
    const t = (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.radToByte)(e);
    return t < 65 || t >= 193;
  }
  _placeGlyph(t, s, l, h, r, c, g, m, x) {
    let d = c;
    const p = d < 0 ? (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.positiveMod)(t.angle + _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cPi, _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.c2pi) : t.angle;
    let w = 0;
    l < 0 && (d *= -1, l *= -1, w = _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cPi), d > 0 && ++r;
    let T = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_0__.Point(t.x, t.y),
      y = h[r],
      I = _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.cInfinity;
    if (h.length <= r) return I;
    for (;;) {
      const e = y.x - T.x,
        t = y.y - T.y,
        i = Math.sqrt(e * e + t * t),
        n = Math.max(l / i, s),
        c = e / i,
        u = t / i,
        b = (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.positiveMod)(Math.atan2(u, c) + w, _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.c2pi);
      if (x.push(new f(T, p, b, m, !1, n, I)), g && x.push(new f(T, p, b, m, !0, n, I)), n <= s) return n;
      T = y.clone();
      do {
        if (r += d, h.length <= r || r < 0) return n;
        y = h[r];
      } while (T.isEqual(y));
      let P = y.x - T.x,
        O = y.y - T.y;
      const _ = Math.sqrt(P * P + O * O);
      P *= i / _, O *= i / _, T.x -= P, T.y -= O, I = n;
    }
  }
}


/***/ }),

/***/ 47239:
/*!******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/ScriptUtils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "allowsIdeographicBreak": () => (/* binding */ c),
/* harmony export */   "hasVerticalOrientation": () => (/* binding */ e),
/* harmony export */   "isLineBreak": () => (/* binding */ s),
/* harmony export */   "isWhiteSpace": () => (/* binding */ a)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
function e(e) {
  return 746 === e || 747 === e || !(e < 4352) && (e >= 12704 && e <= 12735 || e >= 12544 && e <= 12591 || e >= 65072 && e <= 65103 && !(e >= 65097 && e <= 65103) || e >= 63744 && e <= 64255 || e >= 13056 && e <= 13311 || e >= 11904 && e <= 12031 || e >= 12736 && e <= 12783 || e >= 12288 && e <= 12351 && !(e >= 12296 && e <= 12305 || e >= 12308 && e <= 12319 || 12336 === e) || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 || e >= 12800 && e <= 13055 || e >= 12592 && e <= 12687 || e >= 43360 && e <= 43391 || e >= 55216 && e <= 55295 || e >= 4352 && e <= 4607 || e >= 44032 && e <= 55215 || e >= 12352 && e <= 12447 || e >= 12272 && e <= 12287 || e >= 12688 && e <= 12703 || e >= 12032 && e <= 12255 || e >= 12784 && e <= 12799 || e >= 12448 && e <= 12543 && 12540 !== e || e >= 65280 && e <= 65519 && !(65288 === e || 65289 === e || 65293 === e || e >= 65306 && e <= 65310 || 65339 === e || 65341 === e || 65343 === e || e >= 65371 && e <= 65503 || 65507 === e || e >= 65512 && e <= 65519) || e >= 65104 && e <= 65135 && !(e >= 65112 && e <= 65118 || e >= 65123 && e <= 65126) || e >= 5120 && e <= 5759 || e >= 6320 && e <= 6399 || e >= 65040 && e <= 65055 || e >= 19904 && e <= 19967 || e >= 40960 && e <= 42127 || e >= 42128 && e <= 42191);
}
function c(e) {
  return !(e < 11904) && (e >= 12704 && e <= 12735 || e >= 12544 && e <= 12591 || e >= 65072 && e <= 65103 || e >= 63744 && e <= 64255 || e >= 13056 && e <= 13311 || e >= 11904 && e <= 12031 || e >= 12736 && e <= 12783 || e >= 12288 && e <= 12351 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 || e >= 12800 && e <= 13055 || e >= 65280 && e <= 65519 || e >= 12352 && e <= 12447 || e >= 12272 && e <= 12287 || e >= 12032 && e <= 12255 || e >= 12784 && e <= 12799 || e >= 12448 && e <= 12543 || e >= 65040 && e <= 65055 || e >= 42128 && e <= 42191 || e >= 40960 && e <= 42127);
}
function s(e) {
  switch (e) {
    case 10:
    case 32:
    case 38:
    case 40:
    case 41:
    case 43:
    case 45:
    case 47:
    case 173:
    case 183:
    case 8203:
    case 8208:
    case 8211:
    case 8231:
      return !0;
  }
  return !1;
}
function a(e) {
  switch (e) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
      return !0;
  }
  return !1;
}


/***/ }),

/***/ 23858:
/*!**********************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/SourceLayerData.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
class e {
  constructor(t) {
    this.extent = 4096, this.keys = [], this.values = [], this._pbfLayer = t.clone();
    const s = t.asUnsafe();
    for (; s.next();) switch (s.tag()) {
      case 1:
        this.name = s.getString();
        break;
      case 3:
        this.keys.push(s.getString());
        break;
      case 4:
        this.values.push(s.processMessage(e._parseValue));
        break;
      case 5:
        this.extent = s.getUInt32();
        break;
      default:
        s.skip();
    }
  }
  getData() {
    return this._pbfLayer;
  }
  static _parseValue(e) {
    for (; e.next();) switch (e.tag()) {
      case 1:
        return e.getString();
      case 2:
        return e.getFloat();
      case 3:
        return e.getDouble();
      case 4:
        return e.getInt64();
      case 5:
        return e.getUInt64();
      case 6:
        return e.getSInt64();
      case 7:
        return e.getBool();
      default:
        e.skip();
    }
    return null;
  }
}


/***/ }),

/***/ 49121:
/*!******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/TextShaping.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextShaping": () => (/* binding */ l),
/* harmony export */   "sdfGlyphBaseline": () => (/* binding */ h),
/* harmony export */   "sdfGlyphSize": () => (/* binding */ c)
/* harmony export */ });
/* harmony import */ var _ScriptUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScriptUtils.js */ 47239);
/* harmony import */ var _webgl_Rect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Rect.js */ 26057);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/


const c = 24,
  h = 17;
class l {
  constructor(t, e, i, o, s, c, h) {
    this._glyphItems = t, this._maxWidth = e, this._lineHeight = i, this._letterSpacing = o, this._hAnchor = s, this._vAnchor = c, this._justify = h;
  }
  getShaping(s, c, h) {
    const l = this._letterSpacing,
      n = this._lineHeight,
      a = this._justify,
      r = this._maxWidth,
      m = [];
    let f = 0,
      p = 0;
    for (const t of s) {
      const e = t.codePointAt(0);
      if (null == e) continue;
      const i = h && (0,_ScriptUtils_js__WEBPACK_IMPORTED_MODULE_0__.hasVerticalOrientation)(e);
      let s;
      for (const t of this._glyphItems) if (s = t[e], s) break;
      m.push({
        codePoint: e,
        x: f,
        y: p,
        vertical: i,
        glyphMosaicItem: s
      }), s && (f += s.metrics.advance + l);
    }
    let g = f;
    if (r > 0) {
      g = f / Math.max(1, Math.ceil(f / r));
    }
    const y = s.includes("â€‹"),
      d = [],
      x = m.length;
    for (let e = 0; e < x - 1; e++) {
      const o = m[e].codePoint,
        s = (0,_ScriptUtils_js__WEBPACK_IMPORTED_MODULE_0__.allowsIdeographicBreak)(o);
      if ((0,_ScriptUtils_js__WEBPACK_IMPORTED_MODULE_0__.isLineBreak)(o) || s) {
        let t = 0;
        if (10 === o) t -= 1e4;else if (s && y) t += 150;else {
          40 !== o && 65288 !== o || (t += 50);
          const i = m[e + 1].codePoint;
          41 !== i && 65289 !== i || (t += 50);
        }
        d.push(this._buildBreak(e + 1, m[e].x, g, d, t, !1));
      }
    }
    const u = this._optimalBreaks(this._buildBreak(x, f, g, d, 0, !0));
    let M = 0;
    const _ = c ? -n : n;
    let I = 0;
    for (let t = 0; t < u.length; t++) {
      const i = u[t];
      let o = I;
      for (; o < i && (0,_ScriptUtils_js__WEBPACK_IMPORTED_MODULE_0__.isWhiteSpace)(m[o].codePoint);) m[o].glyphMosaicItem = null, ++o;
      let s = i - 1;
      for (; s > o && (0,_ScriptUtils_js__WEBPACK_IMPORTED_MODULE_0__.isWhiteSpace)(m[s].codePoint);) m[s].glyphMosaicItem = null, --s;
      if (o <= s) {
        const t = m[o].x;
        for (let i = o; i <= s; i++) m[i].x -= t, m[i].y = p;
        let e = m[s].x;
        m[s].glyphMosaicItem && (e += m[s].glyphMosaicItem.metrics.advance), M = Math.max(e, M), a && this._applyJustification(m, o, s);
      }
      I = i, p += _;
    }
    if (m.length > 0) {
      const t = u.length - 1,
        e = (a - this._hAnchor) * M;
      let i = (-this._vAnchor * (t + 1) + .5) * n;
      c && t && (i += t * n);
      for (const o of m) o.x += e, o.y += i;
    }
    return m.filter(t => t.glyphMosaicItem);
  }
  static getTextBox(t, e) {
    if (!t.length) return null;
    let i = 1 / 0,
      o = 1 / 0,
      s = 0,
      c = 0;
    for (const l of t) {
      const t = l.glyphMosaicItem.metrics.advance,
        n = l.x,
        a = l.y - h,
        r = n + t,
        m = a + e;
      i = Math.min(i, n), s = Math.max(s, r), o = Math.min(o, a), c = Math.max(c, m);
    }
    return {
      x: i,
      y: o,
      width: s - i,
      height: c - o
    };
  }
  static getBox(t) {
    if (!t.length) return null;
    let e = 1 / 0,
      i = 1 / 0,
      o = 0,
      s = 0;
    for (const c of t) {
      const {
          height: t,
          left: h,
          top: l,
          width: n
        } = c.glyphMosaicItem.metrics,
        a = c.x,
        r = c.y - (t - Math.abs(l)),
        m = a + n + h,
        f = r + t;
      e = Math.min(e, a), o = Math.max(o, m), i = Math.min(i, r), s = Math.max(s, f);
    }
    return {
      x: e,
      y: i,
      width: o - e,
      height: s - i
    };
  }
  static addDecoration(t, e) {
    const i = t.length;
    if (0 === i) return;
    const o = 3;
    let c = t[0].x + t[0].glyphMosaicItem.metrics.left,
      h = t[0].y;
    for (let n = 1; n < i; n++) {
      const i = t[n];
      if (i.y !== h) {
        const l = t[n - 1].x + t[n - 1].glyphMosaicItem.metrics.left + t[n - 1].glyphMosaicItem.metrics.width;
        t.push({
          codePoint: 0,
          x: c,
          y: h + e - o,
          vertical: !1,
          glyphMosaicItem: {
            sdf: !0,
            rect: new _webgl_Rect_js__WEBPACK_IMPORTED_MODULE_1__["default"](4, 0, 4, 8),
            metrics: {
              width: l - c,
              height: 2 + 2 * o,
              left: 0,
              top: 0,
              advance: 0
            },
            page: 0,
            code: 0
          }
        }), h = i.y, c = i.x + i.glyphMosaicItem.metrics.left;
      }
    }
    const l = t[i - 1].x + t[i - 1].glyphMosaicItem.metrics.left + t[i - 1].glyphMosaicItem.metrics.width;
    t.push({
      codePoint: 0,
      x: c,
      y: h + e - o,
      vertical: !1,
      glyphMosaicItem: {
        sdf: !0,
        rect: new _webgl_Rect_js__WEBPACK_IMPORTED_MODULE_1__["default"](4, 0, 4, 8),
        metrics: {
          width: l - c,
          height: 2 + 2 * o,
          left: 0,
          top: 0,
          advance: 0
        },
        page: 0,
        code: 0
      }
    });
  }
  _breakScore(t, e, i, o) {
    const s = (t - e) * (t - e);
    return o ? t < e ? s / 2 : 2 * s : s + Math.abs(i) * i;
  }
  _buildBreak(t, e, i, o, s, c) {
    let h = null,
      l = this._breakScore(e, i, s, c);
    for (const n of o) {
      const t = e - n.x,
        o = this._breakScore(t, i, s, c) + n.score;
      o <= l && (h = n, l = o);
    }
    return {
      index: t,
      x: e,
      score: l,
      previousBreak: h
    };
  }
  _optimalBreaks(t) {
    return t ? this._optimalBreaks(t.previousBreak).concat(t.index) : [];
  }
  _applyJustification(t, e, i) {
    const o = t[i],
      s = o.vertical ? c : o.glyphMosaicItem ? o.glyphMosaicItem.metrics.advance : 0,
      h = (o.x + s) * this._justify;
    for (let c = e; c <= i; c++) t[c].x -= h;
  }
}


/***/ }),

/***/ 9045:
/*!*****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileParser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ B)
/* harmony export */ });
/* harmony import */ var _home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _core_pbf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../core/pbf.js */ 74617);
/* harmony import */ var _core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../core/promiseUtils.js */ 30801);
/* harmony import */ var _geometry_libtess_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../geometry/libtess.js */ 40241);
/* harmony import */ var _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../geometry/support/TileClipper.js */ 99220);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Feature.js */ 15569);
/* harmony import */ var _IndexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IndexMemoryBuffer.js */ 53508);
/* harmony import */ var _SourceLayerData_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SourceLayerData.js */ 23858);
/* harmony import */ var _VertexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./VertexMemoryBuffer.js */ 59702);
/* harmony import */ var _buckets_CircleBucket_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./buckets/CircleBucket.js */ 4002);
/* harmony import */ var _buckets_FillBucket_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./buckets/FillBucket.js */ 12326);
/* harmony import */ var _buckets_LineBucket_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./buckets/LineBucket.js */ 11029);
/* harmony import */ var _buckets_SymbolBucket_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./buckets/SymbolBucket.js */ 49344);
/* harmony import */ var _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style/StyleDefinition.js */ 37599);
/* harmony import */ var _tiling_enums_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../tiling/enums.js */ 42776);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/














const T = 8,
  g = 14,
  w = 16;
class B {
  constructor(t, r, o, n, c) {
    if (this._pbfTiles = {}, this._tileClippers = {}, this._client = o, this._tile = r, c) {
      this._styleLayerUIDs = new Set();
      for (const e of c) this._styleLayerUIDs.add(e);
    }
    this._styleRepository = n, this._layers = this._styleRepository?.layers ?? [];
    const [l, a, u] = r.tileKey.split("/").map(parseFloat);
    this._level = l;
    const f = T + Math.max((this._level - g) * w, 0);
    for (const p of Object.keys(t)) {
      const r = t[p];
      this._pbfTiles[p] = new _core_pbf_js__WEBPACK_IMPORTED_MODULE_1__["default"](new Uint8Array(r.protobuff), new DataView(r.protobuff));
      if (r.refKey) {
        const [e] = r.refKey.split("/").map(parseFloat),
          t = l - e;
        if (t > 0) {
          const e = (1 << t) - 1,
            r = a & e,
            i = u & e;
          this._tileClippers[p] = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_4__.TileClipper(t, r, i, 8, f);
        }
      }
      this._tileClippers[p] || (this._tileClippers[p] = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_4__.SimpleBuilder());
    }
  }
  _canParseStyleLayer(e) {
    return !this._styleLayerUIDs || this._styleLayerUIDs.has(e);
  }
  parse(e) {
    var _this = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const t = (0,_geometry_libtess_js__WEBPACK_IMPORTED_MODULE_3__.loadLibtess)(),
        s = _this._initialize(e),
        {
          returnedBuckets: i
        } = s;
      _this._processLayers(s), _this._linkReferences(s), _this._filterFeatures(s);
      const o = [],
        n = new Set(),
        c = (e, t) => {
          n.has(e) || (o.push({
            name: e,
            repeat: t
          }), n.add(e));
        },
        l = {};
      for (const r of i) r.getResources(r.tileClipper, c, l);
      if (_this._tile.status === _tiling_enums_js__WEBPACK_IMPORTED_MODULE_14__.TileStatus.INVALID) return [];
      const a = _this._fetchResources(o, l, e);
      return Promise.all([...a, t]).then(() => _this._processFeatures(s.returnedBuckets));
    })();
  }
  _initialize(e) {
    const t = e?.signal;
    return {
      signal: t,
      sourceNameToTileData: this._parseTileData(this._pbfTiles),
      layers: this._layers,
      zoom: this._level,
      sourceNameToTileClipper: this._tileClippers,
      sourceNameToUniqueSourceLayerBuckets: {},
      sourceNameToUniqueSourceLayers: {},
      returnedBuckets: [],
      layerIdToBucket: {},
      referencerUIDToReferencedId: new Map()
    };
  }
  _processLayers(e) {
    const {
      sourceNameToTileData: t,
      layers: r,
      zoom: s,
      sourceNameToTileClipper: i,
      sourceNameToUniqueSourceLayerBuckets: o,
      sourceNameToUniqueSourceLayers: n,
      returnedBuckets: c,
      layerIdToBucket: l,
      referencerUIDToReferencedId: a
    } = e;
    for (let u = r.length - 1; u >= 0; u--) {
      const e = r[u];
      if (!this._canParseStyleLayer(e.uid) || e.minzoom && s < Math.floor(e.minzoom) || e.maxzoom && s >= e.maxzoom || e.type === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_13__.StyleLayerType.BACKGROUND) continue;
      if (!t[e.source] || !i[e.source]) continue;
      const f = t[e.source],
        p = i[e.source],
        h = e.sourceLayer,
        m = f[h];
      if (m) {
        let t = n[e.source];
        if (t || (t = n[e.source] = new Set()), t.add(e.sourceLayer), e.refLayerId) a.set(e.uid, e.refLayerId);else {
          const t = this._createBucket(e);
          if (t) {
            t.layerUIDs = [e.uid], t.layerExtent = m.extent, t.tileClipper = p;
            let r = o[e.source];
            r || (r = o[e.source] = {});
            let s = r[h];
            s || (s = r[h] = []), s.push(t), c.push(t), l[e.id] = t;
          }
        }
      }
    }
  }
  _linkReferences(e) {
    const {
      layerIdToBucket: t,
      referencerUIDToReferencedId: r
    } = e;
    r.forEach((e, r) => {
      t[e] && t[e].layerUIDs.push(r);
    });
  }
  _filterFeatures(e) {
    const {
        signal: r,
        sourceNameToTileData: s,
        sourceNameToUniqueSourceLayerBuckets: i,
        sourceNameToUniqueSourceLayers: n
      } = e,
      c = 10 * this._level,
      l = 10 * (this._level + 1),
      a = [],
      u = [];
    for (const t of Object.keys(n)) {
      n[t].forEach(e => {
        a.push(e), u.push(t);
      });
    }
    for (let f = 0; f < a.length; f++) {
      const e = u[f],
        n = a[f];
      if (!s[e] || !i[e]) continue;
      const p = s[e][n],
        h = i[e][n];
      if (!h || 0 === h.length) continue;
      if ((0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_2__.isAborted)(r)) return;
      const m = p.getData();
      for (; m.nextTag(2);) {
        const e = m.getMessage(),
          t = new _Feature_js__WEBPACK_IMPORTED_MODULE_5__["default"](e, p);
        e.release();
        const r = t.values;
        if (r) {
          const e = r._minzoom;
          if (e && e >= l) continue;
          const t = r._maxzoom;
          if (t && t <= c) continue;
        }
        for (const s of h) s.pushFeature(t);
      }
    }
  }
  _fetchResources(e, t, r) {
    const s = [],
      i = this._tile.getWorkerTileHandler();
    let o, n;
    e.length > 0 && (o = i.fetchSprites(e, this._client, r), s.push(o));
    for (const c in t) {
      const e = t[c];
      e.size > 0 && (n = i.fetchGlyphs(this._tile.tileKey, c, e, this._client, r), s.push(n));
    }
    return s;
  }
  _processFeatures(e) {
    const t = e.filter(e => e.hasFeatures() || this._canParseStyleLayer(e.layer.uid));
    for (const r of t) r.processFeatures(r.tileClipper);
    return t;
  }
  _parseTileData(e) {
    const t = {};
    for (const r of Object.keys(e)) {
      const s = e[r],
        i = {};
      for (; s.next();) switch (s.tag()) {
        case 3:
          {
            const e = s.getMessage(),
              t = new _SourceLayerData_js__WEBPACK_IMPORTED_MODULE_7__["default"](e);
            e.release(), i[t.name] = t;
            break;
          }
        default:
          s.skip();
      }
      t[r] = i;
    }
    return t;
  }
  _createBucket(e) {
    switch (e.type) {
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_13__.StyleLayerType.BACKGROUND:
        return null;
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_13__.StyleLayerType.FILL:
        return this._createFillBucket(e);
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_13__.StyleLayerType.LINE:
        return this._createLineBucket(e);
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_13__.StyleLayerType.CIRCLE:
        return this._createCircleBucket(e);
      case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_13__.StyleLayerType.SYMBOL:
        return this._createSymbolBucket(e);
    }
  }
  _createFillBucket(e) {
    return new _buckets_FillBucket_js__WEBPACK_IMPORTED_MODULE_10__["default"](e, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new _VertexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_8__.FillVertexBuffer(e.fillMaterial.getStride()), new _IndexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_6__.TriangleIndexBuffer(), new _VertexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_8__.OutlineVertexBuffer(e.outlineMaterial.getStride()), new _IndexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_6__.TriangleIndexBuffer());
  }
  _createLineBucket(e) {
    return new _buckets_LineBucket_js__WEBPACK_IMPORTED_MODULE_11__["default"](e, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new _VertexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_8__.LineVertexBuffer(e.lineMaterial.getStride()), new _IndexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_6__.TriangleIndexBuffer());
  }
  _createCircleBucket(e) {
    return new _buckets_CircleBucket_js__WEBPACK_IMPORTED_MODULE_9__["default"](e, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new _VertexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_8__.CircleVertexBuffer(e.circleMaterial.getStride()), new _IndexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_6__.TriangleIndexBuffer());
  }
  _createSymbolBucket(e) {
    const t = this._tile;
    return new _buckets_SymbolBucket_js__WEBPACK_IMPORTED_MODULE_12__["default"](e, this._level, new _VertexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_8__.SymbolVertexBuffer(e.iconMaterial.getStride()), new _IndexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_6__.TriangleIndexBuffer(), new _VertexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_8__.SymbolVertexBuffer(e.textMaterial.getStride()), new _IndexMemoryBuffer_js__WEBPACK_IMPORTED_MODULE_6__.TriangleIndexBuffer(), t.placementEngine, t.getWorkerTileHandler());
  }
}


/***/ }),

/***/ 59702:
/*!*************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/VertexMemoryBuffer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CircleVertexBuffer": () => (/* binding */ a),
/* harmony export */   "FillVertexBuffer": () => (/* binding */ r),
/* harmony export */   "LineVertexBuffer": () => (/* binding */ o),
/* harmony export */   "OutlineVertexBuffer": () => (/* binding */ u),
/* harmony export */   "SymbolVertexBuffer": () => (/* binding */ h)
/* harmony export */ });
/* harmony import */ var _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeometryUtils.js */ 12693);
/* harmony import */ var _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MemoryBuffer.js */ 61760);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/


class o extends _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(t) {
    super(t);
  }
  add(t, o, r, u, h, a, n, d, e, p, i, c) {
    const M = this.array;
    let l = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i1616to32(t, o);
    M.push(l);
    const m = 31;
    l = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i8888to32(Math.round(m * r), Math.round(m * u), Math.round(m * h), Math.round(m * a)), M.push(l), l = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i8888to32(Math.round(m * n), Math.round(m * d), Math.round(m * e), Math.round(m * p)), M.push(l), l = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i1616to32(i, 0), M.push(l), c && M.push(...c);
  }
}
class r extends _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(t) {
    super(t);
  }
  add(t, o, r) {
    const u = this.array;
    u.push(_MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i1616to32(t, o)), r && u.push(...r);
  }
}
class u extends _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(t) {
    super(t);
  }
  add(t, o, r, u, h, a, n) {
    const d = this.array,
      e = this.index;
    let p = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i1616to32(t, o);
    d.push(p);
    const i = 15;
    return p = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i8888to32(Math.round(i * r), Math.round(i * u), h, a), d.push(p), n && d.push(...n), e;
  }
}
class h extends _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(t) {
    super(t);
  }
  add(o, r, u, h, a, n, d, e, p, i, c, M) {
    const l = this.array;
    let m = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i1616to32(o, r);
    l.push(m), m = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i1616to32(Math.round(8 * u), Math.round(8 * h)), l.push(m), m = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i8888to32(a / 4, n / 4, e, p), l.push(m), m = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i8888to32(0, (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_0__.radToByte)(d), 10 * i, Math.min(10 * c, 255)), l.push(m), M && l.push(...M);
  }
}
class a extends _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(t) {
    super(t);
  }
  add(t, o, r, u, h) {
    const a = this.array,
      n = _MemoryBuffer_js__WEBPACK_IMPORTED_MODULE_1__["default"].i1616to32(2 * t + r, 2 * o + u);
    a.push(n), h && a.push(...h);
  }
}


/***/ }),

/***/ 58092:
/*!*****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTile.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ i)
/* harmony export */ });
/* harmony import */ var _home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../core/promiseUtils.js */ 30801);
/* harmony import */ var _Placement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Placement.js */ 93352);
/* harmony import */ var _TileParser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TileParser.js */ 9045);
/* harmony import */ var _tiling_enums_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tiling/enums.js */ 42776);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/




class i {
  constructor(t, s, i, a) {
    this.status = _tiling_enums_js__WEBPACK_IMPORTED_MODULE_4__.TileStatus.INITIALIZED, this.placementEngine = new _Placement_js__WEBPACK_IMPORTED_MODULE_2__.PlacementEngine(), this.tileKey = t, this.refKeys = s, this._workerTileHandler = i, this._styleRepository = a;
  }
  release() {
    this.tileKey = "", this.refKeys = null, this.status = _tiling_enums_js__WEBPACK_IMPORTED_MODULE_4__.TileStatus.INITIALIZED, this._workerTileHandler = null;
  }
  parse(e, s) {
    var _this = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const i = s?.signal;
      if (null != i) {
        const t = () => {
          i.removeEventListener("abort", t), _this.status = _tiling_enums_js__WEBPACK_IMPORTED_MODULE_4__.TileStatus.INVALID;
        };
        i.addEventListener("abort", t);
      }
      let a;
      const n = {
        bucketsWithData: [],
        emptyBuckets: null
      };
      try {
        a = yield _this._parse(e, s);
      } catch (c) {
        if ((0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(c)) throw c;
        return {
          result: n,
          transferList: []
        };
      }
      _this.status = _tiling_enums_js__WEBPACK_IMPORTED_MODULE_4__.TileStatus.READY;
      const l = n.bucketsWithData,
        o = [];
      for (const t of a) if (t.hasFeatures()) {
        const e = t.serialize();
        l.push(e);
      } else o.push(t.layer.uid);
      const u = [...l];
      let h = null;
      return o.length > 0 && (h = Uint32Array.from(o), u.push(h.buffer)), n.emptyBuckets = h, {
        result: n,
        transferList: u
      };
    })();
  }
  setObsolete() {
    this.status = _tiling_enums_js__WEBPACK_IMPORTED_MODULE_4__.TileStatus.INVALID;
  }
  getLayers() {
    return this._workerTileHandler.getLayers();
  }
  getWorkerTileHandler() {
    return this._workerTileHandler;
  }
  _parse(t, e) {
    var _this2 = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const i = t.sourceName2DataAndRefKey;
      if (0 === Object.keys(i).length) return [];
      _this2.status = _tiling_enums_js__WEBPACK_IMPORTED_MODULE_4__.TileStatus.MODIFIED;
      return new _TileParser_js__WEBPACK_IMPORTED_MODULE_3__["default"](i, _this2, e.client, _this2._styleRepository, t.styleLayerUIDs).parse(e);
    })();
  }
}


/***/ }),

/***/ 98798:
/*!************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTileHandler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ o)
/* harmony export */ });
/* harmony import */ var _home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../core/promiseUtils.js */ 30801);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums.js */ 41780);
/* harmony import */ var _WorkerTile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WorkerTile.js */ 58092);
/* harmony import */ var _style_StyleRepository_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style/StyleRepository.js */ 70292);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/




class o {
  constructor() {
    this._spriteInfo = {}, this._glyphInfo = {};
  }
  reset() {
    return this._spriteInfo = {}, this._glyphInfo = {}, Promise.resolve();
  }
  getLayers() {
    return this._styleRepository?.layers ?? [];
  }
  createTileAndParse(t, r) {
    var _this = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const {
          key: o
        } = t,
        i = {};
      for (const e of Object.keys(t.sourceName2DataAndRefKey)) {
        const s = t.sourceName2DataAndRefKey[e];
        i[e] = s.refKey;
      }
      const n = new _WorkerTile_js__WEBPACK_IMPORTED_MODULE_3__["default"](o, i, _this, _this._styleRepository);
      try {
        return yield n.parse(t, r);
      } catch (l) {
        if (n.setObsolete(), n.release(), !(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(l)) throw l;
        return null;
      }
    })();
  }
  updateStyle(e) {
    if (!e || 0 === e.length || !this._styleRepository) return;
    const s = this._styleRepository;
    for (const r of e) {
      const e = r.type,
        o = r.data;
      switch (e) {
        case _enums_js__WEBPACK_IMPORTED_MODULE_2__.StyleUpdateType.PAINTER_CHANGED:
          s.setPaintProperties(o.layer, o.paint);
          break;
        case _enums_js__WEBPACK_IMPORTED_MODULE_2__.StyleUpdateType.LAYOUT_CHANGED:
          s.setLayoutProperties(o.layer, o.layout);
          break;
        case _enums_js__WEBPACK_IMPORTED_MODULE_2__.StyleUpdateType.LAYER_REMOVED:
          s.deleteStyleLayer(o.layer);
          break;
        case _enums_js__WEBPACK_IMPORTED_MODULE_2__.StyleUpdateType.LAYER_CHANGED:
          s.setStyleLayer(o.layer, o.index);
          break;
        case _enums_js__WEBPACK_IMPORTED_MODULE_2__.StyleUpdateType.SPRITES_CHANGED:
          this._spriteInfo = {};
      }
    }
  }
  setStyle(e) {
    this._styleRepository = new _style_StyleRepository_js__WEBPACK_IMPORTED_MODULE_4__["default"](e), this._spriteInfo = {}, this._glyphInfo = {};
  }
  fetchSprites(e, t, s) {
    const r = [],
      o = this._spriteInfo;
    for (const i of e) {
      void 0 === o[i.name] && r.push(i);
    }
    return 0 === r.length ? Promise.resolve() : t.invoke("getSprites", r, {
      signal: s?.signal
    }).then(e => {
      for (const t in e) {
        const s = e[t];
        o[t] = s;
      }
    });
  }
  getSpriteItems() {
    return this._spriteInfo;
  }
  fetchGlyphs(e, t, s, r, o) {
    const i = [];
    let n = this._glyphInfo[t];
    return n ? s.forEach(e => {
      n[e] || i.push(e);
    }) : (n = this._glyphInfo[t] = [], s.forEach(e => i.push(e))), 0 === i.length ? Promise.resolve() : r.invoke("getGlyphs", {
      tileID: e,
      font: t,
      codePoints: i
    }, o).then(e => {
      for (let t = 0; t < e.length; t++) e[t] && (n[t] = e[t]);
    });
  }
  getGlyphItems(e) {
    return this._glyphInfo[e];
  }
}


/***/ }),

/***/ 33579:
/*!*************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/BaseBucket.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ t)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
class t {
  constructor(t, e, s) {
    this.layerExtent = 4096, this._features = [], this.layer = t, this.zoom = e, this._spriteInfo = s, this._filter = t.getFeatureFilter();
  }
  pushFeature(t) {
    this._filter && !this._filter.filter(t, this.zoom) || this._features.push(t);
  }
  hasFeatures() {
    return this._features.length > 0;
  }
  getResources(t, e, s) {}
}


/***/ }),

/***/ 4002:
/*!***************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/CircleBucket.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ r)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ 41780);
/* harmony import */ var _BaseBucket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseBucket.js */ 33579);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/


class r extends _BaseBucket_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(t, r, i, c, s) {
    super(t, r, i), this.type = _enums_js__WEBPACK_IMPORTED_MODULE_0__.BucketType.CIRCLE, this._circleVertexBuffer = c, this._circleIndexBuffer = s;
  }
  get circleIndexStart() {
    return this._circleIndexStart;
  }
  get circleIndexCount() {
    return this._circleIndexCount;
  }
  processFeatures(e) {
    const t = this._circleVertexBuffer,
      r = this._circleIndexBuffer;
    this._circleIndexStart = 3 * r.index, this._circleIndexCount = 0;
    const i = this.layer,
      c = this.zoom;
    e && e.setExtent(this.layerExtent);
    for (const s of this._features) {
      const n = s.getGeometry(e);
      if (!n) continue;
      const l = i.circleMaterial.encodeAttributes(s, c, i);
      for (const e of n) if (e) for (const i of e) {
        const e = t.index;
        t.add(i.x, i.y, 0, 0, l), t.add(i.x, i.y, 0, 1, l), t.add(i.x, i.y, 1, 0, l), t.add(i.x, i.y, 1, 1, l), r.add(e, e + 1, e + 2), r.add(e + 1, e + 2, e + 3), this._circleIndexCount += 6;
      }
    }
  }
  serialize() {
    let e = 6;
    e += this.layerUIDs.length, e += this._circleVertexBuffer.array.length, e += this._circleIndexBuffer.array.length;
    const t = new Uint32Array(e),
      r = new Int32Array(t.buffer);
    let i = 0;
    t[i++] = this.type, t[i++] = this.layerUIDs.length;
    for (let c = 0; c < this.layerUIDs.length; c++) t[i++] = this.layerUIDs[c];
    t[i++] = this._circleIndexStart, t[i++] = this._circleIndexCount, t[i++] = this._circleVertexBuffer.array.length;
    for (let c = 0; c < this._circleVertexBuffer.array.length; c++) r[i++] = this._circleVertexBuffer.array[c];
    t[i++] = this._circleIndexBuffer.array.length;
    for (let c = 0; c < this._circleIndexBuffer.array.length; c++) t[i++] = this._circleIndexBuffer.array[c];
    return t.buffer;
  }
}


/***/ }),

/***/ 12326:
/*!*************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/FillBucket.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ s)
/* harmony export */ });
/* harmony import */ var _core_ArrayPool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../core/ArrayPool.js */ 93113);
/* harmony import */ var _chunks_earcut_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../chunks/earcut.js */ 38306);
/* harmony import */ var _geometry_libtess_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../geometry/libtess.js */ 40241);
/* harmony import */ var _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../geometry/support/TileClipper.js */ 99220);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enums.js */ 41780);
/* harmony import */ var _BaseBucket_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseBucket.js */ 33579);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/






class s extends _BaseBucket_js__WEBPACK_IMPORTED_MODULE_5__["default"] {
  constructor(t, e, i, r, n, s, o) {
    super(t, e, i), this.type = _enums_js__WEBPACK_IMPORTED_MODULE_4__.BucketType.FILL, this._patternMap = new Map(), this._fillVertexBuffer = r, this._fillIndexBuffer = n, this._outlineVertexBuffer = s, this._outlineIndexBuffer = o;
  }
  get fillIndexStart() {
    return this._fillIndexStart;
  }
  get fillIndexCount() {
    return this._fillIndexCount;
  }
  get outlineIndexStart() {
    return this._outlineIndexStart;
  }
  get outlineIndexCount() {
    return this._outlineIndexCount;
  }
  getResources(t, e, i) {
    const r = this.layer,
      l = this.zoom,
      n = r.getPaintProperty("fill-pattern");
    if (n) if (n.isDataDriven) for (const s of this._features) e(n.getValue(l, s), !0);else e(n.getValue(l), !0);
  }
  processFeatures(t) {
    this._fillIndexStart = 3 * this._fillIndexBuffer.index, this._fillIndexCount = 0, this._outlineIndexStart = 3 * this._outlineIndexBuffer.index, this._outlineIndexCount = 0;
    const e = this.layer,
      i = this.zoom,
      {
        fillMaterial: r,
        outlineMaterial: l,
        hasDataDrivenFill: n,
        hasDataDrivenOutline: s
      } = e;
    t && t.setExtent(this.layerExtent);
    const o = e.getPaintProperty("fill-pattern"),
      a = o?.isDataDriven;
    let f = !o && e.getPaintValue("fill-antialias", i);
    if (e.outlineUsesFillColor) {
      if (f && !e.hasDataDrivenOpacity) {
        const t = e.getPaintValue("fill-opacity", i),
          r = e.getPaintValue("fill-opacity", i + 1);
        t < 1 && r < 1 && (f = !1);
      }
      if (f && !e.hasDataDrivenColor) {
        const t = e.getPaintValue("fill-color", i),
          r = e.getPaintValue("fill-color", i + 1);
        t[3] < 1 && r[3] < 1 && (f = !1);
      }
    }
    const u = this._features,
      d = t?.validateTessellation;
    if (a) {
      const n = [];
      for (const a of u) {
        const u = o.getValue(i, a),
          h = this._spriteInfo[u];
        if (!h?.rect) continue;
        const x = r.encodeAttributes(a, i, e, h),
          c = f && s ? l.encodeAttributes(a, i, e) : [],
          _ = a.getGeometry(t);
        n.push({
          ddFillAttributes: x,
          ddOutlineAttributes: c,
          page: h.page,
          geometry: _
        }), n.sort((t, e) => t.page - e.page);
        for (const {
          ddFillAttributes: t,
          ddOutlineAttributes: i,
          page: r,
          geometry: l
        } of n) this._processFeature(l, f, e.outlineUsesFillColor, t, i, d, r);
      }
    } else for (const h of u) {
      const o = n ? r.encodeAttributes(h, i, e) : null,
        a = f && s ? l.encodeAttributes(h, i, e) : null,
        u = h.getGeometry(t);
      this._processFeature(u, f, e.outlineUsesFillColor, o, a, d);
    }
  }
  serialize() {
    let t = 10;
    t += this.layerUIDs.length, t += this._fillVertexBuffer.array.length, t += this._fillIndexBuffer.array.length, t += this._outlineVertexBuffer.array.length, t += this._outlineIndexBuffer.array.length, t += 3 * this._patternMap.size + 1;
    const e = new Uint32Array(t),
      i = new Int32Array(e.buffer);
    let r = 0;
    e[r++] = this.type, e[r++] = this.layerUIDs.length;
    for (let s = 0; s < this.layerUIDs.length; s++) e[r++] = this.layerUIDs[s];
    e[r++] = this._fillIndexStart, e[r++] = this._fillIndexCount, e[r++] = this._outlineIndexStart, e[r++] = this._outlineIndexCount;
    const l = this._patternMap,
      n = l.size;
    if (e[r++] = n, n > 0) for (const [s, [o, a]] of l) e[r++] = s, e[r++] = o, e[r++] = a;
    e[r++] = this._fillVertexBuffer.array.length;
    for (let s = 0; s < this._fillVertexBuffer.array.length; s++) i[r++] = this._fillVertexBuffer.array[s];
    e[r++] = this._fillIndexBuffer.array.length;
    for (let s = 0; s < this._fillIndexBuffer.array.length; s++) e[r++] = this._fillIndexBuffer.array[s];
    e[r++] = this._outlineVertexBuffer.array.length;
    for (let s = 0; s < this._outlineVertexBuffer.array.length; s++) i[r++] = this._outlineVertexBuffer.array[s];
    e[r++] = this._outlineIndexBuffer.array.length;
    for (let s = 0; s < this._outlineIndexBuffer.array.length; s++) e[r++] = this._outlineIndexBuffer.array[s];
    return e.buffer;
  }
  _processFeature(t, e, i, r, l, n, o) {
    if (!t) return;
    const a = t.length,
      f = !l || 0 === l.length;
    if (e && (!i || f)) for (let s = 0; s < a; s++) this._processOutline(t[s], l);
    const u = 32;
    let d;
    for (let h = 0; h < a; h++) {
      const e = s._area(t[h]);
      e > u ? (void 0 !== d && this._processFill(t, d, r, n, o), d = [h]) : e < -u && void 0 !== d && d.push(h);
    }
    void 0 !== d && this._processFill(t, d, r, n, o);
  }
  _processOutline(t, e) {
    const i = this._outlineVertexBuffer,
      l = this._outlineIndexBuffer,
      n = l.index;
    let s, o, a;
    const f = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point(0, 0),
      u = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point(0, 0),
      d = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point(0, 0);
    let h = -1,
      x = -1,
      c = -1,
      _ = -1,
      y = -1,
      g = !1;
    const p = 0;
    let I = t.length;
    if (I < 2) return;
    const B = t[p];
    let m = t[I - 1];
    for (; I && m.isEqual(B);) --I, m = t[I - 1];
    if (!(I - p < 2)) {
      for (let r = p; r < I; ++r) {
        r === p ? (s = t[I - 1], o = t[p], a = t[p + 1], f.assignSub(o, s), f.normalize(), f.rightPerpendicular()) : (s = o, o = a, a = r !== I - 1 ? t[r + 1] : t[p], f.assign(u));
        const n = this._isClipEdge(s, o);
        -1 === _ && (g = n), u.assignSub(a, o), u.normalize(), u.rightPerpendicular();
        const B = f.x * u.y - f.y * u.x;
        d.assignAdd(f, u), d.normalize();
        const m = -d.x * -f.x + -d.y * -f.y;
        let V = Math.abs(0 !== m ? 1 / m : 1);
        V > 8 && (V = 8), B >= 0 ? (c = i.add(o.x, o.y, f.x, f.y, 0, 1, e), -1 === _ && (_ = c), h >= 0 && x >= 0 && c >= 0 && !n && l.add(h, x, c), x = i.add(o.x, o.y, V * -d.x, V * -d.y, 0, -1, e), -1 === y && (y = x), h >= 0 && x >= 0 && c >= 0 && !n && l.add(h, x, c), h = x, x = c, c = i.add(o.x, o.y, d.x, d.y, 0, 1, e), h >= 0 && x >= 0 && c >= 0 && !n && l.add(h, x, c), x = i.add(o.x, o.y, u.x, u.y, 0, 1, e), h >= 0 && x >= 0 && c >= 0 && !n && l.add(h, x, c)) : (c = i.add(o.x, o.y, V * d.x, V * d.y, 0, 1, e), -1 === _ && (_ = c), h >= 0 && x >= 0 && c >= 0 && !n && l.add(h, x, c), x = i.add(o.x, o.y, -f.x, -f.y, 0, -1, e), -1 === y && (y = x), h >= 0 && x >= 0 && c >= 0 && !n && l.add(h, x, c), h = x, x = c, c = i.add(o.x, o.y, -d.x, -d.y, 0, -1, e), h >= 0 && x >= 0 && c >= 0 && !n && l.add(h, x, c), h = i.add(o.x, o.y, -u.x, -u.y, 0, -1, e), h >= 0 && x >= 0 && c >= 0 && !n && l.add(h, x, c));
      }
      h >= 0 && x >= 0 && _ >= 0 && !g && l.add(h, x, _), h >= 0 && _ >= 0 && y >= 0 && !g && l.add(h, y, _), this._outlineIndexCount += 3 * (l.index - n);
    }
  }
  _processFill(r, l, n, s, o) {
    s = !0;
    let a;
    l.length > 1 && (a = []);
    let f = 0;
    for (const t of l) 0 !== f && a.push(f), f += r[t].length;
    const u = 2 * f,
      d = _core_ArrayPool_js__WEBPACK_IMPORTED_MODULE_0__["default"].acquire();
    for (const t of l) {
      const e = r[t],
        i = e.length;
      for (let t = 0; t < i; ++t) d.push(e[t].x, e[t].y);
    }
    const h = (0,_chunks_earcut_js__WEBPACK_IMPORTED_MODULE_1__.e)(d, a, 2);
    if (s && _chunks_earcut_js__WEBPACK_IMPORTED_MODULE_1__.e.deviation(d, a, 2, h) > 0) {
      const t = l.map(t => r[t].length),
        {
          buffer: e,
          vertexCount: s
        } = (0,_geometry_libtess_js__WEBPACK_IMPORTED_MODULE_2__.triangulate)(d, t);
      if (s > 0) {
        const t = this._fillVertexBuffer.index;
        for (let i = 0; i < s; i++) this._fillVertexBuffer.add(e[2 * i], e[2 * i + 1], n);
        for (let e = 0; e < s; e += 3) {
          const i = t + e;
          this._fillIndexBuffer.add(i, i + 1, i + 2);
        }
        if (void 0 !== o) {
          const t = this._patternMap,
            e = t.get(o);
          e ? e[1] += s : t.set(o, [this._fillIndexStart + this._fillIndexCount, s]);
        }
        this._fillIndexCount += s;
      }
    } else {
      const t = h.length;
      if (t > 0) {
        const e = this._fillVertexBuffer.index;
        let i = 0;
        for (; i < u;) this._fillVertexBuffer.add(d[i++], d[i++], n);
        let r = 0;
        for (; r < t;) this._fillIndexBuffer.add(e + h[r++], e + h[r++], e + h[r++]);
        if (void 0 !== o) {
          const e = this._patternMap,
            i = e.get(o);
          i ? i[1] += t : e.set(o, [this._fillIndexStart + this._fillIndexCount, t]);
        }
        this._fillIndexCount += t;
      }
    }
    _core_ArrayPool_js__WEBPACK_IMPORTED_MODULE_0__["default"].release(d);
  }
  _isClipEdge(t, e) {
    return t.x === e.x ? t.x <= -64 || t.x >= 4160 : t.y === e.y && (t.y <= -64 || t.y >= 4160);
  }
  static _area(t) {
    let e = 0;
    const i = t.length - 1;
    for (let r = 0; r < i; r++) e += (t[r].x - t[r + 1].x) * (t[r].y + t[r + 1].y);
    return e += (t[i].x - t[0].x) * (t[i].y + t[0].y), .5 * e;
  }
}


/***/ }),

/***/ 11029:
/*!*************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/LineBucket.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ n)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ 41780);
/* harmony import */ var _BaseBucket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseBucket.js */ 33579);
/* harmony import */ var _webgl_TurboLine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/TurboLine.js */ 35246);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/



const s = 65535;
class n extends _BaseBucket_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(t, s, n, a, o) {
    super(t, s, n), this.type = _enums_js__WEBPACK_IMPORTED_MODULE_0__.BucketType.LINE, this._tessellationOptions = {
      pixelCoordRatio: 8,
      halfWidth: 0,
      offset: 0
    }, this._patternMap = new Map(), this.tessellationProperties = {
      _lineVertexBuffer: null,
      _lineIndexBuffer: null,
      _ddValues: null
    }, this.tessellationProperties._lineVertexBuffer = a, this.tessellationProperties._lineIndexBuffer = o, this._lineTessellator = new _webgl_TurboLine_js__WEBPACK_IMPORTED_MODULE_2__.LineTessellation(r(this.tessellationProperties), l(this.tessellationProperties), t.canUseThinTessellation);
  }
  get lineIndexStart() {
    return this._lineIndexStart;
  }
  get lineIndexCount() {
    return this._lineIndexCount;
  }
  getResources(e, t, i) {
    const s = this.layer,
      n = this.zoom,
      r = s.getPaintProperty("line-pattern"),
      l = s.getPaintProperty("line-dasharray"),
      a = s.getLayoutProperty("line-cap");
    if (!r && !l) return;
    const o = a?.getValue(n) || 0,
      u = a?.isDataDriven,
      f = r?.isDataDriven,
      h = l?.isDataDriven;
    if (f || h) for (const p of this._features) t(f ? r.getValue(n, p) : this._getDashArrayKey(p, n, s, l, u, a, o));else if (r) t(r.getValue(n));else if (l) {
      const e = l.getValue(n);
      t(s.getDashKey(e, o));
    }
  }
  processFeatures(e) {
    this._lineIndexStart = 3 * this.tessellationProperties._lineIndexBuffer.index, this._lineIndexCount = 0;
    const t = this.layer,
      i = this.zoom,
      s = this._features,
      n = this._tessellationOptions,
      {
        hasDataDrivenLine: r,
        lineMaterial: l
      } = t;
    e && e.setExtent(this.layerExtent);
    const a = t.getPaintProperty("line-pattern"),
      o = t.getPaintProperty("line-dasharray"),
      u = a?.isDataDriven,
      f = o?.isDataDriven;
    let h;
    h = t.getLayoutProperty("line-cap");
    const p = h?.isDataDriven ? h : null,
      g = p ? null : t.getLayoutValue("line-cap", i),
      y = g || 0,
      d = !!p;
    h = t.getLayoutProperty("line-join");
    const c = h?.isDataDriven ? h : null,
      _ = c ? null : t.getLayoutValue("line-join", i);
    h = t.getLayoutProperty("line-miter-limit");
    const x = h?.isDataDriven ? h : null,
      V = x ? null : t.getLayoutValue("line-miter-limit", i);
    h = t.getLayoutProperty("line-round-limit");
    const m = h?.isDataDriven ? h : null,
      D = m ? null : t.getLayoutValue("line-round-limit", i);
    h = t.getPaintProperty("line-width");
    const P = h?.isDataDriven ? h : null,
      I = P ? null : t.getPaintValue("line-width", i);
    h = t.getPaintProperty("line-offset");
    const L = h?.isDataDriven ? h : null,
      B = L ? null : t.getPaintValue("line-offset", i);
    if (u || f) {
      const r = [];
      for (const n of s) {
        const s = u ? a.getValue(i, n) : this._getDashArrayKey(n, i, t, o, d, p, y),
          f = this._spriteInfo[s];
        if (!f?.rect) continue;
        const h = l.encodeAttributes(n, i, t, f),
          v = n.getGeometry(e);
        r.push({
          ddAttributes: h,
          page: f.page,
          cap: p ? p.getValue(i, n) : g,
          join: c ? c.getValue(i, n) : _,
          miterLimit: x ? x.getValue(i, n) : V,
          roundLimit: m ? m.getValue(i, n) : D,
          halfWidth: .5 * (P ? P.getValue(i, n) : I),
          offset: L ? L.getValue(i, n) : B,
          geometry: v
        });
      }
      r.sort((e, t) => e.page - t.page), n.textured = !0;
      for (const {
        ddAttributes: e,
        page: t,
        cap: i,
        join: s,
        miterLimit: l,
        roundLimit: a,
        halfWidth: o,
        offset: u,
        geometry: f
      } of r) n.capType = i, n.joinType = s, n.miterLimit = l, n.roundLimit = a, n.halfWidth = o, n.offset = u, this._processFeature(f, e, t);
    } else {
      if (a) {
        const e = a.getValue(i),
          t = this._spriteInfo[e];
        if (!t?.rect) return;
      }
      n.textured = !(!a && !o), n.capType = g, n.joinType = _, n.miterLimit = V, n.roundLimit = D, n.halfWidth = .5 * I, n.offset = B;
      for (const a of s) {
        const s = r ? l.encodeAttributes(a, i, t) : null;
        p && (n.capType = p.getValue(i, a)), c && (n.joinType = c.getValue(i, a)), x && (n.miterLimit = x.getValue(i, a)), m && (n.roundLimit = m.getValue(i, a)), P && (n.halfWidth = .5 * P.getValue(i, a)), L && (n.offset = L.getValue(i, a));
        const o = a.getGeometry(e);
        this._processFeature(o, s);
      }
    }
  }
  serialize() {
    let e = 6;
    e += this.layerUIDs.length, e += this.tessellationProperties._lineVertexBuffer.array.length, e += this.tessellationProperties._lineIndexBuffer.array.length, e += 3 * this._patternMap.size + 1;
    const t = new Uint32Array(e),
      i = new Int32Array(t.buffer);
    let s = 0;
    t[s++] = this.type, t[s++] = this.layerUIDs.length;
    for (let l = 0; l < this.layerUIDs.length; l++) t[s++] = this.layerUIDs[l];
    t[s++] = this._lineIndexStart, t[s++] = this._lineIndexCount;
    const n = this._patternMap,
      r = n.size;
    if (t[s++] = r, r > 0) for (const [l, [a, o]] of n) t[s++] = l, t[s++] = a, t[s++] = o;
    t[s++] = this.tessellationProperties._lineVertexBuffer.array.length;
    for (let l = 0; l < this.tessellationProperties._lineVertexBuffer.array.length; l++) i[s++] = this.tessellationProperties._lineVertexBuffer.array[l];
    t[s++] = this.tessellationProperties._lineIndexBuffer.array.length;
    for (let l = 0; l < this.tessellationProperties._lineIndexBuffer.array.length; l++) t[s++] = this.tessellationProperties._lineIndexBuffer.array[l];
    return t.buffer;
  }
  _processFeature(e, t, i) {
    if (!e) return;
    const s = e.length;
    for (let n = 0; n < s; n++) this._processGeometry(e[n], t, i);
  }
  _processGeometry(e, t, i) {
    if (e.length < 2) return;
    const n = .001;
    let r,
      l,
      a = e[0],
      o = 1;
    for (; o < e.length;) r = e[o].x - a.x, l = e[o].y - a.y, r * r + l * l < n * n ? e.splice(o, 1) : (a = e[o], ++o);
    if (e.length < 2) return;
    const u = this.tessellationProperties._lineIndexBuffer,
      f = 3 * u.index;
    this._tessellationOptions.initialDistance = 0, this._tessellationOptions.wrapDistance = s, this.tessellationProperties._ddValues = t, this._lineTessellator.tessellate(e, this._tessellationOptions);
    const h = 3 * u.index - f;
    if (void 0 !== i) {
      const e = this._patternMap,
        t = e.get(i);
      t ? t[1] += h : e.set(i, [f + this._lineIndexCount, h]);
    }
    this._lineIndexCount += h;
  }
  _getDashArrayKey(e, t, i, s, n, r, l) {
    const a = n ? r.getValue(t, e) : l,
      o = s.getValue(t, e);
    return i.getDashKey(o, a);
  }
}
const r = e => (t, i, s, n, r, l, a, o, u, f, h) => (e._lineVertexBuffer.add(t, i, a, o, s, n, r, l, u, f, h, e._ddValues), e._lineVertexBuffer.index - 1),
  l = e => (t, i, s) => {
    e._lineIndexBuffer.add(t, i, s);
  };


/***/ }),

/***/ 49344:
/*!***************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/SymbolBucket.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ L)
/* harmony export */ });
/* harmony import */ var _core_BidiEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../core/BidiEngine.js */ 56231);
/* harmony import */ var _core_maybe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../core/maybe.js */ 53661);
/* harmony import */ var _core_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../core/string.js */ 3758);
/* harmony import */ var _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../geometry/support/TileClipper.js */ 99220);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enums.js */ 41780);
/* harmony import */ var _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../GeometryUtils.js */ 12693);
/* harmony import */ var _Placement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Placement.js */ 93352);
/* harmony import */ var _TextShaping_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../TextShaping.js */ 49121);
/* harmony import */ var _BaseBucket_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BaseBucket.js */ 33579);
/* harmony import */ var _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../style/StyleDefinition.js */ 37599);
/* harmony import */ var _style_StyleLayer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../style/StyleLayer.js */ 70193);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/











const b = 10;
function A(e, t) {
  return e.iconMosaicItem && t.iconMosaicItem ? e.iconMosaicItem.page === t.iconMosaicItem.page ? 0 : e.iconMosaicItem.page - t.iconMosaicItem.page : e.iconMosaicItem && !t.iconMosaicItem ? 1 : !e.iconMosaicItem && t.iconMosaicItem ? -1 : 0;
}
class L extends _BaseBucket_js__WEBPACK_IMPORTED_MODULE_8__["default"] {
  constructor(e, t, n, i, s, a, r, l) {
    super(e, t, l.getSpriteItems()), this.type = _enums_js__WEBPACK_IMPORTED_MODULE_4__.BucketType.SYMBOL, this._markerMap = new Map(), this._glyphMap = new Map(), this._glyphBufferDataStorage = new Map(), this._isIconSDF = !1, this._iconVertexBuffer = n, this._iconIndexBuffer = i, this._textVertexBuffer = s, this._textIndexBuffer = a, this._placementEngine = r, this._workerTileHandler = l;
  }
  get markerPageMap() {
    return this._markerMap;
  }
  get glyphsPageMap() {
    return this._glyphMap;
  }
  get symbolInstances() {
    return this._symbolInstances;
  }
  getResources(e, t, i) {
    const s = this.layer,
      o = this.zoom;
    e && e.setExtent(this.layerExtent);
    const a = s.getLayoutProperty("icon-image"),
      r = s.getLayoutProperty("text-field");
    let l = s.getLayoutProperty("text-transform"),
      h = s.getLayoutProperty("text-font");
    const x = [];
    let c, d, f, g;
    a && !a.isDataDriven && (c = a.getValue(o)), r && !r.isDataDriven && (d = r.getValue(o)), l && l.isDataDriven || (f = s.getLayoutValue("text-transform", o), l = null), h && h.isDataDriven || (g = s.getLayoutValue("text-font", o), h = null);
    for (const m of this._features) {
      const u = m.getGeometry(e);
      if (!u || 0 === u.length) continue;
      let p, _;
      a && (p = a.isDataDriven ? a.getValue(o, m) : this._replaceKeys(c, m.values), p && t(p));
      let M = !1;
      if (r && (_ = r.isDataDriven ? r.getValue(o, m) : this._replaceKeys(d, m.values), _)) {
        switch (_ = _.replaceAll("\\n", "\n"), l && (f = l.getValue(o, m)), f) {
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.TextTransform.LOWERCASE:
            _ = _.toLowerCase();
            break;
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.TextTransform.UPPERCASE:
            _ = _.toUpperCase();
        }
        if (L._bidiEngine.hasBidiChar(_)) {
          let e;
          e = "rtl" === L._bidiEngine.checkContextual(_) ? "IDNNN" : "ICNNN", _ = L._bidiEngine.bidiTransform(_, e, "VLYSN"), M = !0;
        }
        if (_.length > 0) {
          h && (g = h.getValue(o, m));
          for (const e of g) {
            let t = i[e];
            t || (t = i[e] = new Set());
            for (const e of _) {
              const n = e.codePointAt(0);
              null != n && t.add(n);
            }
          }
        }
      }
      if (!p && !_) continue;
      const P = s.getLayoutValue("symbol-sort-key", o, m),
        I = {
          feature: m,
          sprite: p,
          label: _,
          rtl: M,
          geometry: u,
          hash: (_ ? (0,_core_string_js__WEBPACK_IMPORTED_MODULE_2__.numericHash)(_) : 0) ^ (p ? (0,_core_string_js__WEBPACK_IMPORTED_MODULE_2__.numericHash)(p) : 0),
          priority: P,
          textFont: g
        };
      x.push(I);
    }
    this._symbolFeatures = x;
  }
  processFeatures(e) {
    e && e.setExtent(this.layerExtent);
    const n = this.layer,
      s = this.zoom,
      o = n.getLayoutValue("symbol-placement", s),
      r = o !== _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolPlacement.POINT,
      l = n.getLayoutValue("symbol-spacing", s) * _Placement_js__WEBPACK_IMPORTED_MODULE_6__.tilePixelRatio,
      g = n.getLayoutProperty("icon-image"),
      y = n.getLayoutProperty("text-field"),
      b = g ? new _style_StyleLayer_js__WEBPACK_IMPORTED_MODULE_10__.IconLayout(n, s, r) : null,
      V = y ? new _style_StyleLayer_js__WEBPACK_IMPORTED_MODULE_10__.TextLayout(n, s, r) : null,
      T = this._workerTileHandler;
    let w;
    g && (w = T.getSpriteItems()), this._iconIndexStart = 3 * this._iconIndexBuffer.index, this._textIndexStart = 3 * this._textIndexBuffer.index, this._iconIndexCount = 0, this._textIndexCount = 0, this._markerMap.clear(), this._glyphMap.clear();
    const B = [];
    let C = 1;
    V && V.size && (C = V.size / _TextShaping_js__WEBPACK_IMPORTED_MODULE_7__.sdfGlyphSize);
    const R = V ? V.maxAngle * _GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.cDegToRad : 0,
      D = V ? V.size * _Placement_js__WEBPACK_IMPORTED_MODULE_6__.tilePixelRatio : 0;
    for (const a of this._symbolFeatures) {
      let e;
      b && w && a.sprite && (e = w[a.sprite], e && e.sdf && (this._isIconSDF = !0));
      let n;
      !!e && b.update(s, a.feature);
      let g = 0;
      const y = a.label;
      if (y) {
        (0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_1__.assertIsSome)(V), V.update(s, a.feature);
        const e = r && V.rotationAlignment === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.RotationAlignment.MAP ? V.keepUpright : V.writingMode && V.writingMode.includes(_style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.TextWritingMode.VERTICAL);
        let i = .5;
        switch (V.anchor) {
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.TOP_LEFT:
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.LEFT:
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.BOTTOM_LEFT:
            i = 0;
            break;
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.TOP_RIGHT:
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.RIGHT:
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.BOTTOM_RIGHT:
            i = 1;
        }
        let o = .5;
        switch (V.anchor) {
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.TOP_LEFT:
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.TOP:
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.TOP_RIGHT:
            o = 0;
            break;
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.BOTTOM_LEFT:
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.BOTTOM:
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolAnchor.BOTTOM_RIGHT:
            o = 1;
        }
        let l = .5;
        switch (V.justify) {
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.TextJustification.AUTO:
            l = i;
            break;
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.TextJustification.LEFT:
            l = 0;
            break;
          case _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.TextJustification.RIGHT:
            l = 1;
        }
        const x = V.letterSpacing * _TextShaping_js__WEBPACK_IMPORTED_MODULE_7__.sdfGlyphSize,
          c = r ? 0 : V.maxWidth * _TextShaping_js__WEBPACK_IMPORTED_MODULE_7__.sdfGlyphSize,
          m = V.lineHeight * _TextShaping_js__WEBPACK_IMPORTED_MODULE_7__.sdfGlyphSize,
          P = a.textFont.map(e => T.getGlyphItems(e));
        if (n = new _TextShaping_js__WEBPACK_IMPORTED_MODULE_7__.TextShaping(P, c, m, x, i, o, l).getShaping(y, a.rtl, e), n && n.length > 0) {
          let e = 1e30,
            t = -1e30;
          for (const i of n) e = Math.min(e, i.x), t = Math.max(t, i.x);
          g = (t - e + 2 * _TextShaping_js__WEBPACK_IMPORTED_MODULE_7__.sdfGlyphSize) * C * _Placement_js__WEBPACK_IMPORTED_MODULE_6__.tilePixelRatio;
        }
      }
      for (let t of a.geometry) {
        const s = [];
        if (o === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolPlacement.LINE) {
          if (n?.length && V?.size) {
            const e = V.size * _Placement_js__WEBPACK_IMPORTED_MODULE_6__.tilePixelRatio * (2 + Math.min(2, 4 * Math.abs(V.offset[1])));
            t = L._smoothVertices(t, e);
          }
          L._pushAnchors(s, t, l, g);
        } else o === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.SymbolPlacement.LINE_CENTER ? L._pushCenterAnchor(s, t) : a.feature.type === _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.GeometryType.Polygon ? L._pushCentroid(s, t) : s.push(new _Placement_js__WEBPACK_IMPORTED_MODULE_6__.Anchor(t[0].x, t[0].y));
        for (const i of s) {
          if (i.x < 0 || i.x > _Placement_js__WEBPACK_IMPORTED_MODULE_6__.tileCoordSize || i.y < 0 || i.y > _Placement_js__WEBPACK_IMPORTED_MODULE_6__.tileCoordSize) continue;
          if (r && g > 0 && V?.rotationAlignment === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.RotationAlignment.MAP && !L._honorsTextMaxAngle(t, i, g, R, D)) continue;
          const s = {
            shaping: n,
            line: t,
            iconMosaicItem: e,
            anchor: i,
            symbolFeature: a,
            textColliders: [],
            iconColliders: [],
            textVertexRanges: [],
            iconVertexRanges: []
          };
          B.push(s), this._processFeature(s, b, V);
        }
      }
    }
    B.sort(A), this._addPlacedGlyphs(), this._symbolInstances = B;
  }
  serialize() {
    let e = 11;
    e += this.layerUIDs.length, e += 3 * this.markerPageMap.size, e += 3 * this.glyphsPageMap.size, e += L._symbolsSerializationLength(this._symbolInstances), e += this._iconVertexBuffer.array.length, e += this._iconIndexBuffer.array.length, e += this._textVertexBuffer.array.length, e += this._textIndexBuffer.array.length;
    const t = new Uint32Array(e),
      n = new Int32Array(t.buffer),
      i = new Float32Array(t.buffer);
    let s = 0;
    t[s++] = this.type, t[s++] = this.layerUIDs.length;
    for (let o = 0; o < this.layerUIDs.length; o++) t[s++] = this.layerUIDs[o];
    t[s++] = this._isIconSDF ? 1 : 0, t[s++] = this.markerPageMap.size;
    for (const [o, [a, r]] of this.markerPageMap) t[s++] = o, t[s++] = a, t[s++] = r;
    t[s++] = this.glyphsPageMap.size;
    for (const [o, [a, r]] of this.glyphsPageMap) t[s++] = o, t[s++] = a, t[s++] = r;
    t[s++] = this._iconVertexBuffer.index / 4, t[s++] = this._textVertexBuffer.index / 4, s = L.serializeSymbols(t, n, i, s, this._symbolInstances), t[s++] = this._iconVertexBuffer.array.length;
    for (let o = 0; o < this._iconVertexBuffer.array.length; o++) n[s++] = this._iconVertexBuffer.array[o];
    t[s++] = this._iconIndexBuffer.array.length;
    for (let o = 0; o < this._iconIndexBuffer.array.length; o++) t[s++] = this._iconIndexBuffer.array[o];
    t[s++] = this._textVertexBuffer.array.length;
    for (let o = 0; o < this._textVertexBuffer.array.length; o++) n[s++] = this._textVertexBuffer.array[o];
    t[s++] = this._textIndexBuffer.array.length;
    for (let o = 0; o < this._textIndexBuffer.array.length; o++) t[s++] = this._textIndexBuffer.array[o];
    return t.buffer;
  }
  static _symbolsSerializationLength(e) {
    let t = 0;
    t += 1;
    for (const n of e || []) {
      t += 4, t += 1;
      for (const e of n.textColliders) t += b;
      for (const e of n.iconColliders) t += b;
      t += 1, t += 2 * n.textVertexRanges.length, t += 1, t += 2 * n.iconVertexRanges.length;
    }
    return t;
  }
  static serializeSymbols(e, t, n, i, s) {
    s = s || [], t[i++] = s.length;
    for (const o of s) {
      t[i++] = o.anchor.x, t[i++] = o.anchor.y, t[i++] = o.symbolFeature.hash, t[i++] = o.symbolFeature.priority, t[i++] = o.textColliders.length + o.iconColliders.length;
      for (const e of o.textColliders) t[i++] = e.xTile, t[i++] = e.yTile, t[i++] = e.dxPixels, t[i++] = e.dyPixels, t[i++] = e.hard ? 1 : 0, t[i++] = e.partIndex, n[i++] = e.minLod, n[i++] = e.maxLod, t[i++] = e.width, t[i++] = e.height;
      for (const e of o.iconColliders) t[i++] = e.xTile, t[i++] = e.yTile, t[i++] = e.dxPixels, t[i++] = e.dyPixels, t[i++] = e.hard ? 1 : 0, t[i++] = e.partIndex, n[i++] = e.minLod, n[i++] = e.maxLod, t[i++] = e.width, t[i++] = e.height;
      t[i++] = o.textVertexRanges.length;
      for (const [e, n] of o.textVertexRanges) t[i++] = e, t[i++] = n;
      t[i++] = o.iconVertexRanges.length;
      for (const [e, n] of o.iconVertexRanges) t[i++] = e, t[i++] = n;
    }
    return i;
  }
  _replaceKeys(e, t) {
    return e.replaceAll(/{([^{}]+)}/g, (e, n) => n in t ? t[n] : "");
  }
  _processFeature(e, t, n) {
    const {
        line: i,
        iconMosaicItem: s,
        shaping: o,
        anchor: a
      } = e,
      l = this.zoom,
      h = this.layer,
      x = !!s;
    let c = !0;
    x && (c = t?.optional || !s);
    const d = o && o.length > 0,
      f = !d || n?.optional;
    let g, y;
    if (x && (g = this._placementEngine.getIconPlacement(a, s, t)), (g || c) && (d && (y = this._placementEngine.getTextPlacement(a, o, i, n)), y || f)) {
      if (g && y || (f || c ? f || y ? c || g || (y = null) : g = null : (g = null, y = null)), y) {
        const t = h.hasDataDrivenText ? h.textMaterial.encodeAttributes(e.symbolFeature.feature, l, h) : null;
        if (this._storePlacedGlyphs(e, y.shapes, l, n.rotationAlignment, t), y.textColliders) {
          e.textColliders = y.textColliders;
          for (const e of y.textColliders) {
            e.minLod = Math.max(l + (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.log2)(e.minLod), 0), e.maxLod = Math.min(l + (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.log2)(e.maxLod), 25);
            const t = e.angle;
            if (t) {
              const n = Math.cos(t),
                i = Math.sin(t),
                s = e.dxPixels * n - e.dyPixels * i,
                o = e.dxPixels * i + e.dyPixels * n,
                a = (e.dxPixels + e.width) * n - e.dyPixels * i,
                r = (e.dxPixels + e.width) * i + e.dyPixels * n,
                l = e.dxPixels * n - (e.dyPixels + e.height) * i,
                h = e.dxPixels * i + (e.dyPixels + e.height) * n,
                x = (e.dxPixels + e.width) * n - (e.dyPixels + e.height) * i,
                c = (e.dxPixels + e.width) * i + (e.dyPixels + e.height) * n,
                d = Math.min(s, a, l, x),
                f = Math.max(s, a, l, x),
                g = Math.min(o, r, h, c),
                y = Math.max(o, r, h, c);
              e.dxPixels = d, e.dyPixels = g, e.width = f - d, e.height = y - g;
            }
          }
        }
      }
      if (g) {
        const n = h.hasDataDrivenIcon ? h.iconMaterial.encodeAttributes(e.symbolFeature.feature, l, h) : null;
        if (this._addPlacedIcons(e, g.shapes, l, s.page, t.rotationAlignment === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.RotationAlignment.VIEWPORT, n), g.iconColliders) {
          e.iconColliders = g.iconColliders;
          for (const e of g.iconColliders) {
            e.minLod = Math.max(l + (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.log2)(e.minLod), 0), e.maxLod = Math.min(l + (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.log2)(e.maxLod), 25);
            const t = e.angle;
            if (t) {
              const n = Math.cos(t),
                i = Math.sin(t),
                s = e.dxPixels * n - e.dyPixels * i,
                o = e.dxPixels * i + e.dyPixels * n,
                a = (e.dxPixels + e.width) * n - e.dyPixels * i,
                r = (e.dxPixels + e.width) * i + e.dyPixels * n,
                l = e.dxPixels * n - (e.dyPixels + e.height) * i,
                h = e.dxPixels * i + (e.dyPixels + e.height) * n,
                x = (e.dxPixels + e.width) * n - (e.dyPixels + e.height) * i,
                c = (e.dxPixels + e.width) * i + (e.dyPixels + e.height) * n,
                d = Math.min(s, a, l, x),
                f = Math.max(s, a, l, x),
                g = Math.min(o, r, h, c),
                y = Math.max(o, r, h, c);
              e.dxPixels = d, e.dyPixels = g, e.width = f - d, e.height = y - g;
            }
          }
        }
      }
    }
  }
  _addPlacedIcons(e, t, n, i, s, o) {
    const a = Math.max(n - 1, 0),
      l = this._iconVertexBuffer,
      h = this._iconIndexBuffer,
      x = this._markerMap;
    for (const c of t) {
      const t = s ? 0 : Math.max(n + (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.log2)(c.minzoom), a),
        d = s ? 25 : Math.min(n + (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.log2)(c.maxzoom), 25);
      if (d <= t) continue;
      const f = c.tl,
        g = c.tr,
        y = c.bl,
        m = c.br,
        u = c.mosaicRect,
        p = c.labelAngle,
        _ = c.minAngle,
        M = c.maxAngle,
        P = c.anchor,
        I = l.index,
        b = u.x,
        A = u.y,
        L = b + u.width,
        V = A + u.height,
        T = l.index;
      l.add(P.x, P.y, f.x, f.y, b, A, p, _, M, t, d, o), l.add(P.x, P.y, g.x, g.y, L, A, p, _, M, t, d, o), l.add(P.x, P.y, y.x, y.y, b, V, p, _, M, t, d, o), l.add(P.x, P.y, m.x, m.y, L, V, p, _, M, t, d, o), e.iconVertexRanges.length > 0 && e.iconVertexRanges[0][0] + e.iconVertexRanges[0][1] === T ? e.iconVertexRanges[0][1] += 4 : e.iconVertexRanges.push([T, 4]), h.add(I, I + 1, I + 2), h.add(I + 1, I + 2, I + 3), x.has(i) ? x.get(i)[1] += 6 : x.set(i, [this._iconIndexStart + this._iconIndexCount, 6]), this._iconIndexCount += 6;
    }
  }
  _addPlacedGlyphs() {
    const e = this._textVertexBuffer,
      t = this._textIndexBuffer,
      n = this._glyphMap;
    for (const [i, s] of this._glyphBufferDataStorage) for (const o of s) {
      const s = e.index,
        a = o.symbolInstance,
        r = o.ddAttributes,
        l = e.index;
      e.add(o.glyphAnchor[0], o.glyphAnchor[1], o.tl[0], o.tl[1], o.xmin, o.ymin, o.labelAngle, o.minAngle, o.maxAngle, o.minLod, o.maxLod, r), e.add(o.glyphAnchor[0], o.glyphAnchor[1], o.tr[0], o.tr[1], o.xmax, o.ymin, o.labelAngle, o.minAngle, o.maxAngle, o.minLod, o.maxLod, r), e.add(o.glyphAnchor[0], o.glyphAnchor[1], o.bl[0], o.bl[1], o.xmin, o.ymax, o.labelAngle, o.minAngle, o.maxAngle, o.minLod, o.maxLod, r), e.add(o.glyphAnchor[0], o.glyphAnchor[1], o.br[0], o.br[1], o.xmax, o.ymax, o.labelAngle, o.minAngle, o.maxAngle, o.minLod, o.maxLod, r), a.textVertexRanges.length > 0 && a.textVertexRanges[0][0] + a.textVertexRanges[0][1] === l ? a.textVertexRanges[0][1] += 4 : a.textVertexRanges.push([l, 4]), t.add(s, s + 1, s + 2), t.add(s + 1, s + 2, s + 3), n.has(i) ? n.get(i)[1] += 6 : n.set(i, [this._textIndexStart + this._textIndexCount, 6]), this._textIndexCount += 6;
    }
    this._glyphBufferDataStorage.clear();
  }
  _storePlacedGlyphs(e, t, n, i, s) {
    const o = Math.max(n - 1, 0),
      a = i === _style_StyleDefinition_js__WEBPACK_IMPORTED_MODULE_9__.RotationAlignment.VIEWPORT;
    let l, h, x, c, d, f, g, y, m, p, _;
    for (const u of t) {
      if (l = a ? 0 : Math.max(n + (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.log2)(u.minzoom), o), h = a ? 25 : Math.min(n + (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.log2)(u.maxzoom), 25), h <= l) continue;
      x = u.tl, c = u.tr, d = u.bl, f = u.br, g = u.labelAngle, y = u.minAngle, m = u.maxAngle, p = u.anchor, _ = u.mosaicRect, this._glyphBufferDataStorage.has(u.page) || this._glyphBufferDataStorage.set(u.page, []);
      this._glyphBufferDataStorage.get(u.page).push({
        glyphAnchor: [p.x, p.y],
        tl: [x.x, x.y],
        tr: [c.x, c.y],
        bl: [d.x, d.y],
        br: [f.x, f.y],
        xmin: _.x,
        ymin: _.y,
        xmax: _.x + _.width,
        ymax: _.y + _.height,
        labelAngle: g,
        minAngle: y,
        maxAngle: m,
        minLod: l,
        maxLod: h,
        placementLod: o,
        symbolInstance: e,
        ddAttributes: s
      });
    }
  }
  static _pushAnchors(e, t, n, i) {
    n += i;
    let o = 0;
    const a = t.length - 1;
    for (let l = 0; l < a; l++) o += _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point.distance(t[l], t[l + 1]);
    let r = i || n;
    if (r *= .5, o <= r) return;
    const h = r / o;
    let c = 0,
      d = -(n = o / Math.max(Math.round(o / n), 1)) / 2;
    const f = t.length - 1;
    for (let s = 0; s < f; s++) {
      const i = t[s],
        o = t[s + 1],
        a = o.x - i.x,
        r = o.y - i.y,
        f = Math.sqrt(a * a + r * r);
      let g;
      for (; d + n < c + f;) {
        d += n;
        const t = (d - c) / f,
          y = (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.interpolate)(i.x, o.x, t),
          m = (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.interpolate)(i.y, o.y, t);
        void 0 === g && (g = Math.atan2(r, a)), e.push(new _Placement_js__WEBPACK_IMPORTED_MODULE_6__.Anchor(y, m, g, s, h));
      }
      c += f;
    }
  }
  static _pushCenterAnchor(e, t) {
    let n = 0;
    const i = t.length - 1;
    for (let l = 0; l < i; l++) n += _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point.distance(t[l], t[l + 1]);
    const o = n / 2;
    let a = 0;
    const r = t.length - 1;
    for (let s = 0; s < r; s++) {
      const n = t[s],
        i = t[s + 1],
        r = i.x - n.x,
        h = i.y - n.y,
        c = Math.sqrt(r * r + h * h);
      if (o < a + c) {
        const t = (o - a) / c,
          d = (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.interpolate)(n.x, i.x, t),
          f = (0,_GeometryUtils_js__WEBPACK_IMPORTED_MODULE_5__.interpolate)(n.y, i.y, t),
          g = Math.atan2(h, r);
        return void e.push(new _Placement_js__WEBPACK_IMPORTED_MODULE_6__.Anchor(d, f, g, s, 0));
      }
      a += c;
    }
  }
  static _deviation(e, t, n) {
    const i = (t.x - e.x) * (n.x - t.x) + (t.y - e.y) * (n.y - t.y),
      s = (t.x - e.x) * (n.y - t.y) - (t.y - e.y) * (n.x - t.x);
    return Math.atan2(s, i);
  }
  static _honorsTextMaxAngle(e, t, n, i, o) {
    let a = 0;
    const r = n / 2;
    let l = new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point(t.x, t.y),
      h = t.segment + 1;
    for (; a > -r;) {
      if (--h, h < 0) return !1;
      a -= _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point.distance(e[h], l), l = e[h];
    }
    a += _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point.distance(e[h], e[h + 1]);
    const x = [];
    let c = 0;
    const d = e.length;
    for (; a < r;) {
      const t = e[h];
      let n,
        r = h;
      do {
        if (++r, r === d) return !1;
        n = e[r];
      } while (n.isEqual(t));
      let l,
        f = r;
      do {
        if (++f, f === d) return !1;
        l = e[f];
      } while (l.isEqual(n));
      const g = this._deviation(t, n, l);
      for (x.push({
        deviation: g,
        distToAnchor: a
      }), c += g; a - x[0].distToAnchor > o;) c -= x.shift().deviation;
      if (Math.abs(c) > i) return !1;
      a += _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point.distance(n, l), h = r;
    }
    return !0;
  }
  static _smoothVertices(e, t) {
    if (t <= 0) return e;
    let n = e.length;
    if (n < 3) return e;
    const i = [];
    let o = 0,
      a = 0;
    i.push(0);
    for (let y = 1; y < n; y++) {
      const t = _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point.distance(e[y], e[y - 1]);
      t > 0 && (o += t, i.push(o), a++, a !== y && (e[a] = e[y]));
    }
    if (n = a + 1, n < 3) return e;
    t = Math.min(t, .2 * o);
    const r = e[0].x,
      l = e[0].y,
      h = e[n - 1].x,
      x = e[n - 1].y,
      c = _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point.sub(e[0], e[1]);
    c.normalize(), e[0].x += t * c.x, e[0].y += t * c.y, c.assignSub(e[n - 1], e[n - 2]), c.normalize(), e[n - 1].x += t * c.x, e[n - 1].y += t * c.y, i[0] -= t, i[n - 1] += t;
    const d = [];
    d.push(new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point(r, l));
    const f = 1e-6,
      g = .5 * t;
    for (let y = 1; y < n - 1; y++) {
      let o = 0,
        a = 0,
        r = 0;
      for (let n = y - 1; n >= 0; n--) {
        const s = g + i[n + 1] - i[y];
        if (s < 0) break;
        const l = i[n + 1] - i[n],
          h = i[y] - i[n] < g ? 1 : s / l;
        if (h < f) break;
        const x = h * h,
          c = h * s - .5 * x * l,
          d = h * l / t,
          m = e[n + 1],
          u = e[n].x - m.x,
          p = e[n].y - m.y;
        o += d / c * (m.x * h * s + .5 * x * (s * u - l * m.x) - x * h * l * u / 3), a += d / c * (m.y * h * s + .5 * x * (s * p - l * m.y) - x * h * l * p / 3), r += d;
      }
      for (let s = y + 1; s < n; s++) {
        const n = g - i[s - 1] + i[y];
        if (n < 0) break;
        const l = i[s] - i[s - 1],
          h = i[s] - i[y] < g ? 1 : n / l;
        if (h < f) break;
        const x = h * h,
          c = h * n - .5 * x * l,
          d = h * l / t,
          m = e[s - 1],
          u = e[s].x - m.x,
          p = e[s].y - m.y;
        o += d / c * (m.x * h * n + .5 * x * (n * u - l * m.x) - x * h * l * u / 3), a += d / c * (m.y * h * n + .5 * x * (n * p - l * m.y) - x * h * l * p / 3), r += d;
      }
      d.push(new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point(o / r, a / r));
    }
    return d.push(new _geometry_support_TileClipper_js__WEBPACK_IMPORTED_MODULE_3__.Point(h, x)), e[0].x = r, e[0].y = l, e[n - 1].x = h, e[n - 1].y = x, d;
  }
  static _pushCentroid(e, t) {
    const n = 0,
      i = 0,
      s = 4096,
      o = 4096,
      a = t.length - 1;
    let r = 0,
      l = 0,
      h = 0,
      c = t[0].x,
      d = t[0].y;
    c > s && (c = s), c < n && (c = n), d > o && (d = o), d < i && (d = i);
    for (let x = 1; x < a; x++) {
      let e = t[x].x,
        a = t[x].y,
        f = t[x + 1].x,
        g = t[x + 1].y;
      e > s && (e = s), e < n && (e = n), a > o && (a = o), a < i && (a = i), f > s && (f = s), f < n && (f = n), g > o && (g = o), g < i && (g = i);
      const y = (e - c) * (g - d) - (f - c) * (a - d);
      r += y * (c + e + f), l += y * (d + a + g), h += y;
    }
    r /= 3 * h, l /= 3 * h, isNaN(r) || isNaN(l) || e.push(new _Placement_js__WEBPACK_IMPORTED_MODULE_6__.Anchor(r, l));
  }
}
L._bidiEngine = new _core_BidiEngine_js__WEBPACK_IMPORTED_MODULE_0__["default"]();


/***/ }),

/***/ 72157:
/*!**************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/config.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "collisionGridCellSize": () => (/* binding */ t),
/* harmony export */   "declutterBudget": () => (/* binding */ c),
/* harmony export */   "declutterTiles": () => (/* binding */ o),
/* harmony export */   "fadeDuration": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
const o = !0,
  t = 32,
  c = 1.5,
  e = 200;


/***/ }),

/***/ 80696:
/*!************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/definitions.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "angleFactor256": () => (/* binding */ f),
/* harmony export */   "attributeDataAnimation": () => (/* binding */ Q),
/* harmony export */   "attributeDataDd0": () => (/* binding */ T),
/* harmony export */   "attributeDataDd1": () => (/* binding */ U),
/* harmony export */   "attributeDataFilterFlags": () => (/* binding */ P),
/* harmony export */   "attributeDataGpgpu": () => (/* binding */ R),
/* harmony export */   "attributeDataVv": () => (/* binding */ S),
/* harmony export */   "attributeStoreTextureSize": () => (/* binding */ A),
/* harmony export */   "averageGlyphMosaicItem": () => (/* binding */ z),
/* harmony export */   "bitsetFillHasPatternHeightPrecisionFactor": () => (/* binding */ ye),
/* harmony export */   "bitsetFillHasPatternWidthPrecisionFactor": () => (/* binding */ be),
/* harmony export */   "bitsetFillHasUnresolvedReplacementColor": () => (/* binding */ ve),
/* harmony export */   "bitsetFillRandomPatternOffset": () => (/* binding */ ue),
/* harmony export */   "bitsetGenericConsiderAlphaOnly": () => (/* binding */ ge),
/* harmony export */   "bitsetGenericLockColor": () => (/* binding */ pe),
/* harmony export */   "bitsetLineScaleDash": () => (/* binding */ je),
/* harmony export */   "bitsetMarkerAlignmentMap": () => (/* binding */ ne),
/* harmony export */   "bitsetMarkerAlignmentScreen": () => (/* binding */ le),
/* harmony export */   "bitsetMarkerOutlineAllowColorOverride": () => (/* binding */ we),
/* harmony export */   "bitsetMarkerScaleSymbolsProportionally": () => (/* binding */ xe),
/* harmony export */   "bitsetTypeFillOutline": () => (/* binding */ ke),
/* harmony export */   "bufferDataMinimumSize": () => (/* binding */ ie),
/* harmony export */   "bufferDataPoolSize": () => (/* binding */ he),
/* harmony export */   "chartMaxFields": () => (/* binding */ n),
/* harmony export */   "collisionBoxPadding": () => (/* binding */ j),
/* harmony export */   "collisionBucketSize": () => (/* binding */ p),
/* harmony export */   "collisionEarlyRejectBucketSize": () => (/* binding */ g),
/* harmony export */   "collisionMaxZoomDelta": () => (/* binding */ x),
/* harmony export */   "collisionPlacementPadding": () => (/* binding */ u),
/* harmony export */   "collisionTileBoxSize": () => (/* binding */ k),
/* harmony export */   "compressionFactorForU16": () => (/* binding */ h),
/* harmony export */   "debugLabels": () => (/* binding */ s),
/* harmony export */   "displayRecordIntPerElement": () => (/* binding */ de),
/* harmony export */   "dotDensityMaxFields": () => (/* binding */ l),
/* harmony export */   "effectFlag0": () => (/* binding */ Y),
/* harmony export */   "enableEarlyLabelDiscard": () => (/* binding */ Z),
/* harmony export */   "extrudeScale": () => (/* binding */ o),
/* harmony export */   "filterFlag0": () => (/* binding */ X),
/* harmony export */   "glyphSize": () => (/* binding */ b),
/* harmony export */   "heuristicGlyphsPerFeature": () => (/* binding */ y),
/* harmony export */   "heuristicGlyphsPerLine": () => (/* binding */ v),
/* harmony export */   "highlightFlag": () => (/* binding */ W),
/* harmony export */   "hittestRadius": () => (/* binding */ _),
/* harmony export */   "magicLabelLineHeight": () => (/* binding */ w),
/* harmony export */   "maxFilters": () => (/* binding */ V),
/* harmony export */   "maxGpuUploadsPerFrame": () => (/* binding */ oe),
/* harmony export */   "maxRepresentableInt": () => (/* binding */ m),
/* harmony export */   "maxSizeForU16Compression": () => (/* binding */ i),
/* harmony export */   "minMaxZoomPrecisionFactor": () => (/* binding */ me),
/* harmony export */   "nanMagicNumber": () => (/* binding */ t),
/* harmony export */   "patchPixelBufferAllocSize": () => (/* binding */ fe),
/* harmony export */   "patternFillRasterizationScale": () => (/* binding */ Ae),
/* harmony export */   "pictureFillColor": () => (/* binding */ a),
/* harmony export */   "randomInsidePolygonTextureSize": () => (/* binding */ se),
/* harmony export */   "rasterTileSize": () => (/* binding */ d),
/* harmony export */   "sdfTextureSize": () => (/* binding */ ce),
/* harmony export */   "spritePadding": () => (/* binding */ ae),
/* harmony export */   "textPlacementPadding": () => (/* binding */ q),
/* harmony export */   "textureBindingAttributeData0": () => (/* binding */ E),
/* harmony export */   "textureBindingAttributeData1": () => (/* binding */ F),
/* harmony export */   "textureBindingAttributeData2": () => (/* binding */ G),
/* harmony export */   "textureBindingAttributeData3": () => (/* binding */ H),
/* harmony export */   "textureBindingAttributeData4": () => (/* binding */ I),
/* harmony export */   "textureBindingAttributeData5": () => (/* binding */ J),
/* harmony export */   "textureBindingBitmap": () => (/* binding */ D),
/* harmony export */   "textureBindingGlyphAtlas": () => (/* binding */ C),
/* harmony export */   "textureBindingGpgpu": () => (/* binding */ K),
/* harmony export */   "textureBindingHighlight0": () => (/* binding */ L),
/* harmony export */   "textureBindingHighlight1": () => (/* binding */ M),
/* harmony export */   "textureBindingRenderer0": () => (/* binding */ N),
/* harmony export */   "textureBindingRenderer1": () => (/* binding */ O),
/* harmony export */   "textureBindingSpriteAtlas": () => (/* binding */ B),
/* harmony export */   "textureUploadManagerBudget": () => (/* binding */ ze),
/* harmony export */   "textureUploadManagerChunkSize": () => (/* binding */ qe),
/* harmony export */   "thinLineHalfWidthThreshold": () => (/* binding */ $),
/* harmony export */   "tileSize": () => (/* binding */ c),
/* harmony export */   "vtlHighResCutoff": () => (/* binding */ te),
/* harmony export */   "vtlTextureBindingUnitGlyphs": () => (/* binding */ re),
/* harmony export */   "vtlTextureBindingUnitSprites": () => (/* binding */ ee),
/* harmony export */   "webglMaxInnerStops": () => (/* binding */ r),
/* harmony export */   "webglMaxStops": () => (/* binding */ e)
/* harmony export */ });
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/has.js */ 67087);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/

const e = 8,
  r = e - 2,
  t = 1e-30,
  o = 64,
  a = 4294967295,
  c = 512,
  d = 256,
  f = 256 / 360,
  h = 128,
  i = 511,
  m = 16777216,
  s = !1,
  p = 128,
  l = 8,
  n = 10,
  w = 29,
  x = 1,
  g = 16,
  j = 16,
  k = c / p,
  u = 8,
  v = 50,
  y = 10,
  b = 24,
  q = 8,
  z = {
    metrics: {
      width: 15,
      height: 17,
      left: 0,
      top: -7,
      advance: 14
    }
  },
  A = 1024,
  B = 0,
  C = 0,
  D = 0,
  E = 1,
  F = 2,
  G = 3,
  H = 4,
  I = 5,
  J = 6,
  K = 12,
  L = 5,
  M = 6,
  N = 5,
  O = 6,
  P = 0,
  Q = 1,
  R = 2,
  S = 3,
  T = 3,
  U = 4,
  V = 2,
  W = 1,
  X = 2,
  Y = 4,
  Z = !1,
  $ = 1.05,
  _ = (0,_core_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("featurelayer-force-marker-text-draw-order") ? .5 : 3,
  ee = 5,
  re = 6,
  te = 1.15,
  oe = 2,
  ae = 2,
  ce = 128 - 2 * ae,
  de = 8,
  fe = 500,
  he = 4,
  ie = 128,
  me = 10,
  se = 1024,
  pe = 2,
  le = 0,
  ne = 1,
  we = 4,
  xe = 8,
  ge = 16,
  je = 4,
  ke = 1,
  ue = 4,
  ve = 8,
  ye = 32,
  be = 64,
  qe = 128,
  ze = 4,
  Ae = 2;


/***/ }),

/***/ 42776:
/*!************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/tiling/enums.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TileStatus": () => (/* binding */ I)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
var I;
!function (I) {
  I[I.INITIALIZED = 0] = "INITIALIZED", I[I.NO_DATA = 1] = "NO_DATA", I[I.READY = 2] = "READY", I[I.MODIFIED = 3] = "MODIFIED", I[I.INVALID = 4] = "INVALID";
}(I || (I = {}));


/***/ })

}]);
//# sourceMappingURL=node_modules_arcgis_core_views_2d_engine_vectorTiles_WorkerTileHandler_js-node_modules_arcgis-2f7682.js.map