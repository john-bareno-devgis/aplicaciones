"use strict";
(self["webpackChunkrealgis"] = self["webpackChunkrealgis"] || []).push([["default-node_modules_arcgis_core_geometry_GeometryCursor_js-node_modules_arcgis_core_geometry-cfd20c"],{

/***/ 2044:
/*!*********************************************************!*\
  !*** ./node_modules/@arcgis/core/core/PriorityQueue.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ t)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
class t {
  constructor(t = e) {
    this._data = [], this._compare = t;
  }
  get size() {
    return this._data.length;
  }
  enqueue(t) {
    if (null == t) return;
    const {
      _data: e,
      _compare: n
    } = this;
    e.push(t);
    let l = e.length - 1 >>> 0;
    const r = e[l];
    for (; l > 0;) {
      const t = l - 1 >> 1,
        s = e[t];
      if (!(n(s, r) <= 0)) break;
      e[t] = r, e[l] = s, l = t;
    }
  }
  dequeue() {
    const {
        _data: t,
        _compare: e
      } = this,
      n = t[0],
      l = t.pop();
    if (0 === t.length) return n;
    t[0] = l;
    let r = 0;
    const s = t.length,
      u = t[0];
    let a,
      o,
      c = null;
    for (;;) {
      const n = 2 * r + 1,
        l = 2 * r + 2;
      if (c = null, n < s && (a = t[n], e(a, u) > 0 && (c = n)), l < s && (o = t[l], (null === c && e(o, u) <= 0 || null !== c && e(o, a) <= 0) && (c = l)), null === c) break;
      t[r] = t[c], t[c] = u, r = c;
    }
    return n;
  }
}
const e = (t, e) => t < e ? -1 : t > e ? 1 : 0;


/***/ }),

/***/ 99911:
/*!**************************************************************!*\
  !*** ./node_modules/@arcgis/core/geometry/GeometryCursor.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GeometryCursor": () => (/* binding */ a)
/* harmony export */ });
/* harmony import */ var _core_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/lang.js */ 88684);
/* harmony import */ var _geometryCursorCollectUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometryCursorCollectUtils.js */ 90230);
/* harmony import */ var _support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./support/jsonUtils.js */ 71182);
/* harmony import */ var _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layers/graphics/OptimizedGeometry.js */ 93846);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/




class a {
  static fromOptimized(t, e, s = !1, i = !1) {
    return new p().initialize(t, e, s, i, 1);
  }
  static fromJSON(t, e = !1, s = !1) {
    const [i, h] = u(t);
    return new d().initialize(i, h, e, s, 1);
  }
  static fromOptimizedCIM(t, e, s = !1, i = !1) {
    return new m().initialize(t, e, s, i, 1);
  }
  static fromJSONCIM(t, e = !1, s = !1) {
    const [i, h] = u(t);
    return new y().initialize(i, h, e, s, 1);
  }
  static fromFeatureSetReader(t) {
    const e = t.readGeometryForDisplay(),
      s = t.geometryType;
    return e && s ? this.fromOptimized(e, s) : null;
  }
  static fromFeatureSetReaderCIM(t) {
    const e = t.readGeometryForDisplay(),
      s = t.geometryType;
    return e && s ? this.fromOptimizedCIM(e, s) : null;
  }
  static createEmptyOptimized(t, e = !1, s = !1) {
    return new p().initialize(new _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_3__["default"](), t, e, s, 1);
  }
  static createEmptyJSON(t, e = !1, s = !1) {
    return new d().initialize([], t, e, s, 1);
  }
  static createEmptyOptimizedCIM(t, e = !1, s = !1) {
    return new m().initialize(new _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_3__["default"](), t, e, s, 1);
  }
  static createEmptyJSONCIM(t, e = !1, s = !1) {
    return new y().initialize([], t, e, s, 1);
  }
  asJSON() {
    const t = (0,_geometryCursorCollectUtils_js__WEBPACK_IMPORTED_MODULE_1__.collectMultipath)(this);
    return "esriGeometryEnvelope" === this.geometryType ? {
      xmin: t[0][0][0],
      ymin: t[0][0][1],
      xmax: t[0][2][0],
      ymax: t[0][2][1]
    } : "esriGeometryMultipoint" === this.geometryType ? {
      points: t.flat()
    } : "esriGeometryPoint" === this.geometryType ? {
      x: t[0][0][0],
      y: t[0][0][1]
    } : "esriGeometryPolygon" === this.geometryType ? {
      rings: t
    } : {
      paths: t
    };
  }
  getCurrentRingArea() {
    if (!this || this.pathSize < 3) return 0;
    let t,
      e,
      s = 0;
    if (this.seekPathStart(), !this.nextPoint()) return 0;
    t = this.x, e = this.y;
    const i = t,
      h = e;
    for (; this.nextPoint();) s += (t - this.x) * (e + this.y), t = this.x, e = this.y;
    return s += (t - i) * (e + h), -.5 * s;
  }
  invertY() {
    this.yFactor *= -1;
  }
}
class p extends a {
  constructor() {
    super(...arguments), this._end = -1;
  }
  initialize(t, e, s, i, h) {
    return this.hasZ = s, this.hasM = i, this.geometryType = e, this._stride = 2 + Number(s) + Number(i), this._geometry = t, this._pathIndex = -1, this._pathOffset = 0, this._pointOffset = -this._stride, this._end = -1, this.yFactor = h, this;
  }
  reset() {
    this.initialize(this._geometry, this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  seekPath(t) {
    if (t >= 0 && t < this.totalSize) {
      if (this._pathIndex < t) for (; this._pathIndex < t && this.nextPath(););else if (this._pathIndex > t) for (; this._pathIndex > t && this.prevPath(););
      return !0;
    }
    return !1;
  }
  seekPathStart() {
    this._pointOffset = this._pathOffset - this._stride;
  }
  seekPathEnd() {
    this._pointOffset = this._end;
  }
  seekInPath(t) {
    const e = this._pathOffset + t * this._stride;
    return e >= 0 && e < this._end && (this._pointOffset = e, !0);
  }
  nextPoint() {
    return (this._pointOffset += this._stride) < this._end;
  }
  prevPoint() {
    return (this._pointOffset -= this._stride) >= this._pathOffset;
  }
  nextPath() {
    if (this._pathIndex >= 0) {
      const t = this._geometry.isPoint ? 1 : this._geometry.lengths[this._pathIndex];
      this._pathOffset += this._stride * t;
    }
    this._pointOffset = this._pathOffset - this._stride;
    const t = this._geometry.isPoint ? 1 : this._geometry.lengths[this._pathIndex + 1];
    return this._end = this._pointOffset + this._stride + this._stride * t, ++this._pathIndex < this.totalSize;
  }
  prevPath() {
    this._end = this._pathOffset;
    const t = this._geometry.isPoint ? 1 : this._geometry.lengths[this._pathIndex - 1];
    return this._pathOffset -= this._stride * t, this._pointOffset = this._pathOffset - this._stride, --this._pathIndex >= 0;
  }
  pathLength() {
    const t = this._end,
      e = this._stride,
      s = this._geometry.coords;
    let i = 0;
    for (let h = this._pathOffset + e; h < t; h += e) {
      const t = s[h - e],
        r = s[h - e + 1],
        n = s[h] - t,
        o = s[h + 1] - r;
      i += Math.sqrt(n * n + o * o);
    }
    return i;
  }
  startPath() {
    this._geometry.lengths.push(0);
  }
  pushPath(t) {
    this.startPath(), this.pushPoints(t);
  }
  pushPoint(t) {
    for (let e = 0; e < this._stride; ++e) this._geometry.coords.push(t[e]);
    this._geometry.lengths[this.totalSize - 1]++;
  }
  pushXY(t, e) {
    this._geometry.coords.push(t, e), this._geometry.lengths[this.totalSize - 1]++;
  }
  pushPoints(t) {
    for (const e of t) for (let t = 0; t < this._stride; ++t) this._geometry.coords.push(e[t]);
    this._geometry.lengths[this.totalSize - 1] += t.length;
  }
  pushCursor(t) {
    const e = t.asOptimized();
    this._geometry.coords.push(...e.coords), this._geometry.lengths.push(...e.lengths);
  }
  asOptimized() {
    const t = this._geometry.clone();
    if (1 !== this.yFactor) for (let e = 1; e < t.coords.length; e += this._stride) t.coords[e] *= this.yFactor;
    return "esriGeometryPoint" === this.geometryType && (t.lengths.length = 0), t;
  }
  isClosed() {
    const t = this._geometry.coords,
      e = this._pathOffset,
      s = this._end - this._stride;
    for (let i = 0; i < this._stride; i++) if (t[e + i] !== t[s + i]) return !1;
    return !0;
  }
  clone() {
    return new p().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._geometry.coords.length / this._stride;
  }
  get pathSize() {
    const {
      lengths: t
    } = this._geometry;
    return this._pathIndex < 0 || this._pathIndex > t.length - 1 ? 0 : t[this._pathIndex];
  }
  get totalSize() {
    return this._geometry.lengths.length;
  }
  get x() {
    return this._geometry.coords[this._pointOffset];
  }
  set x(t) {
    this._geometry.coords[this._pointOffset] = t;
  }
  get y() {
    return this.yFactor * this._geometry.coords[this._pointOffset + 1];
  }
  set y(t) {
    this._geometry.coords[this._pointOffset + 1] = this.yFactor * t;
  }
  get z() {
    return this._geometry.coords[this._pointOffset + 2];
  }
  set z(t) {
    this._geometry.coords[this._pointOffset + 2] = t;
  }
  get m() {
    const t = this.hasZ ? 3 : 2;
    return this._geometry.coords[this._pointOffset + t];
  }
  set m(t) {
    this._geometry.coords[this._pointOffset + 3] = t;
  }
  get pathIndex() {
    return this._pathIndex;
  }
  get _coordIndex() {
    return this._pointOffset / this._stride;
  }
}
function _(t) {
  const e = [t.x, t.y];
  return t.z && e.push(t.z), t.m && e.push(t.m), e;
}
function u(t) {
  return (0,_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__.isPolygon)(t) ? [t.rings, "esriGeometryPolygon"] : (0,_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__.isPolyline)(t) ? [t.paths, "esriGeometryPolyline"] : (0,_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__.isMultipoint)(t) ? [[t.points], "esriGeometryMultipoint"] : (0,_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__.isExtent)(t) ? [[[[t.xmin, t.ymin], [t.xmin, t.ymax], [t.xmax, t.ymax], [t.xmax, t.ymin], [t.xmin, t.ymin]]], "esriGeometryEnvelope"] : (0,_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__.isPoint)(t) ? [[[_(t)]], "esriGeometryPoint"] : [[], "esriGeometryPolyline"];
}
class d extends a {
  initialize(t, e, s, i, h) {
    return this._paths = t, this.geometryType = e, this.hasZ = s, this.hasM = i, this._pathIndex = this._pointIndex = -1, this.yFactor = h, this._mIndex = this.hasZ ? 3 : 2, this;
  }
  reset() {
    this._pathIndex = this._pointIndex = -1;
  }
  seekPath(t) {
    return t >= 0 && t < this.totalSize && (this._pathIndex = t, this._pointIndex = -1, this._currentPath = this._paths[t], !0);
  }
  seekPathStart() {
    this._pointIndex = -1;
  }
  seekPathEnd() {
    this._pointIndex = this._currentPath.length;
  }
  seekInPath(t) {
    return t >= 0 && t < this._currentPath.length && (this._pointIndex = t, this._currentPoint = this._currentPath[this._pointIndex], !0);
  }
  nextPoint() {
    return this._currentPoint = this._currentPath[++this._pointIndex], this._pointIndex < this._currentPath.length;
  }
  prevPoint() {
    return this._currentPoint = this._currentPath[--this._pointIndex], this._pointIndex >= 0;
  }
  nextPath() {
    return this._pointIndex = -1, this._currentPath = this._paths[++this._pathIndex], this._pathIndex < this.totalSize;
  }
  prevPath() {
    return this._pointIndex = -1, this._currentPath = this._paths[--this._pathIndex], this._pathIndex >= 0;
  }
  pathLength() {
    const t = this._currentPath.length,
      e = this._currentPath;
    let s = 0;
    for (let i = 1; i < t; i++) {
      const t = e[i - 1],
        h = e[i],
        r = t[0],
        n = t[1],
        o = h[0] - r,
        a = h[1] - n;
      s += Math.sqrt(o * o + a * a);
    }
    return s;
  }
  startPath() {
    this._paths.push([]);
  }
  pushPath(t) {
    this._paths.push(t);
  }
  pushPoint(t) {
    this._paths[this.totalSize - 1].push(t);
  }
  pushXY(t, e) {
    this._paths[this.totalSize - 1].push([t, e]);
  }
  pushPoints(t) {
    this._paths[this.totalSize - 1].push(...t);
  }
  pushCursor(t) {
    const s = (0,_geometryCursorCollectUtils_js__WEBPACK_IMPORTED_MODULE_1__.collectMultipath)(t);
    for (const e of s) this.pushPath(e);
  }
  asOptimized() {
    const t = new _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    if ("esriGeometryPoint" === this.geometryType) t.coords.push(...this._paths[0][0]), t.lengths.length = 0;else for (const e of this._paths) {
      for (const s of e) t.coords.push(s[0]), t.coords.push(s[1] * this.yFactor), this.hasZ && t.coords.push(s[2]), this.hasM && t.coords.push(s[this._mIndex]);
      t.lengths.push(e.length);
    }
    return t;
  }
  isClosed() {
    const t = this._currentPath[0],
      e = this._currentPath[this._currentPath.length - 1];
    for (let s = 0; s < t.length; s++) if (t[s] !== e[s]) return !1;
    return !0;
  }
  clone() {
    return new d().initialize((0,_core_lang_js__WEBPACK_IMPORTED_MODULE_0__.clone)(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._paths.map(t => t.length).reduce((t, e) => t + e);
  }
  get pathSize() {
    return this._pathIndex < 0 || this._pathIndex > this.totalSize - 1 ? -1 : this._paths[this._pathIndex].length;
  }
  get totalSize() {
    return this._paths.length;
  }
  get x() {
    return this._currentPoint[0];
  }
  set x(t) {
    this._currentPoint[0] = t;
  }
  get y() {
    return this.yFactor * this._currentPoint[1];
  }
  set y(t) {
    this._currentPoint[1] = this.yFactor * t;
  }
  get z() {
    return this._currentPoint[2];
  }
  set z(t) {
    this._currentPoint[2] = t;
  }
  get m() {
    return this._currentPoint[this._mIndex];
  }
  set m(t) {
    this._currentPoint[this._mIndex] = t;
  }
  get pathIndex() {
    return this._pathIndex;
  }
}
const c = 4,
  l = 1;
class m extends p {
  initialize(t, e, s, i, h) {
    return super.initialize(t, e, s, i, h), this._controlPoints || (this._controlPoints = this._controlPoints = new Array(this.totalSize).fill(void 0).map(t => new Set())), this;
  }
  startPath() {
    super.startPath(), this._controlPoints.push(new Set());
  }
  clone() {
    const t = new m().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
    return t._controlPoints = this._controlPoints, t;
  }
  setControlPoint() {
    this._controlPoints[this.pathIndex].add(this._coordIndex);
  }
  getControlPoint() {
    return this._controlPoints[this.pathIndex].has(this._coordIndex);
  }
  setControlPointAt(t) {
    this._controlPoints[this.pathIndex].add(t);
  }
  getControlPointAt(t) {
    return this._controlPoints[this.pathIndex].has(t);
  }
}
class y extends d {
  initialize(t, e, s, i, h) {
    return super.initialize(t, e, s, i, h);
  }
  clone() {
    return new y().initialize((0,_core_lang_js__WEBPACK_IMPORTED_MODULE_0__.clone)(this._paths), this.geometryType, this.hasZ, this.hasM, 1);
  }
  setControlPoint() {
    this._paths[this.pathIndex][this._pointIndex][c] = l;
  }
  getControlPoint() {
    return this._paths[this.pathIndex][this._pointIndex][c] === l;
  }
  setControlPointAt(t) {
    this._paths[this.pathIndex][t][c] = l;
  }
  getControlPointAt(t) {
    return this._paths[this.pathIndex][t][c] === l;
  }
}


/***/ }),

/***/ 17601:
/*!******************************************************************!*\
  !*** ./node_modules/@arcgis/core/geometry/support/labelPoint.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLabelPoint": () => (/* binding */ l),
/* harmony export */   "getPolylabelPoint": () => (/* binding */ g)
/* harmony export */ });
/* harmony import */ var _core_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/PriorityQueue.js */ 2044);
/* harmony import */ var _aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aaBoundingRect.js */ 6848);
/* harmony import */ var _boundsUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./boundsUtils.js */ 71949);
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./centroid.js */ 78127);
/* harmony import */ var _coordsUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coordsUtils.js */ 12818);
/* harmony import */ var _intersectsBase_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./intersectsBase.js */ 76438);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/






const N = 100 * 222045e-21;
function l(t) {
  if (0 === t.totalSize) return null;
  const a = (0,_boundsUtils_js__WEBPACK_IMPORTED_MODULE_2__.getCursorBoundsXY)(t);
  if (!a) return null;
  const o = 4 * (Math.abs(a[0]) + Math.abs(a[2]) + Math.abs(a[1]) + Math.abs(a[3]) + 1) * N;
  let s = 0,
    c = 0;
  t.reset();
  for (let e = 0; t.nextPath(); e++) {
    const n = t.getCurrentRingArea();
    n > c && (c = n, s = e);
  }
  if (t.seekPath(s), 0 === t.pathSize) return null;
  t.seekPathStart();
  const l = (0,_boundsUtils_js__WEBPACK_IMPORTED_MODULE_2__.getCursorPathBounds)(t);
  if (Math.abs(c) <= 2 * o * o) return [(l[0] + l[2]) / 2, (l[1] + l[3]) / 2];
  t.seekPathStart();
  const x = (0,_centroid_js__WEBPACK_IMPORTED_MODULE_3__.ringCentroidCursorXY)(t, (0,_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_1__.create)());
  if (null === x) return null;
  if (t.totalPoints < 4) return x;
  const m = [[NaN, NaN], [NaN, NaN], [NaN, NaN], [NaN, NaN]],
    d = [NaN, NaN, NaN, NaN],
    P = [NaN, NaN, NaN, NaN];
  let y = !1,
    M = f(x, t, !0);
  0 === M.distance && (y = !0, m[0][0] = x[0], m[0][1] = x[1], M = f(x, t, !1)), d[0] = M.distance, P[0] = 0;
  const b = [NaN, NaN];
  let S = !1,
    k = .25,
    z = -1,
    g = NaN;
  do {
    if (g = NaN, m[1] = h(t, w(l[0], l[2], k), o, a), isNaN(m[1][0]) || isNaN(m[1][1]) || (M = f(m[1], t, !1), g = M.distance), !isNaN(g) && g > o && u(m[1], t)) S = !0, d[1] = g, P[1] = p(m[1], x);else if (!isNaN(g) && g > z && (z = g, b[0] = m[1][0], b[1] = m[1][1]), k -= .01, k < .1) {
      if (!(z >= 0)) break;
      S = !0, d[1] = z, m[1][0] = b[0], m[1][1] = b[1], P[1] = p(m[1], x);
    }
  } while (!S);
  S = !1, k = .5, z = -1;
  let q = .01,
    j = 1;
  do {
    if (g = NaN, m[2] = h(t, w(l[0], l[2], k), o, a), isNaN(m[2][0]) || isNaN(m[2][1]) || (M = f(m[2], t, !1), g = M.distance), !isNaN(g) && g > o && u(m[2], t)) S = !0, d[2] = g, P[2] = p(m[2], x);else if (!isNaN(g) && g > z) z = g, b[0] = m[2][0], b[1] = m[2][1];else if (g > z && (z = g, b[0] = m[2][0], b[1] = m[2][1]), k = .5 + q * j, q += .01, j *= -1, k < .3 || k > .7) {
      if (!(z >= 0)) break;
      S = !0, d[2] = z, m[2][0] = b[0], m[2][1] = b[1], P[2] = p(m[2], x);
    }
  } while (!S);
  S = !1, k = .75, z = -1;
  do {
    if (g = NaN, m[3] = h(t, w(l[0], l[2], k), o, a), isNaN(m[3][0]) || isNaN(m[3][1]) || (M = f(m[3], t, !1), g = M.distance), !isNaN(g) && g > o && u(m[3], t)) S = !0, d[3] = g, P[3] = p(m[3], x);else if (g > z && (z = g, b[0] = m[3][0], b[1] = m[3][1]), k += .01, k > .9) {
      if (!(z >= 0)) break;
      S = !0, d[3] = z, m[3][0] = b[0], m[3][1] = b[1], P[3] = p(m[3], x);
    }
  } while (!S);
  const T = [0, 1, 2, 3],
    D = y ? 0 : 1;
  let R;
  for (let e = D; e < 4; e++) for (let t = D; t < 3; t++) {
    const e = P[t],
      n = P[t + 1];
    C(e, n) > 0 && (R = T[t], T[t] = T[t + 1], T[t + 1] = R, P[t] = n, P[t + 1] = e);
  }
  let B = D,
    Q = 0,
    U = 0;
  for (let e = D; e < 4; e++) {
    switch (e) {
      case 0:
        U = 2 * d[T[e]];
        break;
      case 1:
        U = 1.66666666 * d[T[e]];
        break;
      case 2:
        U = 1.33333333 * d[T[e]];
        break;
      case 3:
        U = d[T[e]];
    }
    U > Q && (Q = U, B = T[e]);
  }
  return m[B];
}
function u(t, e) {
  let n,
    i,
    r,
    a,
    o = 0;
  for (e.reset(); e.nextPath() && e.nextPoint();) for (n = e.x, i = e.y; e.nextPoint(); n = r, i = a) {
    if (r = e.x, a = e.y, i > t[1] == a > t[1]) continue;
    (r - n) * (t[1] - i) - (a - i) * (t[0] - n) > 0 ? o++ : o--;
  }
  return 0 !== o;
}
function f(t, e, n) {
  if (n && u(t, e)) return {
    coord: t,
    distance: 0
  };
  let i = 1 / 0,
    r = 0,
    a = 0,
    s = [0, 0],
    c = [0, 0];
  const N = [0, 0];
  for (e.reset(); e.nextPath() && e.nextPoint();) if (!(e.pathSize < 2)) for (s[0] = e.x, s[1] = e.y; e.nextPoint(); s = c) {
    c = [e.x, e.y], (0,_coordsUtils_js__WEBPACK_IMPORTED_MODULE_4__.projectPointOnLineSeg)(N, t, s, c);
    const n = p(t, N);
    n < i && (i = n, r = N[0], a = N[1]);
  }
  return {
    coord: [r, a],
    distance: Math.sqrt(i)
  };
}
function h(t, n, i, r) {
  const a = [n, 0];
  let o = 1 / 0,
    s = 1 / 0,
    N = !1,
    l = !1;
  const u = [[n, r[1] - 1], [n, r[3] + 1]],
    f = [0, 0],
    h = [0, 0],
    m = [0, 0],
    d = [[0, 0], [0, 0]],
    P = (0,_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_1__.create)();
  for (t.reset(); t.nextPath() && t.nextPoint();) if (!(t.pathSize < 2)) for (d[0][0] = t.x, d[0][1] = t.y; t.nextPoint(); d[0][0] = d[1][0], d[0][1] = d[1][1]) {
    if (d[1][0] = t.x, d[1][1] = t.y, null === x(P, d)) continue;
    if (h[0] = u[0][0], h[1] = u[0][1], m[0] = u[1][0], m[1] = u[1][1], 0 === M(P, h, m)) continue;
    if (!(0,_intersectsBase_js__WEBPACK_IMPORTED_MODULE_5__.segmentIntersects)(u[0], u[1], d[0], d[1], f)) continue;
    const e = f[1];
    o > s ? e < o && (o = e, N = !0) : e < s && (s = e, l = !0);
  }
  return N && l ? a[1] = (o + s) / 2 : a[0] = a[1] = NaN, a;
}
function x(t, n) {
  if (n.length < 2) return null;
  t || (t = (0,_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_1__.create)());
  const [i, r] = n[0],
    [a, o] = n[1];
  return t[0] = Math.min(i, a), t[1] = Math.min(r, o), t[2] = Math.max(i, a), t[3] = Math.max(r, o), t;
}
const m = 1,
  d = 4,
  P = 3,
  y = 12;
function M(t, e, n) {
  let i = b(e, t),
    r = b(n, t);
  const a = t[0],
    o = t[1],
    s = t[2],
    c = t[3];
  if (i & r) return 0;
  if (!(i | r)) return 4;
  const N = (i ? 1 : 0) | (r ? 2 : 0);
  do {
    const N = n[0] - e[0],
      l = n[1] - e[1];
    if (N > l) i & P ? (i & m ? (e[1] += l * (a - e[0]) / N, e[0] = a) : (e[1] += l * (s - e[0]) / N, e[0] = s), i = b(e, t)) : r & P ? (r & m ? (n[1] += l * (a - n[0]) / N, n[0] = a) : (n[1] += l * (s - n[0]) / N, n[0] = s), r = b(n, t)) : i ? (i & d ? (e[0] += N * (o - e[1]) / l, e[1] = o) : (e[0] += N * (c - e[1]) / l, e[1] = c), i = b(e, t)) : (r & d ? (n[0] += N * (o - n[1]) / l, n[1] = o) : (n[0] += N * (c - n[1]) / l, n[1] = c), r = b(n, t));else if (i & y ? (i & d ? (e[0] += N * (o - e[1]) / l, e[1] = o) : (e[0] += N * (c - e[1]) / l, e[1] = c), i = b(e, t)) : r & y ? (r & d ? (n[0] += N * (o - n[1]) / l, n[1] = o) : (n[0] += N * (c - n[1]) / l, n[1] = c), r = b(n, t)) : i ? (i & m ? (e[1] += l * (a - e[0]) / N, e[0] = a) : (e[1] += l * (s - e[0]) / N, e[0] = s), i = b(e, t)) : (r & m ? (n[1] += l * (a - n[0]) / N, n[0] = a) : (n[1] += l * (s - n[0]) / N, n[0] = s), r = b(n, t)), i & r) return 0;
  } while (i | r);
  return N;
}
function b(t, e) {
  return (t[0] < e[0] ? 1 : 0) | (t[0] > e[2] ? 1 : 0) << 1 | (t[1] < e[1] ? 1 : 0) << 2 | (t[1] > e[3] ? 1 : 0) << 3;
}
function w(t, e, n) {
  return t + (e - t) * n;
}
function p(t, e) {
  return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]);
}
function C(t, e) {
  if (t < e) return -1;
  if (t > e) return 1;
  if (t === e) return 0;
  const n = isNaN(t),
    i = isNaN(e);
  return n < i ? -1 : n > i ? 1 : 0;
}
class S {
  constructor(t, e, n, i) {
    this.x = t, this.y = e, this.cellSize = n, this.distancefromCellCenter = (0,_coordsUtils_js__WEBPACK_IMPORTED_MODULE_4__.distanceFromPointToPolygon)(t, e, i), this.maxDistanceToPolygon = this.distancefromCellCenter + this.cellSize * Math.SQRT2;
  }
}
const k = 1,
  z = 100;
function g(e) {
  if (!e.nextPath() || !e.pathSize) return null;
  const n = (0,_boundsUtils_js__WEBPACK_IMPORTED_MODULE_2__.getCursorPathBounds)(e),
    r = n[2] - n[0],
    o = n[3] - n[1];
  if (0 === r || 0 === o) return [n[0] + r / 2, n[1] + o / 2];
  const s = Math.max(Math.min(r, o) / z, k),
    c = new _core_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__["default"]((t, e) => e.maxDistanceToPolygon - t.maxDistanceToPolygon),
    N = Math.min(r, o);
  let l = N / 2,
    u = 0,
    f = 0;
  for (u = n[0]; u < n[2]; u += N) for (f = n[1]; f < n[3]; f += N) c.enqueue(new S(u + l, f + l, l, e));
  e.reset(), e.nextPath();
  const h = (0,_centroid_js__WEBPACK_IMPORTED_MODULE_3__.ringsCentroidCursor)(e);
  if (null === h) return null;
  let x,
    m = new S(h[0], h[1], 0, e);
  for (; c.size > 0;) x = c.dequeue(), x.distancefromCellCenter > m.distancefromCellCenter && (m = x), x.maxDistanceToPolygon - m.distancefromCellCenter <= s || (l = x.cellSize / 2, c.enqueue(new S(x.x - l, x.y - l, l, e)), c.enqueue(new S(x.x + l, x.y - l, l, e)), c.enqueue(new S(x.x - l, x.y + l, l, e)), c.enqueue(new S(x.x + l, x.y + l, l, e)));
  return [m.x, m.y];
}


/***/ })

}]);
//# sourceMappingURL=default-node_modules_arcgis_core_geometry_GeometryCursor_js-node_modules_arcgis_core_geometry-cfd20c.js.map