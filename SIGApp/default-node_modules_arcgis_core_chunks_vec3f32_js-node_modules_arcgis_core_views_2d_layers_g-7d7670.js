"use strict";
(self["webpackChunkrealgis"] = self["webpackChunkrealgis"] || []).push([["default-node_modules_arcgis_core_chunks_vec3f32_js-node_modules_arcgis_core_views_2d_layers_g-7d7670"],{

/***/ 49533:
/*!*****************************************************!*\
  !*** ./node_modules/@arcgis/core/chunks/vec3f32.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "O": () => (/* binding */ f),
/* harmony export */   "U": () => (/* binding */ l),
/* harmony export */   "Z": () => (/* binding */ i),
/* harmony export */   "a": () => (/* binding */ t),
/* harmony export */   "b": () => (/* binding */ e),
/* harmony export */   "c": () => (/* binding */ n),
/* harmony export */   "d": () => (/* binding */ s),
/* harmony export */   "e": () => (/* binding */ c),
/* harmony export */   "f": () => (/* binding */ r),
/* harmony export */   "g": () => (/* binding */ _),
/* harmony export */   "h": () => (/* binding */ y),
/* harmony export */   "o": () => (/* binding */ o),
/* harmony export */   "u": () => (/* binding */ u),
/* harmony export */   "v": () => (/* binding */ w),
/* harmony export */   "z": () => (/* binding */ a)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
function n() {
  return new Float32Array(3);
}
function t(n) {
  const t = new Float32Array(3);
  return t[0] = n[0], t[1] = n[1], t[2] = n[2], t;
}
function r(n, t, r) {
  const e = new Float32Array(3);
  return e[0] = n, e[1] = t, e[2] = r, e;
}
function e(n, t) {
  return new Float32Array(n, t, 3);
}
function a() {
  return n();
}
function o() {
  return r(1, 1, 1);
}
function u() {
  return r(1, 0, 0);
}
function s() {
  return r(0, 1, 0);
}
function c() {
  return r(0, 0, 1);
}
const i = a(),
  f = o(),
  l = u(),
  _ = s(),
  y = c(),
  w = Object.freeze(Object.defineProperty({
    __proto__: null,
    ONES: f,
    UNIT_X: l,
    UNIT_Y: _,
    UNIT_Z: y,
    ZEROS: i,
    clone: t,
    create: n,
    createView: e,
    fromValues: r,
    ones: o,
    unitX: u,
    unitY: s,
    unitZ: c,
    zeros: a
  }, Symbol.toStringTag, {
    value: "Module"
  }));


/***/ }),

/***/ 18661:
/*!**************************************************************************!*\
  !*** ./node_modules/@arcgis/core/geometry/support/normalizeUtilsSync.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CutVertical": () => (/* binding */ T),
/* harmony export */   "normalizeCentralMeridianForDisplay": () => (/* binding */ a),
/* harmony export */   "normalizeCentralMeridianSync": () => (/* binding */ p)
/* harmony export */ });
/* harmony import */ var _core_JSONSupport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/JSONSupport.js */ 69237);
/* harmony import */ var _aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aaBoundingRect.js */ 6848);
/* harmony import */ var _boundsUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./boundsUtils.js */ 71949);
/* harmony import */ var _coordsUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coordsUtils.js */ 12818);
/* harmony import */ var _jsonUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jsonUtils.js */ 71182);
/* harmony import */ var _normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./normalizeUtilsCommon.js */ 15686);
/* harmony import */ var _spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./spatialReferenceUtils.js */ 53492);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/







function p(t) {
  return f(t, !0);
}
function a(t) {
  return f(t, !1);
}
function f(i, n) {
  if (null == i) return null;
  const p = i.spatialReference,
    a = (0,_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_6__.getInfo)(p),
    f = (0,_core_JSONSupport_js__WEBPACK_IMPORTED_MODULE_0__.isSerializable)(i) ? i.toJSON() : i;
  if (!a) return f;
  const I = (0,_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_6__.isWebMercator)(p) ? 102100 : 4326,
    g = _normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__.cutParams[I].maxX,
    v = _normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__.cutParams[I].minX;
  if ((0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_4__.isPoint)(f)) return y(f, g, v);
  if ((0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_4__.isMultipoint)(f)) return f.points = f.points.map(t => y(t, g, v)), f;
  if ((0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_4__.isExtent)(f)) return d(f, a);
  if ((0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_4__.isPolygon)(f) || (0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_4__.isPolyline)(f)) {
    const t = (0,_boundsUtils_js__WEBPACK_IMPORTED_MODULE_2__.getBoundsXY)(S, f),
      i = {
        xmin: t[0],
        ymin: t[1],
        xmax: t[2],
        ymax: t[3]
      },
      e = (0,_normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__.offsetMagnitude)(i.xmin, v) * (2 * g),
      h = 0 === e ? f : (0,_normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__.updatePolyGeometry)(f, e);
    return i.xmin += e, i.xmax += e, i.xmax > g ? P(h, g, n) : i.xmin < v ? P(h, v, n) : h;
  }
  return f;
}
function d(t, i) {
  if (!i) return t;
  const s = I(t, i).map(t => t.extent);
  return s.length < 2 ? s[0] || t : s.length > 2 ? (t.xmin = i.valid[0], t.xmax = i.valid[1], t) : {
    rings: s.map(t => [[t.xmin, t.ymin], [t.xmin, t.ymax], [t.xmax, t.ymax], [t.xmax, t.ymin], [t.xmin, t.ymin]])
  };
}
function y(t, i, s) {
  if (Array.isArray(t)) {
    const n = t[0];
    if (n > i) {
      const s = (0,_normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__.offsetMagnitude)(n, i);
      t[0] = n + s * (-2 * i);
    } else if (n < s) {
      const i = (0,_normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__.offsetMagnitude)(n, s);
      t[0] = n + i * (-2 * s);
    }
  } else {
    const n = t.x;
    if (n > i) {
      const s = (0,_normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__.offsetMagnitude)(n, i);
      t.x += s * (-2 * i);
    } else if (n < s) {
      const i = (0,_normalizeUtilsCommon_js__WEBPACK_IMPORTED_MODULE_5__.offsetMagnitude)(n, s);
      t.x += i * (-2 * s);
    }
  }
  return t;
}
function I(t, i) {
  const s = [],
    {
      ymin: n,
      ymax: e,
      xmin: h,
      xmax: o
    } = t,
    r = t.xmax - t.xmin,
    [u, m] = i.valid,
    {
      x,
      frameId: _
    } = g(t.xmin, i),
    {
      x: l,
      frameId: c
    } = g(t.xmax, i),
    p = x === l && r > 0;
  if (r > 2 * m) {
    const t = {
        xmin: h < o ? x : l,
        ymin: n,
        xmax: m,
        ymax: e
      },
      i = {
        xmin: u,
        ymin: n,
        xmax: h < o ? l : x,
        ymax: e
      },
      r = {
        xmin: 0,
        ymin: n,
        xmax: m,
        ymax: e
      },
      p = {
        xmin: u,
        ymin: n,
        xmax: 0,
        ymax: e
      },
      a = [],
      f = [];
    v(t, r) && a.push(_), v(t, p) && f.push(_), v(i, r) && a.push(c), v(i, p) && f.push(c);
    for (let s = _ + 1; s < c; s++) a.push(s), f.push(s);
    s.push(new C(t, [_]), new C(i, [c]), new C(r, a), new C(p, f));
  } else x > l || p ? s.push(new C({
    xmin: x,
    ymin: n,
    xmax: m,
    ymax: e
  }, [_]), new C({
    xmin: u,
    ymin: n,
    xmax: l,
    ymax: e
  }, [c])) : s.push(new C({
    xmin: x,
    ymin: n,
    xmax: l,
    ymax: e
  }, [_]));
  return s;
}
function g(t, i) {
  const [s, n] = i.valid,
    e = 2 * n;
  let h,
    o = 0;
  return t > n ? (h = Math.ceil(Math.abs(t - n) / e), t -= h * e, o = h) : t < s && (h = Math.ceil(Math.abs(t - s) / e), t += h * e, o = -h), {
    x: t,
    frameId: o
  };
}
function v(t, i) {
  const {
    xmin: s,
    ymin: n,
    xmax: e,
    ymax: h
  } = i;
  return O(t, s, n) && O(t, s, h) && O(t, e, h) && O(t, e, n);
}
function O(t, i, s) {
  return i >= t.xmin && i <= t.xmax && s >= t.ymin && s <= t.ymax;
}
function P(t, i, s = !0) {
  const e = !(0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_4__.isPolyline)(t);
  if (e && (0,_coordsUtils_js__WEBPACK_IMPORTED_MODULE_3__.closeRings)(t), s) {
    return new T().cut(t, i);
  }
  const h = e ? t.rings : t.paths,
    o = e ? 4 : 2,
    r = h.length,
    m = -2 * i;
  for (let n = 0; n < r; n++) {
    const t = h[n];
    if (t && t.length >= o) {
      const i = [];
      for (const s of t) i.push([s[0] + m, s[1]]);
      h.push(i);
    }
  }
  return e ? t.rings = h : t.paths = h, t;
}
class C {
  constructor(t, i) {
    this.extent = t, this.frameIds = i;
  }
}
const S = (0,_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_1__.create)();
class T {
  constructor() {
    this._linesIn = [], this._linesOut = [];
  }
  cut(t, i) {
    let s;
    if (this._xCut = i, t.rings) this._closed = !0, s = t.rings, this._minPts = 4;else {
      if (!t.paths) return null;
      this._closed = !1, s = t.paths, this._minPts = 2;
    }
    for (const e of s) {
      if (!e || e.length < this._minPts) continue;
      let t = !0;
      for (const i of e) t ? (this.moveTo(i), t = !1) : this.lineTo(i);
      this._closed && this.close();
    }
    this._pushLineIn(), this._pushLineOut(), s = [];
    for (const e of this._linesIn) e && e.length >= this._minPts && s.push(e);
    const n = -2 * this._xCut;
    for (const e of this._linesOut) if (e && e.length >= this._minPts) {
      for (const t of e) t[0] += n;
      s.push(e);
    }
    return this._closed ? t.rings = s : t.paths = s, t;
  }
  moveTo(t) {
    this._pushLineIn(), this._pushLineOut(), this._prevSide = this._side(t[0]), this._moveTo(t[0], t[1], this._prevSide), this._prevPt = t, this._firstPt = t;
  }
  lineTo(t) {
    const i = this._side(t[0]);
    if (i * this._prevSide == -1) {
      const s = this._intersect(this._prevPt, t);
      this._lineTo(this._xCut, s, 0), this._prevSide = 0, this._lineTo(t[0], t[1], i);
    } else this._lineTo(t[0], t[1], i);
    this._prevSide = i, this._prevPt = t;
  }
  close() {
    const t = this._firstPt,
      i = this._prevPt;
    t[0] === i[0] && t[1] === i[1] || this.lineTo(t), this._checkClosingPt(this._lineIn), this._checkClosingPt(this._lineOut);
  }
  _moveTo(t, i, s) {
    this._closed ? (this._lineIn.push([s <= 0 ? t : this._xCut, i]), this._lineOut.push([s >= 0 ? t : this._xCut, i])) : (s <= 0 && this._lineIn.push([t, i]), s >= 0 && this._lineOut.push([t, i]));
  }
  _lineTo(t, i, s) {
    this._closed ? (this._addPolyVertex(this._lineIn, s <= 0 ? t : this._xCut, i), this._addPolyVertex(this._lineOut, s >= 0 ? t : this._xCut, i)) : s < 0 ? (0 === this._prevSide && this._pushLineOut(), this._lineIn.push([t, i])) : s > 0 ? (0 === this._prevSide && this._pushLineIn(), this._lineOut.push([t, i])) : this._prevSide < 0 ? (this._lineIn.push([t, i]), this._lineOut.push([t, i])) : this._prevSide > 0 && (this._lineOut.push([t, i]), this._lineIn.push([t, i]));
  }
  _addPolyVertex(t, i, s) {
    const n = t.length;
    n > 1 && t[n - 1][0] === i && t[n - 2][0] === i ? t[n - 1][1] = s : t.push([i, s]);
  }
  _checkClosingPt(t) {
    const i = t.length;
    i > 3 && t[0][0] === this._xCut && t[i - 2][0] === this._xCut && t[1][0] === this._xCut && (t[0][1] = t[i - 2][1], t.pop());
  }
  _side(t) {
    return t < this._xCut ? -1 : t > this._xCut ? 1 : 0;
  }
  _intersect(t, i) {
    const s = (this._xCut - t[0]) / (i[0] - t[0]);
    return t[1] + s * (i[1] - t[1]);
  }
  _pushLineIn() {
    this._lineIn && this._lineIn.length >= this._minPts && this._linesIn.push(this._lineIn), this._lineIn = [];
  }
  _pushLineOut() {
    this._lineOut && this._lineOut.length >= this._minPts && this._linesOut.push(this._lineOut), this._lineOut = [];
  }
}


/***/ }),

/***/ 98731:
/*!*********************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/DirtyMap.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
const t = -1;
class e {
  constructor() {
    this._dirties = [{
      vertexFrom: t,
      vertexCount: t,
      indexFrom: t,
      indexCount: t,
      allDirty: !1
    }, {
      vertexFrom: t,
      vertexCount: t,
      indexFrom: t,
      indexCount: t,
      allDirty: !1
    }, {
      vertexFrom: t,
      vertexCount: t,
      indexFrom: t,
      indexCount: t,
      allDirty: !1
    }, {
      vertexFrom: t,
      vertexCount: t,
      indexFrom: t,
      indexCount: t,
      allDirty: !1
    }, {
      vertexFrom: t,
      vertexCount: t,
      indexFrom: t,
      indexCount: t,
      allDirty: !1
    }];
  }
  hasDirty() {
    return this._dirties.some(e => e.indexCount !== t || e.allDirty);
  }
  markAllClean() {
    for (const e of this._dirties) e.indexFrom = t, e.indexCount = t, e.vertexFrom = t, e.vertexCount = t, e.allDirty = !1;
  }
  markAllDirty() {
    for (const t of this._dirties) t.allDirty = !0;
  }
  forEach(e) {
    for (let r = 0; r < this._dirties.length; ++r) {
      const {
          indexCount: i,
          indexFrom: o,
          vertexCount: n,
          vertexFrom: x,
          allDirty: l
        } = this._dirties[r],
        s = {};
      let d,
        m = !1;
      (l || x !== t && n > 0) && (s.geometry = {
        count: n,
        from: x,
        allDirty: l
      }, m = !0), (l || o !== t && i > 0) && (d = {
        count: i,
        from: o,
        allDirty: l
      }, m = !0), m && e({
        indices: d,
        vertices: s
      }, r);
    }
  }
  markDirtyIndices(e, r, i) {
    const o = this._dirties[e],
      n = r,
      x = i;
    if (!o.allDirty) if (o.indexCount !== t) {
      const t = Math.min(o.indexFrom, n),
        e = Math.max(o.indexFrom + o.indexCount, n + x) - t;
      o.indexFrom = t, o.indexCount = e;
    } else o.indexFrom = n, o.indexCount = x;
  }
  markDirtyVertices(e, r, i, o) {
    const n = this._dirties[e],
      x = i,
      l = o;
    if (!n.allDirty) if (n.vertexCount !== t) {
      const t = Math.min(n.vertexFrom, x),
        e = Math.max(n.vertexFrom + n.vertexCount, x + l) - t;
      n.vertexFrom = t, n.vertexCount = e;
    } else n.vertexFrom = x, n.vertexCount = l;
  }
}


/***/ }),

/***/ 96710:
/*!*******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecordStore.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ d)
/* harmony export */ });
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/has.js */ 67087);
/* harmony import */ var _FreeList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FreeList.js */ 62029);
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils.js */ 52300);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/



const s = ["FILL", "LINE", "MARKER", "TEXT", "LABEL"];
function o(e) {
  const t = e.getStrides(),
    r = {};
  for (let i = 0; i < t.length; i++) r[s[i]] = t[i];
  return r;
}
const n = .5;
class d {
  constructor(r, i, s, o) {
    this._strides = r, this._displayList = i, this._freeListsAndStorage = {}, this._dirtyMap = null, this._dirtyMap = s;
    for (const n in r) {
      this._freeListsAndStorage[n] = {
        vtxFreeList: o ? new _FreeList_js__WEBPACK_IMPORTED_MODULE_1__.FreeList(o) : null,
        idxFreeList: o ? new _FreeList_js__WEBPACK_IMPORTED_MODULE_1__.FreeList(o) : null,
        vertexBuffers: {},
        indexBuffer: o ? new Uint32Array(o) : null
      };
      for (const e in r[n]) this._freeListsAndStorage[n].vertexBuffers[e] = {
        data: o ? (0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.allocateTypedArrayBuffer)(o, r[n][e]) : null,
        stride: r[n][e]
      };
    }
  }
  static fromTileData(t, i) {
    const n = o(t),
      a = [0, 0, 0, 0, 0],
      x = [0, 0, 0, 0, 0];
    for (const e of t.tileDisplayData.displayObjects) for (const t of e.displayRecords) a[t.geometryType] = Math.max(a[t.geometryType], t.vertexFrom + t.vertexCount), x[t.geometryType] = Math.max(x[t.geometryType], t.indexFrom + t.indexCount);
    const u = new d(n, t.tileDisplayData.displayList, i, void 0),
      f = t.tileBufferData?.geometries ?? [];
    for (let o = 0; o < f.length; ++o) {
      const t = a[o],
        i = x[o],
        n = f[o],
        d = s[o],
        c = u._storageFor(d),
        l = f[o].indexBuffer;
      c.indexBuffer = l, c.idxFreeList = new _FreeList_js__WEBPACK_IMPORTED_MODULE_1__.FreeList(l.length), c.idxFreeList.allocate(i);
      let m = 0;
      for (const e in n.vertexBuffer) {
        const t = f[o].vertexBuffer[e];
        c.vertexBuffers[e].data = t.data, c.vertexBuffers[e].stride = t.stride;
        const i = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.strideToPackingFactor)(t.stride),
          s = t.data.length * i / t.stride;
        m || (m = s);
      }
      c.vtxFreeList = new _FreeList_js__WEBPACK_IMPORTED_MODULE_1__.FreeList(m), c.vtxFreeList.allocate(t);
    }
    return u;
  }
  delete(e) {
    const t = s[e.geometryType];
    this._freeVertices(t, e.vertexFrom, e.vertexCount), this._freeIndices(t, e.indexFrom, e.indexCount), this._displayList.removeFromList(e), e.vertexFrom = void 0, e.indexFrom = void 0;
  }
  setMeshData(e, t, r, o, n) {
    const d = s[e.geometryType];
    let a, x;
    e.meshData = null, void 0 === e.vertexFrom ? (x = t.vertexCount, a = this._allocateVertices(d, x)) : t.vertexCount > e.vertexCount ? (this._freeVertices(d, e.vertexFrom, e.vertexCount), x = t.vertexCount, a = this._allocateVertices(d, x)) : t.vertexCount === e.vertexCount ? (a = e.vertexFrom, x = e.vertexCount) : (this._freeVertices(d, e.vertexFrom + t.vertexCount, e.vertexCount - t.vertexCount), a = e.vertexFrom, x = t.vertexCount);
    let u,
      f,
      c,
      l = !0;
    if (void 0 === e.indexFrom ? (u = n, c = t.indexCount, f = this._allocateIndices(d, c)) : t.indexCount > e.indexCount ? (u = this._displayList.removeFromList(e), this._freeIndices(d, e.indexFrom, e.indexCount), c = t.indexCount, f = this._allocateIndices(d, c)) : t.indexCount === e.indexCount ? (l = !1, f = e.indexFrom, c = e.indexCount) : (u = this._displayList.removeFromList(e), this._freeIndices(d, e.indexFrom + t.indexCount, e.indexCount - t.indexCount), f = e.indexFrom, c = t.indexCount), -1 !== a && -1 !== f) {
      const s = this._storageFor(d);
      if ((0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.copyMeshData)(a, f, s.vertexBuffers, s.indexBuffer, t, r, o), e.vertexFrom = a, e.indexFrom = f, e.vertexCount = t.vertexCount, e.indexCount = t.indexCount, this._dirtyMap) {
        this._dirtyMap.markDirtyIndices(e.geometryType, e.indexFrom, e.indexCount);
        for (const t in r) this._dirtyMap.markDirtyVertices(e.geometryType, t, e.vertexFrom, e.vertexCount);
      }
      return l && this._displayList.addToList(e, u), !0;
    }
    return -1 !== a && this._freeVertices(d, a, x), -1 !== f && this._freeIndices(d, f, c), e.setMeshDataFromBuffers(t, r, o), e.vertexFrom = void 0, e.vertexCount = 0, e.indexFrom = void 0, e.indexCount = 0, !1;
  }
  tryAddMeshData(e, t) {
    const r = t.vertexBuffer,
      o = t.indexBuffer,
      n = s[e.geometryType],
      d = this._allocateVertices(n, e.vertexCount);
    if (-1 === d) return this._freeVertices(n, d, e.vertexCount), !1;
    const a = this._allocateIndices(n, e.indexCount);
    if (-1 === a) return this._freeVertices(n, d, e.vertexCount), this._freeIndices(n, a, e.indexCount), !1;
    const x = this._storageFor(n);
    if ((0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.copyMeshData)(d, a, x.vertexBuffers, x.indexBuffer, e, r, o), e.vertexFrom = d, e.indexFrom = a, this._dirtyMap) {
      this._dirtyMap.markDirtyIndices(e.geometryType, e.indexFrom, e.indexCount);
      for (const t in r) this._dirtyMap.markDirtyVertices(e.geometryType, t, d, e.vertexCount);
    }
    return this._displayList.addToList(e), !0;
  }
  _allocateVertices(e, t) {
    const r = this._storageFor(e),
      i = r.vtxFreeList?.allocate(t);
    if (null == i || -1 === i) return -1;
    const s = r.vtxFreeList?.fragmentation;
    return null == s || s > n ? -1 : i;
  }
  _freeVertices(e, t, r) {
    const i = this._storageFor(e);
    i.vtxFreeList?.free(t, r);
  }
  _freeIndices(e, t, r) {
    const i = this._storageFor(e);
    i.idxFreeList?.free(t, r);
  }
  _allocateIndices(e, t) {
    const r = this._storageFor(e),
      i = r.idxFreeList?.allocate(t);
    if (null == i || -1 === i) return -1;
    const s = r.idxFreeList?.fragmentation;
    return null == s || s > n ? -1 : i;
  }
  _storageFor(e) {
    return this._freeListsAndStorage[e];
  }
  _stridesFor(e, t) {
    return this._strides[e][t];
  }
}


/***/ }),

/***/ 62029:
/*!*********************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/FreeList.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FreeList": () => (/* binding */ t)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
class e {
  get largestRange() {
    return this._largestRange;
  }
  constructor(e) {
    this._largestRange = null, this._parent = e, this._updateLargestRange();
  }
  rangeCreated(e) {
    (!this._largestRange || e.count > this._largestRange.count) && (this._largestRange = e);
  }
  rangeResized(e, t) {
    e === this._largestRange ? e.count < t && this._updateLargestRange() : (!this._largestRange || e.count > this._largestRange.count) && (this._largestRange = e);
  }
  findBestRange(e) {
    let t = this._parent._freeHead,
      n = null;
    for (; null !== t;) t.count >= e && (!n || t.count - e < n.count - e) && (n = t), t = t.next;
    return n;
  }
  findAdjacentRanges(e, t) {
    let n = !0,
      r = !1,
      s = null,
      o = this._parent._freeHead;
    for (; n && !r;) {
      const a = null !== s ? s.from + s.count : 0,
        l = null !== o ? o.from : this._parent._size;
      e >= a && e + t <= l ? (n = !1, r = !0) : null !== o ? (s = o, o = o.next) : n = !1;
    }
    return [s, o];
  }
  _updateLargestRange() {
    let e = null,
      t = this._parent._freeHead;
    for (; null !== t;) (!e || t.count > e.count) && (e = t), t = t.next;
    this._largestRange = e;
  }
}
class t {
  constructor(t, n) {
    this._allocated = 0, this._size = t, this._freeHead = t > 0 ? {
      from: 0,
      count: t,
      prev: null,
      next: null
    } : null, this._bookKeeper = n || new e(this), this._freeHead && this._bookKeeper.rangeCreated(this._freeHead);
  }
  allocate(e) {
    const n = this._bookKeeper.findBestRange(e);
    if (null == n) return -1;
    const r = n.from,
      s = n.count;
    if (n.from += e, n.count -= e, this._bookKeeper.rangeResized(n, r, s), this._allocated += e, 0 === n.count) {
      const e = null !== n.prev ? this._freeHead : n.next;
      t._removeRange(n), this._freeHead = e;
    }
    return r;
  }
  free(e, n) {
    const [r, s] = this._bookKeeper.findAdjacentRanges(e, n),
      o = {
        from: e,
        count: n,
        prev: r ?? null,
        next: s ?? null
      };
    if (null != r && (r.next = o), null != s && (s.prev = o), this._bookKeeper.rangeCreated(o), this._allocated -= n, null != s && o.from + o.count === s.from) {
      const e = o.from,
        n = o.count;
      t._fuse(o, s), t._removeRange(s), this._bookKeeper.rangeResized(o, e, n), this._bookKeeper.rangeResized(s, void 0, 0);
    }
    if (null != r && r.from + r.count === o.from) {
      const e = r.from,
        n = r.count;
      t._fuse(r, o), t._removeRange(o), this._bookKeeper.rangeResized(r, e, n), this._bookKeeper.rangeResized(o, void 0, 0);
    }
    this._freeHead = null !== o.prev ? this._freeHead : o;
  }
  get fragmentation() {
    const e = this._size - this._allocated;
    if (0 === e) return 0;
    return 1 - this._bookKeeper.largestRange.count / e;
  }
  static _removeRange(e) {
    null !== e.prev ? null !== e.next ? (e.prev.next = e.next, e.next.prev = e.prev) : e.prev.next = null : null !== e.next && (e.next.prev = null);
  }
  static _fuse(e, t) {
    e.count += t.count, e.next = t.next, t.from += t.count, t.count = 0, null !== t.next && (t.next.prev = e);
  }
}


/***/ }),

/***/ 39461:
/*!*******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/GraphicDisplayList.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ n)
/* harmony export */ });
/* harmony import */ var _materialKey_MaterialKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./materialKey/MaterialKey.js */ 21605);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/

function t(e, t, n, ...o) {
  t < e.length ? e.splice(t, n, ...o) : e.push(...o);
}
class n {
  constructor() {
    this.symbolLevels = [];
  }
  replay(t, n, o) {
    for (const i of this.symbolLevels) for (const r of i.zLevels) {
      const i = r.geometryDPInfo.unified;
      if (i) for (const r of i) {
        const {
            geometryType: i,
            materialKey: l,
            indexFrom: s,
            indexCount: m
          } = r,
          y = _materialKey_MaterialKey_js__WEBPACK_IMPORTED_MODULE_0__.MaterialKeyBase.load(l).symbologyType,
          d = t.painter.getBrush(i, y),
          u = {
            geometryType: i,
            materialKey: l,
            indexFrom: s,
            indexCount: m,
            target: n.getGeometry(i)
          };
        d.prepareState(t), d.drawGeometry(t, n, u, o);
      }
    }
  }
  get empty() {
    return !this.symbolLevels || 0 === this.symbolLevels.length;
  }
  clear() {
    this.symbolLevels.length = 0;
  }
  addToList(e, t) {
    if (Array.isArray(e)) for (const n of e) this._addToList(n, t);else this._addToList(e, t);
  }
  removeFromList(e) {
    Array.isArray(e) || (e = [e]);
    let t = null;
    for (const n of e) t = this._removeFromList(n);
    return t;
  }
  clone() {
    const e = new n();
    for (const t of this.symbolLevels) e.symbolLevels.push(t.clone());
    return e;
  }
  splitAfter(e) {
    const t = this._getDisplayList(e.symbolLevel, e.zOrder),
      n = t.length,
      i = e.indexFrom + e.indexCount;
    for (let r = 0; r < n; ++r) {
      const n = t[r];
      if (n.geometryType === e.geometryType && i > n.indexFrom && i <= n.indexFrom + n.indexCount) {
        if (i < n.indexFrom + n.indexCount) {
          const e = new o();
          e.geometryType = n.geometryType, e.materialKey = n.materialKey, e.indexFrom = i, e.indexCount = n.indexFrom + n.indexCount - i, t.splice(r + 1, 0, e), n.indexCount = i - n.indexFrom;
        }
        return r;
      }
    }
  }
  _addToList(e, n) {
    const i = e.symbolLevel,
      r = e.zOrder,
      l = this._getDisplayList(i, r),
      s = null != n ? n : l.length - 1,
      m = s >= 0 && s < l.length ? l[s] : null;
    if (null !== m && m.materialKey === e.materialKey && m.indexFrom + m.indexCount === e.indexFrom && m.geometryType === e.geometryType) m.indexCount += e.indexCount;else {
      const n = new o();
      n.indexFrom = e.indexFrom, n.indexCount = e.indexCount, n.materialKey = e.materialKey, n.geometryType = e.geometryType, t(l, s + 1, 0, n);
    }
  }
  _removeFromList(e) {
    const n = e.symbolLevel,
      i = e.zOrder,
      r = this._getDisplayList(n, i),
      l = r.length;
    let s;
    for (let t = 0; t < l; ++t) {
      const n = r[t];
      if (e.indexFrom + e.indexCount > n.indexFrom && e.indexFrom < n.indexFrom + n.indexCount && n.geometryType === e.geometryType) {
        s = t;
        break;
      }
    }
    if (void 0 !== s) {
      const n = r[s];
      if (e.indexFrom === n.indexFrom) return n.indexCount -= e.indexCount, n.indexFrom += e.indexCount, 0 === n.indexCount && t(r, s, 1), s - 1;
      if (e.indexFrom + e.indexCount === n.indexFrom + n.indexCount) return n.indexCount -= e.indexCount, 0 === n.indexCount ? (t(r, s, 1), s - 1) : s;
      {
        const i = n.indexFrom,
          l = e.indexFrom - n.indexFrom,
          m = e.indexCount,
          y = n.indexFrom + n.indexCount - (e.indexFrom + e.indexCount);
        n.indexCount = l;
        const d = new o();
        return d.geometryType = n.geometryType, d.materialKey = n.materialKey, d.indexFrom = i + l + m, d.indexCount = y, t(r, s + 1, 0, d), s;
      }
    }
    return null;
  }
  _getDisplayList(e, t) {
    let n;
    const o = this.symbolLevels.length;
    for (let i = 0; i < o; i++) if (this.symbolLevels[i].symbolLevel === e) {
      n = this.symbolLevels[i];
      break;
    }
    let s;
    n || (n = new l(), n.symbolLevel = e, this.symbolLevels.push(n));
    const m = n.zLevels.length;
    for (let i = 0; i < m; i++) if (n.zLevels[i].zLevel === t) {
      s = n.zLevels[i];
      break;
    }
    return s || (s = new r(), s.geometryDPInfo = new i(), s.zLevel = t, n.zLevels.push(s)), s.geometryDPInfo.unified || (s.geometryDPInfo.unified = []), s.geometryDPInfo.unified;
  }
  getDPInfoType() {
    return "unified";
  }
}
class o {
  constructor() {
    this.materialKey = null, this.indexFrom = 0, this.indexCount = 0;
  }
  clone() {
    const e = new o();
    return e.geometryType = this.geometryType, e.materialKey = this.materialKey, e.indexFrom = this.indexFrom, e.indexCount = this.indexCount, e;
  }
}
class i {
  constructor() {
    this.fill = null, this.line = null, this.marker = null, this.text = null, this.label = null, this.unified = null;
  }
  clone() {
    const e = new i();
    return e.fill = this.fill && this.fill.map(e => e.clone()), e.line = this.line && this.line.map(e => e.clone()), e.marker = this.marker && this.marker.map(e => e.clone()), e.text = this.text && this.text.map(e => e.clone()), e.label = this.label && this.label.map(e => e.clone()), e.unified = this.unified && this.unified.map(e => e.clone()), e;
  }
}
class r {
  constructor() {
    this.geometryDPInfo = new i();
  }
  clone() {
    const e = new r();
    return e.zLevel = this.zLevel, e.geometryDPInfo = this.geometryDPInfo.clone(), e;
  }
}
class l {
  constructor() {
    this.zLevels = [];
  }
  clone() {
    const e = new l();
    e.symbolLevel = this.symbolLevel;
    for (const t of this.zLevels) e.zLevels.push(t.clone());
    return e;
  }
}


/***/ }),

/***/ 19761:
/*!************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/GraphicTile.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphicTile": () => (/* binding */ a)
/* harmony export */ });
/* harmony import */ var _DirtyMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DirtyMap.js */ 98731);
/* harmony import */ var _DisplayRecordStore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DisplayRecordStore.js */ 96710);
/* harmony import */ var _WGLBuffers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WGLBuffers.js */ 65537);
/* harmony import */ var _WGLTile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WGLTile.js */ 6833);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/




class a extends _WGLTile_js__WEBPACK_IMPORTED_MODULE_3__.WGLTile {
  constructor() {
    super(...arguments), this._data = null, this._displayList = null, this._lastCommitTime = 0, this._hasData = !1, this._invalidated = !1, this._wglBuffers = null, this._dirtyMap = new _DirtyMap_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
  }
  destroy() {
    super.destroy(), this.clear();
  }
  get hasData() {
    return !!this._hasData;
  }
  get displayObjects() {
    return this._displayObjects ?? [];
  }
  getGeometry(t) {
    return this._wglBuffers && this._wglBuffers.has(t) ? this._wglBuffers.get(t) : null;
  }
  getDisplayList() {
    return this._displayList;
  }
  patch(e) {
    if (!0 === e.clear) return this.clear(), void (this._hasData = !1);
    const i = e.addOrUpdate,
      a = e.remove;
    !this._data && i?.tileDisplayData?.displayObjects.length ? (i.tileDisplayData.computeDisplayList(), this._dirtyMap = new _DirtyMap_js__WEBPACK_IMPORTED_MODULE_0__["default"](), this._dispRecStore = _DisplayRecordStore_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromTileData(i, this._dirtyMap), this._data = i, this._dirtyMap.markAllDirty(), this._hasData = !0, e.end && this.ready()) : this._data && (i?.tileDisplayData?.displayObjects.length || a.length) ? this._doPatchData(e) : e.end && this.ready(), e.end && !this._data && this.clear(), this.requestRender(), this.emit("change");
  }
  commit(t) {
    t.time && t.time === this._lastCommitTime || (this._lastCommitTime = t.time, this.visible && this._data && (this._wglBuffers || (this._wglBuffers = new _WGLBuffers_js__WEBPACK_IMPORTED_MODULE_2__["default"](t.context)), (this._dirtyMap.hasDirty() || this._invalidated) && (this._invalidated = !1, this._wglBuffers.upload(this._data.tileBufferData, this._dirtyMap), this._displayList = this._data.tileDisplayData.displayList.clone(), this._displayObjects = this._data.tileDisplayData.displayObjects.slice(), this._dirtyMap.markAllClean())));
  }
  clear() {
    this._data = null, this._displayList = null, this._dispRecStore = null, this._wglBuffers && (this._wglBuffers.dispose(), this._wglBuffers = null);
  }
  _doPatchData(t) {
    this._invalidated = !0, this._patchData(t) || (this._dirtyMap.markAllDirty(), this._data.reshuffle(), this._dispRecStore = _DisplayRecordStore_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromTileData(this._data, this._dirtyMap)), this.requestRender();
  }
  _patchData(t) {
    let s = !0;
    const e = t.addOrUpdate?.tileDisplayData?.displayObjects || [],
      i = (t.remove || []).slice();
    for (const r of e) null != r.insertAfter && i.push(r.id);
    let a;
    i.length > 0 && (a = new Set(i));
    const l = this._data.tileDisplayData;
    for (const r of i) {
      const t = l.displayObjectRegistry.get(r);
      if (t) {
        l.displayList.removeFromList(t.displayRecords);
        for (const s of t.displayRecords) this._dispRecStore.delete(s);
        l.displayObjectRegistry.delete(r);
      }
    }
    a?.size && (l.displayObjects = l.displayObjects.filter(t => !a.has(t.id)));
    for (const r of e) {
      let e,
        i = l.displayObjectRegistry.get(r.id);
      if (i) {
        const t = i.displayRecords;
        i.set(r), i.displayRecords = t;
        const s = i.displayRecords.length;
        for (let e = 0; e < s; ++e) {
          const t = i.displayRecords[e],
            s = r.displayRecords[e];
          (e >= r.displayRecords.length || t.geometryType !== s.geometryType || t.symbolLevel !== s.symbolLevel || t.zOrder !== s.zOrder || t.materialKey !== s.materialKey) && (this._dispRecStore.delete(i.displayRecords[e]), e < r.displayRecords.length && (i.displayRecords[e] = void 0));
        }
        i.displayRecords.length = r.displayRecords.length;
      } else {
        let t;
        i = r.copy(), i.displayRecords = [], l.displayObjectRegistry.set(r.id, i);
        const s = l.displayObjects;
        if (null != i.insertAfter) {
          if (e = {}, i.insertAfter >= 0) {
            const e = l.displayObjectRegistry.get(i.insertAfter);
            e ? (t = s.indexOf(e) + 1, t < s.length ? s.splice(t, 0, i) : (s.push(i), t = s.length)) : (s.push(i), t = s.length);
          } else s.unshift(i), t = 0;
        } else s.push(i), t = s.length;
        if (e) {
          const i = r.displayRecords.length > 0 ? 1 : 0;
          let a = 0;
          for (let r = t - 1; r >= 0 && a < i; --r) for (let t = s[r].displayRecords.length - 1; t >= 0 && a < i; --t) {
            const i = s[r].displayRecords[t],
              d = l.displayList.getDPInfoType();
            e[d] || (e[d] = i, ++a);
          }
        }
      }
      const a = r.displayRecords.length;
      for (let d = 0; d < a; ++d) {
        const a = r.displayRecords[d];
        let o = i.displayRecords[d];
        o ? (o.meshData = a.meshData, o.materialKey = a.materialKey) : (o = a.copy(), o.vertexFrom = void 0, o.indexFrom = void 0, i.displayRecords[d] = o);
        const h = a.geometryType,
          p = l.displayList.getDPInfoType(),
          y = t.addOrUpdate.tileBufferData.geometries[h],
          c = y.vertexBuffer,
          n = y.indexBuffer;
        let f;
        e && (f = e[p] ? l.displayList.splitAfter(e[p]) : -1), s = this._dispRecStore.setMeshData(o, a, c, n, f) && s, e && null != o.indexFrom && null != o.indexFrom && (e[p] = o);
      }
    }
    return s;
  }
}


/***/ }),

/***/ 35008:
/*!*******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/MemoryRequirements.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
class e {
  constructor() {
    this._byGeometryType = null;
  }
  get satisfied() {
    return !this._byGeometryType;
  }
  reset() {
    this._byGeometryType = null;
  }
  verticesFor(e) {
    return this._byGeometryType ? this._byGeometryType[e].vertices : 0;
  }
  indicesFor(e) {
    return this._byGeometryType ? this._byGeometryType[e].indices : 0;
  }
  needMore(e, t, i) {
    if (!t && !i) return;
    this._byGeometryType || (this._byGeometryType = [{
      vertices: 0,
      indices: 0
    }, {
      vertices: 0,
      indices: 0
    }, {
      vertices: 0,
      indices: 0
    }, {
      vertices: 0,
      indices: 0
    }, {
      vertices: 0,
      indices: 0
    }]);
    const s = this._byGeometryType[e];
    s.vertices += t, s.indices += i;
  }
}


/***/ }),

/***/ 23709:
/*!*********************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/MeshData.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ t)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
class t {
  constructor() {
    this.vertexData = new Map(), this.vertexCount = 0, this.indexData = [];
  }
  clear() {
    this.vertexData.clear(), this.vertexCount = 0, this.indexData = [];
  }
  update(t, e, a) {
    for (const s in t) this.vertexData.set(s, t[s]);
    for (const s in this.vertexData) null === t[s] && this.vertexData.delete(s);
    this.vertexCount = e, this.indexData = a;
  }
}


/***/ }),

/***/ 63647:
/*!***************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/TileBufferData.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ f)
/* harmony export */ });
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.js */ 52300);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/

const r = 5;
class f {
  constructor() {
    this.geometries = [{
      indexBuffer: void 0,
      vertexBuffer: {}
    }, {
      indexBuffer: void 0,
      vertexBuffer: {}
    }, {
      indexBuffer: void 0,
      vertexBuffer: {}
    }, {
      indexBuffer: void 0,
      vertexBuffer: {}
    }, {
      indexBuffer: void 0,
      vertexBuffer: {}
    }];
  }
  clone() {
    const e = new f();
    for (let r = 0; r < this.geometries.length; r++) {
      const f = this.geometries[r],
        t = e.geometries[r];
      t.indexBuffer = f.indexBuffer.slice(), t.vertexBuffer = {};
      for (const e in f.vertexBuffer) {
        const {
          data: r,
          stride: i
        } = f.vertexBuffer[e];
        t.vertexBuffer[e] = {
          data: r.slice(),
          stride: i
        };
      }
    }
    return e;
  }
  static deserialize(t) {
    const i = new f();
    for (let f = 0; f < r; ++f) {
      i.geometries[f].indexBuffer = new Uint32Array(t.geometries[f].indexBuffer), i.geometries[f].vertexBuffer = {};
      for (const r in t.geometries[f].vertexBuffer) i.geometries[f].vertexBuffer[r] = {
        data: (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.allocateTypedArrayBufferwithData)(t.geometries[f].vertexBuffer[r].data, t.geometries[f].vertexBuffer[r].stride),
        stride: t.geometries[f].vertexBuffer[r].stride
      };
    }
    return i;
  }
  serialize() {
    const e = {
      geometries: [{
        indexBuffer: this.geometries[0].indexBuffer.buffer,
        vertexBuffer: {}
      }, {
        indexBuffer: this.geometries[1].indexBuffer.buffer,
        vertexBuffer: {}
      }, {
        indexBuffer: this.geometries[2].indexBuffer.buffer,
        vertexBuffer: {}
      }, {
        indexBuffer: this.geometries[3].indexBuffer.buffer,
        vertexBuffer: {}
      }, {
        indexBuffer: this.geometries[4].indexBuffer.buffer,
        vertexBuffer: {}
      }]
    };
    for (let f = 0; f < r; ++f) for (const r in this.geometries[f].vertexBuffer) e.geometries[f].vertexBuffer[r] = {
      data: this.geometries[f].vertexBuffer[r].data.buffer,
      stride: this.geometries[f].vertexBuffer[r].stride
    };
    return e;
  }
  getBuffers() {
    const e = [];
    for (let f = 0; f < r; ++f) {
      e.push(this.geometries[f].indexBuffer.buffer);
      for (const r in this.geometries[f].vertexBuffer) e.push(this.geometries[f].vertexBuffer[r].data.buffer);
    }
    return e;
  }
}


/***/ }),

/***/ 46555:
/*!*********************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/TileData.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TileData": () => (/* binding */ B)
/* harmony export */ });
/* harmony import */ var _core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/arrayUtils.js */ 19420);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums.js */ 20753);
/* harmony import */ var _MemoryRequirements_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MemoryRequirements.js */ 35008);
/* harmony import */ var _TileBufferData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TileBufferData.js */ 63647);
/* harmony import */ var _TileDisplayData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileDisplayData.js */ 60013);
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils.js */ 52300);
/* harmony import */ var _WGLDisplayRecord_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WGLDisplayRecord.js */ 50757);
/* harmony import */ var _cpuMapped_DisplayRecordReader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cpuMapped/DisplayRecordReader.js */ 46461);
/* harmony import */ var _mesh_VertexBuffer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mesh/VertexBuffer.js */ 79950);
/* harmony import */ var _mesh_VertexVector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mesh/VertexVector.js */ 68336);
/* harmony import */ var _util_Writer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./util/Writer.js */ 68741);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/











const d = new _MemoryRequirements_js__WEBPACK_IMPORTED_MODULE_2__["default"](),
  p = new _MemoryRequirements_js__WEBPACK_IMPORTED_MODULE_2__["default"](),
  D = 5;
function h(e, t) {
  const r = {};
  for (const s in e) {
    const i = {
      data: (0,_Utils_js__WEBPACK_IMPORTED_MODULE_5__.allocateTypedArrayBuffer)(t, e[s]),
      stride: e[s]
    };
    r[s] = i;
  }
  return r;
}
function x(e) {
  return [e.fill || {}, e.line || {}, e.icon || {}, e.text || {}, e.label || {}];
}
function y(e) {
  const t = [[], [], [], [], []],
    r = e;
  for (const s of r) for (const e of s.displayRecords) t[e.geometryType].push(e);
  return t;
}
class B {
  constructor() {
    this.tileDisplayData = null, this.tileBufferData = null;
  }
  reshuffle() {
    if (d.reset(), !this.tileDisplayData) return;
    const t = y(this.tileDisplayData.displayObjects);
    for (const e of t) for (const t of e) t && d.needMore(t.geometryType, t.meshData ? t.meshData.vertexCount : t.vertexCount, t.meshData ? t.meshData.indexData.length : t.indexCount);
    const r = t.length,
      i = new _TileBufferData_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    for (let s = 0; s < r; ++s) {
      i.geometries[s].indexBuffer = new Uint32Array(Math.round(_core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_0__.ReallocGrowthFactor * d.indicesFor(s)));
      const t = [],
        r = this.tileBufferData?.geometries[s].vertexBuffer;
      if (!r) continue;
      for (const e in r) t.push(r[e].stride);
      const a = B._computeVertexAlignment(t),
        n = Math.round(_core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_0__.ReallocGrowthFactor * d.verticesFor(s)),
        f = B._align(n, a);
      for (const e in r) {
        const t = r[e].stride;
        i.geometries[s].vertexBuffer[e] = {
          stride: t,
          data: (0,_Utils_js__WEBPACK_IMPORTED_MODULE_5__.allocateTypedArrayBuffer)(f, t)
        };
      }
    }
    p.reset(), this.tileDisplayData.displayList?.clear();
    for (let e = 0; e < r; ++e) {
      const r = t[e];
      for (const t of r) {
        if (t.meshData) t.writeMeshDataToBuffers(p.verticesFor(e), i.geometries[e].vertexBuffer, p.indicesFor(e), i.geometries[e].indexBuffer), t.meshData = null;else {
          const r = this.tileBufferData?.geometries[e];
          if (r) {
            const s = r.vertexBuffer,
              o = r.indexBuffer,
              n = i.geometries[e].vertexBuffer,
              f = i.geometries[e].indexBuffer,
              l = p.verticesFor(e),
              u = p.indicesFor(e);
            (0,_Utils_js__WEBPACK_IMPORTED_MODULE_5__.copyMeshData)(l, u, n, f, t, s, o), t.vertexFrom = l, t.indexFrom = u;
          }
        }
        p.needMore(e, t.vertexCount, t.indexCount);
      }
    }
    const {
      displayList: n,
      displayObjects: f
    } = this.tileDisplayData;
    if (n) for (const e of f) n.addToList(e.displayRecords);
    this.tileBufferData = i;
  }
  getStrides() {
    const e = [],
      t = this.tileBufferData?.geometries;
    if (!t) return e;
    for (let r = 0; r < t.length; ++r) {
      const s = t[r];
      e[r] = {};
      for (const t in s.vertexBuffer) e[r][t] = s.vertexBuffer[t].stride;
    }
    return e;
  }
  clone() {
    const e = new B();
    return e.tileBufferData = this.tileBufferData?.clone() ?? null, e.tileDisplayData = this.tileDisplayData?.clone() ?? null, e;
  }
  _guessSize() {
    const e = this.tileDisplayData?.displayObjects ?? [],
      t = Math.min(e.length, 4),
      r = 12,
      s = 40;
    let i = 0;
    for (let o = 0; o < t; o++) i = Math.max(i, e[o].displayRecords.length);
    return 2 * (e.length * r + e.length * i * s);
  }
  serialize() {
    const e = this.tileBufferData.serialize(),
      t = this.tileBufferData.getBuffers(),
      r = this.tileDisplayData.serialize(new _util_Writer_js__WEBPACK_IMPORTED_MODULE_10__["default"](Int32Array, this._guessSize())).buffer();
    return t.push(r), {
      result: {
        displayData: r,
        bufferData: e
      },
      transferList: t
    };
  }
  static fromVertexData(e, r) {
    const s = {},
      i = new Map();
    for (const t of r) i.set(t.id, t);
    return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_5__.forEachGeometryType)(r => {
      const o = e.data[r];
      if (null != o) {
        const e = _cpuMapped_DisplayRecordReader_js__WEBPACK_IMPORTED_MODULE_7__.DisplayRecordReader.from(o.records).getCursor();
        for (; e.next();) {
          const t = e.id,
            s = e.materialKey,
            o = e.indexFrom,
            a = e.indexCount,
            n = e.vertexFrom,
            l = e.vertexCount,
            u = i.get(t),
            c = new _WGLDisplayRecord_js__WEBPACK_IMPORTED_MODULE_6__["default"](t, r, s);
          c.indexFrom = o, c.indexCount = a, c.vertexFrom = n, c.vertexCount = l, u.displayRecords.push(c);
        }
        s[r] = _mesh_VertexBuffer_js__WEBPACK_IMPORTED_MODULE_8__.VertexBuffers.fromVertexData(o, r);
      } else s[r] = new _mesh_VertexVector_js__WEBPACK_IMPORTED_MODULE_9__.VertexVectors(r, 0, _enums_js__WEBPACK_IMPORTED_MODULE_1__.WGLSymbologyType.DEFAULT).intoBuffers();
    }), B.fromMeshData({
      displayObjects: r,
      vertexBuffersMap: s
    });
  }
  static fromMeshData(e) {
    const t = new B(),
      r = new _TileDisplayData_js__WEBPACK_IMPORTED_MODULE_4__["default"](),
      o = new _TileBufferData_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    r.displayObjects = e.displayObjects;
    for (const s in e.vertexBuffersMap) {
      const t = s,
        r = e.vertexBuffersMap[t];
      o.geometries[t].indexBuffer = r.indexBuffer, o.geometries[t].vertexBuffer = r.namedBuffers;
    }
    return t.tileDisplayData = r, t.tileBufferData = o, t;
  }
  static bind(e, t) {
    const r = new B();
    return r.tileDisplayData = e, r.tileBufferData = t, r;
  }
  static create(e, t) {
    const r = new B();
    r.tileDisplayData = new _TileDisplayData_js__WEBPACK_IMPORTED_MODULE_4__["default"](), r.tileDisplayData.displayObjects = e;
    const o = [0, 0, 0, 0, 0],
      a = [0, 0, 0, 0, 0],
      n = [[], [], [], [], []];
    for (const s of e) for (const e of s.displayRecords) n[e.geometryType].push(e), o[e.geometryType] += e.meshData.vertexCount, a[e.geometryType] += e.meshData.indexData.length;
    const l = new _TileBufferData_js__WEBPACK_IMPORTED_MODULE_3__["default"](),
      u = x(t);
    for (let s = 0; s < D; s++) {
      const e = new Uint32Array(a[s]),
        t = h(u[s], o[s]);
      _WGLDisplayRecord_js__WEBPACK_IMPORTED_MODULE_6__["default"].writeAllMeshDataToBuffers(n[s], t, e), l.geometries[s] = {
        indexBuffer: e,
        vertexBuffer: t
      };
    }
    return r.tileBufferData = l, r;
  }
  static _align(e, t) {
    const r = e % t;
    return 0 === r ? e : e + (t - r);
  }
  static _computeVertexAlignment(e) {
    let t = !1,
      r = !1;
    for (const s of e) s % 4 == 2 ? t = !0 : s % 4 != 0 && (r = !0);
    return r ? 4 : t ? 2 : 1;
  }
}


/***/ }),

/***/ 60013:
/*!****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/TileDisplayData.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/* harmony import */ var _GraphicDisplayList_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GraphicDisplayList.js */ 39461);
/* harmony import */ var _WGLDisplayObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WGLDisplayObject.js */ 64648);
/* harmony import */ var _util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/serializationUtils.js */ 92568);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/



class e {
  constructor() {
    this.displayObjects = [], this._displayList = null;
  }
  get displayObjectRegistry() {
    if (!this._displayObjectRegistry) {
      this._displayObjectRegistry = new Map();
      for (const s of this.displayObjects) this._displayObjectRegistry.set(s.id, s);
    }
    return this._displayObjectRegistry;
  }
  get displayList() {
    return this._displayList;
  }
  computeDisplayList() {
    this._displayList = new _GraphicDisplayList_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    for (const s of this.displayObjects) for (const t of s.displayRecords) this._displayList.addToList(t);
  }
  clone() {
    const s = new e();
    return this.displayObjects && (s.displayObjects = this.displayObjects.map(s => s.clone())), s;
  }
  serialize(s) {
    return (0,_util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_2__.serializeList)(s, this.displayObjects), s;
  }
  _deserializeObjects(s) {
    const i = s.readInt32(),
      e = new Array(i),
      a = new Map();
    for (let l = 0; l < e.length; ++l) {
      const i = _WGLDisplayObject_js__WEBPACK_IMPORTED_MODULE_1__["default"].deserialize(s);
      e[l] = i, a.set(i.id, i);
    }
    this.displayObjects = e, this._displayList = null, this._displayObjectRegistry = a;
  }
  static deserialize(s) {
    const t = new e();
    return t._deserializeObjects(s), t;
  }
}


/***/ }),

/***/ 65537:
/*!***********************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/WGLBuffers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ o)
/* harmony export */ });
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.js */ 52300);
/* harmony import */ var _webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/BufferObject.js */ 10615);
/* harmony import */ var _webgl_enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/enums.js */ 69923);
/* harmony import */ var _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/VertexArrayObject.js */ 19955);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/




class o {
  constructor(a) {
    this.geometryMap = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.createGeometryData)(() => ({
      indexBuffer: _webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_1__.BufferObject.createIndex(a, _webgl_enums_js__WEBPACK_IMPORTED_MODULE_2__.Usage.STATIC_DRAW),
      vao: null
    }), (e, s) => ({
      vertexBuffer: _webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_1__.BufferObject.createVertex(a, _Utils_js__WEBPACK_IMPORTED_MODULE_0__.cVboInfo[s])
    }));
  }
  dispose() {
    for (let e = 0; e < 5; e++) {
      const t = this.geometryMap[e];
      if (t) {
        t.data.vao?.disposeVAOOnly(), t.data.indexBuffer?.dispose();
        for (const e in t.buffers) t.buffers[e]?.data.vertexBuffer.dispose();
      }
    }
  }
  get(e) {
    const t = this.geometryMap[e];
    return {
      getVAO(e, r, s) {
        if (!t.data.vao) {
          const o = {};
          for (const e in t.buffers) o[e] = t.buffers[e].data.vertexBuffer;
          t.data.vao = new _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_3__.VertexArrayObject(e, s, r, o, t.data.indexBuffer);
        }
        return t.data.vao;
      }
    };
  }
  has(e) {
    return null != this.geometryMap[e];
  }
  upload(e, t) {
    t.forEach((t, r) => {
      this._upload(t, r, e);
    });
  }
  _upload(e, t, r) {
    if (e.indices && (e.indices.allDirty ? this._uploadIndices(r, t) : null != e.indices.from && null != e.indices.count && this._uploadIndices(r, t, e.indices.from, e.indices.count)), e.vertices) {
      const s = e.vertices;
      for (const e in s) {
        const a = s[e];
        a.allDirty ? this._uploadVertices(r, t, e) : null != a.from && null != a.count && this._uploadVertices(r, t, e, a.from, a.count);
      }
    }
  }
  _uploadVertices(e, t, r, s, a) {
    const o = this.geometryMap[t];
    if (!o) return;
    const f = e.geometries[t].vertexBuffer[r];
    if (!f) return;
    const {
      data: i,
      stride: n
    } = f;
    if (o.buffers[r] && i.length > 0) {
      const e = n / i.BYTES_PER_ELEMENT;
      null != s && null != a ? o.buffers[r].data.vertexBuffer.setSubData(i, s * e, s * e, (s + a) * e) : o.buffers[r].data.vertexBuffer.setData(i);
    }
  }
  _uploadIndices(e, t, r, s) {
    const a = this.geometryMap[t];
    if (!a) return;
    const o = e.geometries[t].indexBuffer;
    a.data.indexBuffer && o.length > 0 && (null != r && null != s ? a.data.indexBuffer.setSubData(o, r, r, r + s) : a.data.indexBuffer.setData(o));
  }
}


/***/ }),

/***/ 64648:
/*!*****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayObject.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/* harmony import */ var _WGLDisplayRecord_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WGLDisplayRecord.js */ 50757);
/* harmony import */ var _util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/serializationUtils.js */ 92568);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/


class e {
  constructor(s) {
    this.insertAfter = null, this.id = s, this.displayRecords = [];
  }
  copy() {
    const s = new e(this.id);
    return s.set(this), s;
  }
  clone() {
    const s = new e(this.id);
    return s.displayRecords = this.displayRecords.map(s => s.clone()), s.insertAfter = this.insertAfter, s;
  }
  set(s) {
    this.id = s.id, this.displayRecords = s.displayRecords, this.insertAfter = s.insertAfter;
  }
  serialize(s) {
    return s.push(this.id), (0,_util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_1__.serializeList)(s, this.displayRecords), s;
  }
  static deserialize(i) {
    const r = i.readInt32(),
      d = new e(r),
      o = {
        id: r
      };
    return d.displayRecords = (0,_util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_1__.deserializeList)(i, _WGLDisplayRecord_js__WEBPACK_IMPORTED_MODULE_0__["default"], o) ?? [], d;
  }
}


/***/ }),

/***/ 50757:
/*!*****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayRecord.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ s)
/* harmony export */ });
/* harmony import */ var _MeshData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MeshData.js */ 23709);
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.js */ 52300);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/


class s {
  constructor(t, e, s, i = 0, r = 0) {
    this.id = t, this.geometryType = e, this.materialKey = s, this.minZoom = i, this.maxZoom = r, this.meshData = null, this.symbolLevel = 0, this.zOrder = 0, this.vertexFrom = 0, this.vertexCount = 0, this.indexFrom = 0, this.indexCount = 0, this._sortKey = null;
  }
  get sortKey() {
    return null == this._sortKey && this._computeSortKey(), this._sortKey;
  }
  clone() {
    return this.copy();
  }
  copy() {
    const t = new s(this.id, this.geometryType, this.materialKey);
    return t.vertexFrom = this.vertexFrom, t.vertexCount = this.vertexCount, t.indexFrom = this.indexFrom, t.indexCount = this.indexCount, t.zOrder = this.zOrder, t.symbolLevel = this.symbolLevel, t.meshData = this.meshData, t.minZoom = this.minZoom, t.maxZoom = this.maxZoom, t;
  }
  setMeshDataFromBuffers(s, i, r) {
    const o = new _MeshData_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    for (const t in i) {
      const r = i[t].stride,
        a = i[t].data;
      if (!a) continue;
      const h = [],
        n = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.strideToPackingFactor)(r);
      for (let t = 0; t < r * s.vertexCount / n; ++t) h[t] = a[t + r * s.vertexFrom / n];
      o.vertexData.set(t, h);
    }
    o.indexData.length = 0;
    for (let t = 0; t < s.indexCount; ++t) o.indexData[t] = r[t + s.indexFrom] - s.vertexFrom;
    o.vertexCount = s.vertexCount, this.meshData = o;
  }
  readMeshDataFromBuffers(s, i) {
    this.meshData ? this.meshData.clear() : this.meshData = new _MeshData_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    for (const t in s) {
      const i = s[t].stride,
        r = s[t].data,
        o = [],
        a = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.strideToPackingFactor)(i);
      for (let t = 0; t < i * this.vertexCount / a; ++t) o[t] = r[t + i * this.vertexFrom / a];
      this.meshData.vertexData.set(t, o);
    }
    this.meshData.indexData.length = 0;
    for (let t = 0; t < this.indexCount; ++t) this.meshData.indexData[t] = i[t + this.indexFrom] - this.vertexFrom;
    this.meshData.vertexCount = this.vertexCount;
  }
  writeMeshDataToBuffers(t, s, i, r) {
    if (this.meshData) {
      for (const i in s) {
        const r = s[i].stride,
          o = this.meshData.vertexData.get(i),
          a = s[i].data,
          h = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.strideToPackingFactor)(r);
        for (let e = 0; e < r * this.meshData.vertexCount / h; ++e) a[e + r * t / h] = o[e];
      }
      for (let e = 0; e < this.meshData.indexData.length; ++e) r[e + i] = this.meshData.indexData[e] + t;
      this.vertexFrom = t, this.vertexCount = this.meshData.vertexCount, this.indexFrom = i, this.indexCount = this.meshData.indexData.length;
    }
  }
  static writeAllMeshDataToBuffers(t, e, s) {
    let i = 0,
      r = 0;
    for (const o of t) o.writeMeshDataToBuffers(i, e, r, s), i += o.vertexCount, r += o.indexCount;
  }
  _computeSortKey() {
    this._sortKey = (31 & this.symbolLevel) << 12 | (127 & this.zOrder) << 4 | 7 & this.geometryType;
  }
  serialize(t) {
    return t.push(this.geometryType), t.push(this.materialKey), t.push(this.vertexFrom), t.push(this.vertexCount), t.push(this.indexFrom), t.push(this.indexCount), t.push(this.minZoom), t.push(this.maxZoom), t;
  }
  static deserialize(t, e) {
    const i = t.readInt32(),
      r = t.readInt32(),
      o = new s(e.id, i, r);
    return o.vertexFrom = t.readInt32(), o.vertexCount = t.readInt32(), o.indexFrom = t.readInt32(), o.indexCount = t.readInt32(), o.minZoom = t.readInt32(), o.maxZoom = t.readInt32(), o;
  }
}


/***/ }),

/***/ 79950:
/*!******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexBuffer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VertexBuffers": () => (/* binding */ r)
/* harmony export */ });
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils.js */ 52300);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/

class t {
  constructor(e, t) {
    this.data = e, this.stride = t;
  }
  static decode(r) {
    const s = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.allocateTypedArrayBufferwithData)(r.data, r.stride),
      n = r.stride;
    return new t(s, n);
  }
  static fromVertexVector(r) {
    const s = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.allocateTypedArrayBufferwithData)(r.data.buffer(), r.stride),
      n = r.stride;
    return new t(s, n);
  }
}
class r {
  constructor(e, t, r) {
    this.geometryType = e, this.indexBuffer = new Uint32Array(t), this.namedBuffers = r;
  }
  static decode(e) {
    const s = e.geometryType,
      n = e.indexBuffer,
      o = {};
    for (const r in e.namedBuffers) o[r] = t.decode(e.namedBuffers[r]);
    return new r(s, n, o);
  }
  static fromVertexData(s, n) {
    const o = s.indices,
      c = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.allocateTypedArrayBufferwithData)(s.vertices, s.stride),
      i = s.stride,
      d = {
        geometry: new t(c, i)
      };
    return new r(n, o, d);
  }
  static fromVertexVectors(e) {
    const s = e.geometryType,
      n = e.indexVector.buffer(),
      o = {};
    let c;
    for (c in e.namedVectors) o[c] = t.fromVertexVector(e.namedVectors[c]);
    return new r(s, n, o);
  }
}


/***/ }),

/***/ 68336:
/*!******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexVector.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VertexVector": () => (/* binding */ s),
/* harmony export */   "VertexVectors": () => (/* binding */ o)
/* harmony export */ });
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils.js */ 52300);
/* harmony import */ var _VertexBuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VertexBuffer.js */ 79950);
/* harmony import */ var _util_Writer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Writer.js */ 68741);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/



class s {
  get vertexCount() {
    const t = this.stride / 4,
      e = this.data.length / t;
    return e !== (0 | e) && console.debug("Corrupted stride"), e;
  }
  constructor(t, e) {
    this.data = t, this.stride = e;
  }
  transfer(t, e) {
    const r = this.data.buffer();
    t.vertexCount = this.vertexCount, t.data = r, t.stride = this.stride, e.push(r);
  }
}
class o {
  constructor(e, o, n) {
    this.geometryType = e, this.indexVector = new _util_Writer_js__WEBPACK_IMPORTED_MODULE_2__["default"](Uint32Array, 6 * o), this.namedVectors = {};
    const i = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.getStrides)(e, n);
    for (const t in i) {
      const e = i[t];
      let n;
      switch (e % 4) {
        case 0:
        case 2:
          n = new _util_Writer_js__WEBPACK_IMPORTED_MODULE_2__["default"](Uint32Array, e * o);
          break;
        case 1:
        case 3:
          n = new _util_Writer_js__WEBPACK_IMPORTED_MODULE_2__["default"](Uint8Array, e * o);
      }
      this.namedVectors[t] = new s(n, e);
    }
  }
  get(t) {
    return this.namedVectors[t].data;
  }
  getVector(t) {
    return this.namedVectors[t];
  }
  transfer(t, e) {
    const r = this.indexVector.buffer(),
      s = {};
    let o;
    for (o in e.push(r), this.namedVectors) {
      const t = this.namedVectors[o];
      s[o] = {}, t.transfer(s[o], e);
    }
    t.geometryType = this.geometryType, t.indexBuffer = r, t.namedBuffers = s, this.destroy();
  }
  intoBuffers() {
    const t = _VertexBuffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffers.fromVertexVectors(this);
    return this.destroy(), t;
  }
  destroy() {
    this.indexVector = null, this.namedVectors = null;
  }
}


/***/ }),

/***/ 92568:
/*!************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deserializeList": () => (/* binding */ n),
/* harmony export */   "serializeList": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
function e(e, n) {
  if (null !== n) {
    e.push(n.length);
    for (const r of n) r.serialize(e);
    return e;
  }
  e.push(0);
}
function n(e, n, r) {
  const t = e.readInt32(),
    o = new Array(t);
  for (let i = 0; i < o.length; i++) o[i] = n.deserialize(e, r);
  return o;
}


/***/ }),

/***/ 50813:
/*!**************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphicsReader": () => (/* binding */ o)
/* harmony export */ });
/* harmony import */ var _geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../geometry/support/jsonUtils.js */ 71182);
/* harmony import */ var _layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../layers/graphics/featureConversionUtils.js */ 50805);
/* harmony import */ var _FeatureSetReader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FeatureSetReader.js */ 80074);
/* harmony import */ var _FeatureSetReaderJSON_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FeatureSetReaderJSON.js */ 80416);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/




class o extends _FeatureSetReaderJSON_js__WEBPACK_IMPORTED_MODULE_3__.FeatureSetReaderJSON {
  static from(s, n, i) {
    const c = _FeatureSetReader_js__WEBPACK_IMPORTED_MODULE_2__.FeatureSetReader.createInstance(),
      u = [],
      a = s.filter(r => !!r.geometry);
    for (const e of a) {
      const s = (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_0__.getJsonType)(e.geometry);
      (0,_layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_1__.convertFromGraphics)(u, [e], s, !1, !1, n);
    }
    return new o(c, u, i);
  }
  constructor(r, t, e) {
    super(r, t, null), this._transform = e;
  }
  get geometryType() {
    const r = this._current;
    return r ? r.geometryType : null;
  }
  get insertAfter() {
    return this._current.insertAfter;
  }
  readGraphic() {
    return this._current;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r = new o(this.instance, this._features, this._transform);
    return this.copyInto(r), r;
  }
}


/***/ }),

/***/ 16176:
/*!****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ b)
/* harmony export */ });
/* harmony import */ var _core_screenUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/screenUtils.js */ 55798);
/* harmony import */ var _chunks_rbush_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../chunks/rbush.js */ 34662);
/* harmony import */ var _geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../geometry/support/aaBoundingRect.js */ 6848);
/* harmony import */ var _geometry_support_boundsUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../geometry/support/boundsUtils.js */ 71949);
/* harmony import */ var _geometry_support_normalizeUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../geometry/support/normalizeUtils.js */ 93136);
/* harmony import */ var _geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../geometry/support/spatialReferenceUtils.js */ 53492);
/* harmony import */ var _symbols_cim_CIMSymbolDrawHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../symbols/cim/CIMSymbolDrawHelper.js */ 99061);
/* harmony import */ var _symbols_cim_CIMSymbolHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../symbols/cim/CIMSymbolHelper.js */ 77213);
/* harmony import */ var _GraphicStoreItem_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./GraphicStoreItem.js */ 20894);
/* harmony import */ var _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./graphicsUtils.js */ 48068);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/










const m = {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  },
  p = (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_2__.create)(),
  g = 1e-5;
function f(e, t, i, r, s) {
  return m.minX = t, m.minY = i, m.maxX = r, m.maxY = s, e.search(m);
}
function _(e) {
  return {
    minX: e.bounds[0],
    minY: e.bounds[1],
    maxX: e.bounds[2],
    maxY: e.bounds[3]
  };
}
class b {
  constructor(e, i, r, s, o, n, l) {
    this._graphics = s, this._onAdd = o, this._onRemove = n, this._hashToCIM = l, this._index = (0,_chunks_rbush_js__WEBPACK_IMPORTED_MODULE_1__.r)(9, _), this._itemByGraphic = new Map(), this._inflatedSizeHelper = new _symbols_cim_CIMSymbolHelper_js__WEBPACK_IMPORTED_MODULE_7__.CIMSymbolInflatedSizeHelper(), this._tileInfoView = e, this._uidFieldName = r;
    const u = e.getClosestInfoForScale(i);
    u && (this._resolution = this._tileInfoView.getTileResolution(u.level));
  }
  setResourceManager(e) {
    this._cimResourceManager = e, this._hittestDrawHelper = new _symbols_cim_CIMSymbolDrawHelper_js__WEBPACK_IMPORTED_MODULE_6__.HittestDrawHelper(e);
  }
  hitTest(e, t, s, o, l) {
    e = (0,_geometry_support_normalizeUtils_js__WEBPACK_IMPORTED_MODULE_4__.normalizeMapX)(e, this._tileInfoView.spatialReference);
    const u = .5 * o * window.devicePixelRatio * s;
    p[0] = e - u, p[1] = t - u, p[2] = e + u, p[3] = t + u;
    const h = .5 * o * (s + _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_9__.pixelBuffer),
      a = f(this._index, e - h, t - h, e + h, t + h);
    if (!a || 0 === a.length) return [];
    const d = [],
      m = (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_2__.create)(),
      g = (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_2__.create)();
    for (const i of a) {
      const {
        geometry: e,
        symbolResource: t
      } = i;
      this._getSymbolBounds(m, t, e, g, l), g[3] = g[2] = g[1] = g[0] = 0, (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(m, p) && i.graphic?.visible && d.push(i);
    }
    if (0 === d.length) return [];
    const _ = this._hittestDrawHelper,
      b = [];
    for (const i of d) {
      const {
          geometry: e,
          symbolResource: t
        } = i,
        {
          hash: r,
          textInfo: s
        } = t,
        n = this._hashToCIM.get(r);
      n && _.hitTest(p, n.symbol, e, s, l, o) && b.push(i);
    }
    return b.sort(y), b.map(e => e.graphic);
  }
  getGraphicsData(e, t, i) {
    const r = this._searchForItems(t);
    if (0 === r.length || 0 === i.length) return [];
    r.sort((e, t) => e.zorder - t.zorder), r[0].insertAfter = -1;
    for (let a = 1; a < r.length; a++) r[a].insertAfter = r[a - 1].graphic.uid;
    r.sort((e, t) => e.graphic.uid - t.graphic.uid), i.sort((e, t) => e.uid - t.uid);
    let s,
      o = 0,
      n = 0;
    const l = t.resolution,
      u = [],
      h = {
        originPosition: "upperLeft",
        scale: [l, l],
        translate: [t.bounds[0], t.bounds[3]]
      };
    for (const c of i) {
      for (n = -2; o < r.length;) if (s = r[o], o++, c.uid === s.graphic.uid) {
        n = s.insertAfter;
        break;
      }
      if (!s?.geometry || -2 === n) continue;
      const i = s.getGeometryQuantized(h, t.bounds, this._tileInfoView.spatialReference, l),
        d = {
          ...s.graphic.attributes
        };
      d[this._uidFieldName] = c.uid, null == s.groupId && (s.groupId = e.createTemplateGroup(s.symbol, null)), u.push({
        centroid: _GraphicStoreItem_js__WEBPACK_IMPORTED_MODULE_8__["default"].getCentroidQuantized(s, h),
        geometry: i,
        attributes: d,
        symbol: s.symbol,
        groupId: s.groupId,
        insertAfter: n,
        zorder: s.zorder
      });
    }
    return u.sort((e, t) => e.zorder - t.zorder), u;
  }
  queryTileData(e, t) {
    if (0 === this._graphics.length) return [];
    const {
        bounds: i,
        resolution: r
      } = t,
      s = this._searchForItems(t),
      o = [];
    return 0 === s.length || this._createTileGraphics(o, e, s, {
      originPosition: "upperLeft",
      scale: [r, r],
      translate: [i[0], i[3]]
    }, t), o;
  }
  has(e) {
    return this._itemByGraphic.has(e);
  }
  getBounds(e) {
    const t = this._itemByGraphic.get(e);
    return t ? t.bounds : null;
  }
  getAllBounds() {
    return Array.from(this._itemByGraphic.values()).filter(e => e.graphic.visible).map(e => e.bounds);
  }
  addOrModify(e, t, i) {
    if (!e || null == t) return;
    this.has(e) && this.remove(e), this._onAdd(e);
    const r = [0, 0, 0, 0],
      s = this._getSymbolBounds(null, t, i, r, 0),
      o = _GraphicStoreItem_js__WEBPACK_IMPORTED_MODULE_8__["default"].acquire(e, t, i, null != s ? s : null, r);
    return this._itemByGraphic.set(e, o), i && this._index.insert(o), o.bounds;
  }
  remove(e) {
    if (!this._itemByGraphic.has(e)) return;
    this._onRemove(e);
    const t = this._itemByGraphic.get(e);
    t?.bounds && this._index.remove(t), this._itemByGraphic.delete(e);
  }
  updateZ() {
    const e = this._graphics.items;
    let t, i;
    for (let r = 0; r < e.length; r++) i = e[r], t = this._itemByGraphic.get(i), t && (t.zorder = r);
  }
  update(e, t, i) {
    const r = this._itemByGraphic.get(e);
    r.groupId = null;
    const o = (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_2__.clone)(r.bounds);
    this._index.remove(r);
    const n = this._getSymbolBounds(r.bounds, t, i, r.size, 0);
    return null != n && r.set(e, t, i, n, r.size), i && this._index.insert(r), {
      oldBounds: o,
      newBounds: r.bounds
    };
  }
  updateLevel(e) {
    if (this._resolution === e) return;
    this._resolution = e, this._index.clear();
    const t = this._itemByGraphic,
      i = [];
    for (const [r, s] of t) {
      const e = this._getSymbolBounds(s.bounds, s.symbolResource, s.geometry, s.size, 0);
      s.geometry && null != e && (s.bounds = e, i.push(s));
    }
    this._index.load(i);
  }
  clear() {
    this._itemByGraphic.clear(), this._index.clear();
  }
  _createTileGraphics(e, t, i, r, s) {
    const o = this._uidFieldName,
      n = this._tileInfoView.spatialReference,
      {
        bounds: l,
        resolution: u
      } = s;
    let h, c, d, m;
    i.sort((e, t) => e.zorder - t.zorder);
    for (let p = 0; p < i.length; p++) {
      d = i[p], h = d.graphic, c = d.getGeometryQuantized(r, l, n, u), m = 0 === p ? -1 : i[p - 1].graphic.uid;
      const s = {
        ...d.graphic.attributes
      };
      s[o] = h.uid, null == d.groupId && (d.groupId = t.createTemplateGroup(d.symbol, null)), e.push({
        centroid: _GraphicStoreItem_js__WEBPACK_IMPORTED_MODULE_8__["default"].getCentroidQuantized(d, r),
        geometry: c,
        attributes: s,
        symbol: d.symbol,
        groupId: d.groupId,
        insertAfter: m,
        zorder: d.zorder
      });
    }
  }
  _searchForItems(e) {
    const t = this._tileInfoView.spatialReference,
      r = e.bounds,
      s = (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__.getInfo)(t);
    if (s && t.isWrappable) {
      const [t, o] = s.valid,
        n = Math.abs(r[2] - o) < g,
        l = Math.abs(r[0] - t) < g;
      if ((!n || !l) && (n || l)) {
        const s = e.resolution;
        let l;
        l = (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_2__.create)(n ? [t, r[1], t + s * _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_9__.pixelBuffer, r[3]] : [o - s * _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_9__.pixelBuffer, r[1], o, r[3]]);
        const u = f(this._index, r[0], r[1], r[2], r[3]),
          h = f(this._index, l[0], l[1], l[2], l[3]);
        return [...new Set([...u, ...h])];
      }
    }
    return f(this._index, r[0], r[1], r[2], r[3]);
  }
  _getSymbolBounds(t, r, s, n, l) {
    if (!r || !r.symbol || !s) return null;
    if (t || (t = (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_2__.create)()), (0,_geometry_support_boundsUtils_js__WEBPACK_IMPORTED_MODULE_3__.getBoundsXY)(t, s), !n || 0 === n[0] && 0 === n[1] && 0 === n[2] && 0 === n[3]) {
      const {
          hash: t,
          textInfo: i
        } = r,
        s = this._hashToCIM.get(t);
      if (!s) return null;
      n || (n = [0, 0, 0, 0]);
      const o = this._inflatedSizeHelper.getSymbolInflateSize(n, s.symbol, this._cimResourceManager, l, i);
      n[0] = (0,_core_screenUtils_js__WEBPACK_IMPORTED_MODULE_0__.pt2px)(o[0]), n[1] = (0,_core_screenUtils_js__WEBPACK_IMPORTED_MODULE_0__.pt2px)(o[1]), n[2] = (0,_core_screenUtils_js__WEBPACK_IMPORTED_MODULE_0__.pt2px)(o[2]), n[3] = (0,_core_screenUtils_js__WEBPACK_IMPORTED_MODULE_0__.pt2px)(o[3]);
    }
    const u = this._resolution,
      a = _symbols_cim_CIMSymbolHelper_js__WEBPACK_IMPORTED_MODULE_7__.CIMSymbolInflatedSizeHelper.safeSize(n);
    return t[0] -= a * u, t[1] -= a * u, t[2] += a * u, t[3] += a * u, t;
  }
}
const y = (e, t) => {
  const i = (0,_graphicsUtils_js__WEBPACK_IMPORTED_MODULE_9__.graphicGeometryToNumber)(e.graphic),
    r = (0,_graphicsUtils_js__WEBPACK_IMPORTED_MODULE_9__.graphicGeometryToNumber)(t.graphic);
  return i === r ? t.zorder - e.zorder : i - r;
};


/***/ }),

/***/ 20894:
/*!********************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ d)
/* harmony export */ });
/* harmony import */ var _geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../geometry/support/aaBoundingRect.js */ 6848);
/* harmony import */ var _geometry_support_centroid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../geometry/support/centroid.js */ 78127);
/* harmony import */ var _geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../geometry/support/jsonUtils.js */ 71182);
/* harmony import */ var _geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../geometry/support/quantizationUtils.js */ 6099);
/* harmony import */ var _geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../geometry/support/spatialReferenceUtils.js */ 53492);
/* harmony import */ var _layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../layers/graphics/featureConversionUtils.js */ 50805);
/* harmony import */ var _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../layers/graphics/OptimizedGeometry.js */ 93846);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/







const p = new _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"](),
  y = new _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"](),
  g = "esriGeometryPolyline";
function f(t) {
  t.coords.length = 0, t.lengths.length = 0;
}
class d {
  constructor() {
    this.bounds = (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_0__.create)(), this.graphic = null;
  }
  static acquire(t = null, e, s, r, i) {
    let o;
    return 0 === d._pool.length ? o = new d() : (o = d._pool.pop(), this._set.delete(o)), o.acquire(t, e, s, r, i), o;
  }
  static release(t) {
    t && !this._set.has(t) && (t.release(), this._pool.push(t), this._set.add(t));
  }
  static getCentroidQuantized(t, e) {
    if ((0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__.isPolygon)(t.geometry)) {
      const r = t.symbol;
      if (null == r) return null;
      if (r?.layers.length > 0 && r.layers.some(t => "text" === t.type || "marker" === t.type)) {
        const r = (0,_geometry_support_centroid_js__WEBPACK_IMPORTED_MODULE_1__.polygonCentroid)(t.geometry);
        return null !== r ? (0,_geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_3__.quantizePoint)(e, {}, {
          x: r[0],
          y: r[1]
        }, !1, !1) : null;
      }
    }
    return null;
  }
  acquire(t = null, e, s, r, i) {
    t && this.set(t, e, s, r, i);
  }
  release() {
    this.graphic = null, this.symbolResource = null, this.geometry = null;
  }
  get symbol() {
    return this.symbolResource.symbol;
  }
  set(t, e, s, r, i) {
    this.graphic = t, this.geometry = s, this.symbolResource = e, this.bounds = r, i && (this.size = i);
  }
  getGeometryQuantized(t, s, r, o) {
    const c = this.geometry,
      d = (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_2__.getJsonType)(c);
    if (null == d) return null;
    switch (d) {
      case "esriGeometryPolygon":
        {
          const e = c,
            {
              rings: s
            } = e;
          if (!s || 0 === s.length) return null;
          let r;
          if (r = 1 === s.length && 2 === s[0].length ? (0,_geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_3__.quantizeGeometry)(t, {
            paths: [[s[0][0], s[0][1]]]
          }) : (0,_geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_3__.quantizeGeometry)(t, this.geometry), !r) {
            const e = {
              x: s[0][0][0],
              y: s[0][0][1]
            };
            if (r = (0,_geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_3__.quantizeGeometry)(t, e), r) {
              const {
                x: t,
                y: e
              } = r;
              return {
                rings: [[[t - 1, e], [1, -1], [1, 1], [-1, 1], [-1, -1]]]
              };
            }
          }
          return r;
        }
      case "esriGeometryPolyline":
        {
          const e = c;
          f(p), f(y);
          const s = e.hasZ ?? !1,
            r = e.hasM ?? !1;
          return (0,_layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_5__.convertFromPolyline)(p, e), (0,_layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_5__.generalizeOptimizedGeometry)(y, p, s, r, g, t.scale[0]), (0,_layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_5__.quantizeOptimizedGeometry)(p, y, s, r, g, t), (0,_layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_5__.convertToPolyline)(p, e.hasZ ?? !1, e.hasM ?? !1);
        }
      case "esriGeometryMultipoint":
        {
          const i = c,
            u = .5 * o * Math.max(Math.abs(this.size[0]) + this.size[2] - this.size[0], Math.abs(this.size[1]) + this.size[3] - this.size[1]),
            h = (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_4__.getInfo)(r);
          let a = i.points;
          if (h) {
            const [t, r] = h.valid,
              i = r - t;
            a = a.filter(o => {
              if (o[0] + u > r || o[0] - u < t) {
                const t = [...o];
                return o[0] + u > r ? t[0] -= i : t[0] += i, (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_0__.containsPointWithMargin)(s, o, u) || (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_0__.containsPointWithMargin)(s, t, u);
              }
              return (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_0__.containsPointWithMargin)(s, o, u);
            });
          }
          return 0 === a.length ? {
            points: a
          } : (0,_geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_3__.quantizeGeometry)(t, {
            points: a
          });
        }
    }
    return (0,_geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_3__.quantizeGeometry)(t, this.geometry);
  }
}
d._pool = [], d._set = new Set();


/***/ }),

/***/ 86863:
/*!******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ re)
/* harmony export */ });
/* harmony import */ var _home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../chunks/tslib.es6.js */ 18100);
/* harmony import */ var _core_Accessor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../core/Accessor.js */ 2299);
/* harmony import */ var _core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../core/arrayUtils.js */ 19420);
/* harmony import */ var _core_BidiText_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../core/BidiText.js */ 65489);
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../core/has.js */ 67087);
/* harmony import */ var _core_Identifiable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../core/Identifiable.js */ 20711);
/* harmony import */ var _core_maybe_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../core/maybe.js */ 53661);
/* harmony import */ var _core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../core/promiseUtils.js */ 30801);
/* harmony import */ var _core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../core/reactiveUtils.js */ 7521);
/* harmony import */ var _core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../core/accessorSupport/decorators/property.js */ 9497);
/* harmony import */ var _core_accessorSupport_ensureType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../../core/accessorSupport/ensureType.js */ 83382);
/* harmony import */ var _core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../../core/accessorSupport/decorators/subclass.js */ 20891);
/* harmony import */ var _geometry_SpatialReference_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../../geometry/SpatialReference.js */ 68230);
/* harmony import */ var _geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../../geometry/support/aaBoundingRect.js */ 6848);
/* harmony import */ var _geometry_support_coordsUtils_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../../geometry/support/coordsUtils.js */ 12818);
/* harmony import */ var _geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../../geometry/support/jsonUtils.js */ 71182);
/* harmony import */ var _geometry_support_normalizeUtilsSync_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../../../geometry/support/normalizeUtilsSync.js */ 18661);
/* harmony import */ var _geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../../../geometry/support/spatialReferenceUtils.js */ 53492);
/* harmony import */ var _layers_graphics_data_projectionSupport_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../../../layers/graphics/data/projectionSupport.js */ 19482);
/* harmony import */ var _symbols_cim_CIMSymbolHelper_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../../../symbols/cim/CIMSymbolHelper.js */ 77213);
/* harmony import */ var _symbols_support_defaults_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../../../symbols/support/defaults.js */ 32682);
/* harmony import */ var _engine_webgl_definitions_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../engine/webgl/definitions.js */ 80696);
/* harmony import */ var _engine_webgl_enums_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../engine/webgl/enums.js */ 20753);
/* harmony import */ var _engine_webgl_GraphicTile_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../engine/webgl/GraphicTile.js */ 19761);
/* harmony import */ var _engine_webgl_TileData_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../engine/webgl/TileData.js */ 46555);
/* harmony import */ var _engine_webgl_WGLDisplayObject_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../../engine/webgl/WGLDisplayObject.js */ 64648);
/* harmony import */ var _engine_webgl_mesh_MeshData_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../engine/webgl/mesh/MeshData.js */ 73960);
/* harmony import */ var _engine_webgl_mesh_factories_WGLMeshFactory_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../engine/webgl/mesh/factories/WGLMeshFactory.js */ 98133);
/* harmony import */ var _engine_webgl_mesh_templates_WGLTemplateStore_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../../engine/webgl/mesh/templates/WGLTemplateStore.js */ 15978);
/* harmony import */ var _engine_webgl_util_Matcher_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../../engine/webgl/util/Matcher.js */ 61995);
/* harmony import */ var _features_schemaUtils_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../features/schemaUtils.js */ 29982);
/* harmony import */ var _features_support_AttributeStore_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../features/support/AttributeStore.js */ 25534);
/* harmony import */ var _features_support_ComputedAttributeStorage_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../features/support/ComputedAttributeStorage.js */ 19049);
/* harmony import */ var _features_support_GraphicsReader_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../features/support/GraphicsReader.js */ 50813);
/* harmony import */ var _GraphicStore_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./GraphicStore.js */ 16176);
/* harmony import */ var _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./graphicsUtils.js */ 48068);
/* harmony import */ var _support_cimSymbolUtils_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ../support/cimSymbolUtils.js */ 11362);
/* harmony import */ var _webgl_capabilities_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ../../../webgl/capabilities.js */ 86626);
/* harmony import */ var _features_createSymbolSchema_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ../features/createSymbolSchema.js */ 81945);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/







































const te = (0,_core_has_js__WEBPACK_IMPORTED_MODULE_5__["default"])("esri-2d-graphic-debug");
function ie(e, t, i) {
  let s = i.get(e);
  return s || (s = {
    tile: t,
    addedOrModified: [],
    removed: []
  }, i.set(e, s)), s;
}
let se = class extends (0,_core_Identifiable_js__WEBPACK_IMPORTED_MODULE_6__.IdentifiableMixin)(_core_Accessor_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
  constructor(e) {
    super(e), this._storage = new _features_support_ComputedAttributeStorage_js__WEBPACK_IMPORTED_MODULE_33__.ComputedAttributeStorage(), this._displayIds = new Map(), this._controller = new AbortController(), this._tiles = new Map(), this._graphicStoreUpdate = !1, this._graphicsSet = new Set(), this._matcher = Promise.resolve(null), this._tileUpdateSet = new Set(), this._tilesToUpdate = new Map(), this._graphicIdToAbortController = new Map(), this._attached = !1, this._updatingGraphicsTimer = null, this._hashToExpandedSymbol = new Map(), this._hashToExpandedSymbolPromise = new Map(), this._hashToCIMSymbolPromise = new Map(), this._hashToCIM = new Map(), this._processing = !1, this._needsProcessing = !1, this._pendingUpdate = {
      added: new Set(),
      updated: new Set(),
      removed: new Set()
    }, this.lastUpdateId = -1, this.renderer = null, this.updateRequested = !1, this.defaultPointSymbolEnabled = !0, this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this._updatingGraphicsTimer && (clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = null, this.notifyChange("updating")), this._controller.abort(), this.container.destroy(), this._set("graphics", null), this._graphicStore.clear(), this._attributeStore = null, this._hashToExpandedSymbol.clear(), this.view = null, this.renderer = null, this._hashToCIM.clear(), this._hashToCIMSymbolPromise.clear(), this._hashToExpandedSymbolPromise.clear();
  }
  _createMatcher(e, t, i) {
    if (e) {
      const s = (0,_features_schemaUtils_js__WEBPACK_IMPORTED_MODULE_31__.createSymbolSchemaOptions)(e),
        r = (0,_features_schemaUtils_js__WEBPACK_IMPORTED_MODULE_31__.createMatcherSchema)({
          indexCount: 0,
          fields: {}
        }, "feature", e, s);
      this._matcher = (0,_engine_webgl_util_Matcher_js__WEBPACK_IMPORTED_MODULE_30__.createMatcher)(r, t, null, i);
    }
  }
  _createDisplayId(e) {
    let t = this._displayIds.get(e);
    return t || (t = this._storage.createDisplayId(), this._displayIds.set(e, t)), t;
  }
  initialize() {
    this._attributeStore = new _features_support_AttributeStore_js__WEBPACK_IMPORTED_MODULE_32__["default"]({
      type: "local",
      initialize: e => Promise.resolve(this.container.attributeView.initialize(e)),
      update: e => this.container.attributeView.requestUpdate(e),
      render: () => this.container.requestRender()
    }, (0,_webgl_capabilities_js__WEBPACK_IMPORTED_MODULE_38__.getWebGLCapabilities)("2d")), this.container.checkHighlight = () => this._attributeStore.hasHighlight;
    const e = e => {
        this._createDisplayId(e.uid), this._setFilterState(e.uid, e.visible);
      },
      t = e => {
        const t = this._displayIds.get(e.uid);
        this._displayIds.delete(e.uid), this._storage.releaseDisplayId(t);
      },
      i = new _engine_webgl_mesh_templates_WGLTemplateStore_js__WEBPACK_IMPORTED_MODULE_29__.WGLTemplateStore(this.container.getMaterialItems.bind(this.container), this.view.featuresTilingScheme.tileInfo);
    this._graphicStore = new _GraphicStore_js__WEBPACK_IMPORTED_MODULE_35__["default"](this.view.featuresTilingScheme, this.view.state.scale, this.uid, this.graphics, e, t, this._hashToCIM), this._meshFactory = new _engine_webgl_mesh_factories_WGLMeshFactory_js__WEBPACK_IMPORTED_MODULE_28__.WGLMeshFactory(null, this.uid, i), this._templateStore = i, this.addHandles([(0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_9__.watch)(() => this._effectiveRenderer, e => {
      this._createMatcher(e, i, this.container.stage.resourceManager);
      for (const t of this.graphics) this._pendingUpdate.updated.add(t);
      this.requestUpdate();
    }), this.view.graphicsTileStore.on("update", this._onTileUpdate.bind(this)), this.container.on("attach", () => {
      te && this.container.enableRenderingBounds(() => this._graphicStore.getAllBounds()), this.graphics.items.length > 0 && this._graphicsChangeHandler({
        target: this.graphics,
        added: this.graphics.items,
        removed: [],
        moved: []
      }), this.addHandles(this.graphics.on("change", e => this._graphicsChangeHandler(e)), "graphics");
      const e = this.container.stage.resourceManager;
      this._createMatcher(this._effectiveRenderer, i, e), this._graphicStore.setResourceManager(e), this._attached = !0, this.notifyChange("updating");
    })]);
    const s = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({
      added: s,
      removed: []
    });
  }
  get _effectiveRenderer() {
    return "function" == typeof this.renderer ? this.renderer() : this.renderer;
  }
  get updating() {
    return !this._attached || null !== this._updatingGraphicsTimer || this._pendingUpdate.added.size > 0 || this._pendingUpdate.removed.size > 0 || this._pendingUpdate.updated.size > 0 || this._tileUpdateSet.size > 0 || this._tilesToUpdate.size > 0 || this._attributeStore?.updatingHandles.updating || this._processing;
  }
  hitTest(e) {
    if (!this.view || this.view.suspended) return [];
    const {
      resolution: t,
      rotation: i
    } = this.view.state;
    return this._graphicStore.hitTest(e.x, e.y, 2, t, i);
  }
  update(e) {
    (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(this._controller.signal);
    const t = e.state,
      {
        resolution: i
      } = t;
    if (this._graphicStore.updateLevel(i), this._graphicStoreUpdate = !0, this.updateRequested = !1, this._pendingUpdate.updated.size > 0) {
      if (!this._processing) return void this._updateGraphics();
      this._needsProcessing = !0;
    }
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = !0, this.requestUpdateCallback());
  }
  processUpdate(e) {
    this.updateRequested && (this.updateRequested = !1, this.update(e));
  }
  graphicUpdateHandler(e) {
    const {
      graphic: t,
      property: i
    } = e;
    switch (i) {
      case "attributes":
      case "geometry":
      case "symbol":
        this._pendingUpdate.updated.add(t), this.requestUpdate();
        break;
      case "visible":
        this._setFilterState(t.uid, t.visible), this._attributeStore.sendUpdates();
    }
  }
  setHighlight(e) {
    const t = e.map(e => this._displayIds.get(e)).filter(_core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_3__.isSome);
    this._attributeStore.setHighlight(e, t);
  }
  _getIntersectingTiles(e) {
    const t = this._graphicStore.getBounds(e);
    if (!t || 0 === (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_14__.width)(t) || 0 === (0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_14__.height)(t)) return [];
    const i = (0,_graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.intersectingInternationalDateline)(t, this.view.spatialReference);
    return null != i ? [...new Set([...this.view.graphicsTileStore.boundsIntersections(i[0]), ...this.view.graphicsTileStore.boundsIntersections(i[1])])] : this.view.graphicsTileStore.boundsIntersections(t);
  }
  _updateTile(e) {
    var _this = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(_this._controller.signal);
      const t = e.tile,
        i = _this._getGraphicsData(_this._templateStore, t, e.addedOrModified),
        s = yield _this._processGraphics(t, i);
      return (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(_this._controller.signal), _this._patchTile(t.key, {
        type: "update",
        addOrUpdate: s,
        remove: e.removed,
        end: !0,
        clear: !1,
        sort: !1
      }), s;
    })();
  }
  _patchTile(e, t) {
    const i = this._tiles.get(e);
    i && (this.container.onTileData(i, t), this.container.requestRender());
  }
  _graphicsChangeHandler(e) {
    const t = this._pendingUpdate;
    for (const i of e.added) t.added.add(i);
    for (const i of e.moved) t.updated.add(i);
    for (const i of e.removed) this._pendingUpdate.added.has(i) ? t.added.delete(i) : t.removed.add(i);
    this._processing ? this._needsProcessing = !0 : this._updateGraphics();
  }
  _getGraphicsToUpdate() {
    const e = {
      added: [],
      removed: [],
      updated: []
    };
    if (!this.graphics) return e;
    const t = this._pendingUpdate;
    for (const i of this.graphics.items) t.added.has(i) ? e.added.push(i) : t.updated.has(i) && e.updated.push(i);
    for (const i of t.removed) this._graphicStore.has(i) && e.removed.push(i);
    return t.added.clear(), t.removed.clear(), t.updated.clear(), e;
  }
  _updateGraphics() {
    var _this2 = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this2._processing = !0;
      const {
          added: e,
          removed: t,
          updated: i
        } = _this2._getGraphicsToUpdate(),
        s = _this2._tilesToUpdate;
      let r;
      try {
        if (!_this2._graphicStoreUpdate) {
          const e = _this2.view.state,
            {
              resolution: t
            } = e;
          _this2._graphicStore.updateLevel(t);
        }
        const o = [],
          a = new Array(e.length + t.length);
        for (let e = 0; e < i.length; e++) {
          const t = i[e],
            n = _this2._getIntersectingTiles(t);
          for (const e of n) {
            r = e.id;
            ie(r, e, s).removed.push(_this2._displayIds.get(t.uid));
          }
          o.push(_this2._updateGraphic(t, null)), a[e] = t;
        }
        const n = i.length;
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          a[n + t] = i, _this2._graphicsSet.add(i), o.push(_this2._addGraphic(i));
        }
        for (const e of t) {
          _this2._abortProcessingGraphic(e.uid);
          const t = _this2._getIntersectingTiles(e);
          for (const i of t) {
            r = i.id;
            ie(r, i, s).removed.push(_this2._displayIds.get(e.uid));
          }
          _this2._graphicsSet.delete(e), _this2._graphicStore.remove(e);
        }
        let h;
        _this2._flipUpdatingGraphics(), yield Promise.all(o);
        for (let e = 0; e < a.length; e++) {
          h = a[e];
          const t = _this2._getIntersectingTiles(h);
          for (const e of t) {
            r = e.id;
            ie(r, e, s).addedOrModified.push(h);
          }
        }
        _this2._graphicStore.updateZ();
        const l = [];
        for (const [e, t] of s) l.push(_this2._updateTile(t));
        yield Promise.all(l);
      } catch (o) {
        (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.isAbortError)(o), 0;
      }
      for (const a of t) try {
        const e = yield _this2._getSymbolForGraphic(a, null);
        if (e) {
          const t = e.hash();
          _this2._hashToExpandedSymbol.delete(t);
        }
      } catch (o) {
        (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.isAbortError)(o), 0;
      }
      s.clear(), _this2.notifyChange("updating"), _this2._processing = !1, _this2._needsProcessing && (_this2._needsProcessing = !1, _this2._updateGraphics());
    })();
  }
  _getArcadeInfo(e) {
    const t = (e.attributes ? Object.keys(e.attributes) : []).map(t => ({
      name: t,
      alias: t,
      type: "string" == typeof e.attributes[t] ? "esriFieldTypeString" : "esriFieldTypeDouble"
    }));
    return null == e.geometry ? null : {
      geometryType: (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.getJsonType)(e.geometry),
      spatialReference: _geometry_SpatialReference_js__WEBPACK_IMPORTED_MODULE_13__["default"].fromJSON(e.geometry.spatialReference),
      fields: t
    };
  }
  _getSymbolForGraphic(e, t) {
    return (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(this._controller.signal), null != e.symbol ? Promise.resolve(e.symbol) : null != this._effectiveRenderer ? this._effectiveRenderer.getSymbolAsync(e, {
      scale: this.view.state.scale,
      signal: null != t ? t.signal : null
    }) : Promise.resolve(this._getNullSymbol(e));
  }
  _getCIMSymbol(e, t, i) {
    let s = this._hashToCIM.get(t);
    if (s) return Promise.resolve(s);
    const r = (0,_symbols_cim_CIMSymbolHelper_js__WEBPACK_IMPORTED_MODULE_20__.symbolToCIM)(e);
    if (null != r) {
      if ("CIMSymbolReference" === r.type) return s = r, this._hashToCIM.set(t, s), Promise.resolve(s);
      let e = this._hashToCIMSymbolPromise.get(t);
      return e || (e = r.fetchCIMSymbol(i).then(e => (this._hashToCIM.set(t, e.data), this._hashToCIMSymbolPromise.delete(t), e)).catch(e => (this._hashToCIMSymbolPromise.delete(t), (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAbortError)(e), null)), this._hashToCIMSymbolPromise.set(t, e), e);
    }
    return Promise.resolve(null);
  }
  _expandCIMSymbol(e, t, i, s) {
    const r = this._hashToExpandedSymbol.get(i);
    if (r) return Promise.resolve(r);
    let o = this._hashToExpandedSymbolPromise.get(i);
    if (o) return o;
    const a = this.container.stage,
      n = this._getArcadeInfo(t),
      h = (0,_features_schemaUtils_js__WEBPACK_IMPORTED_MODULE_31__.createSymbolSchemaOptions)(null),
      l = (0,_features_createSymbolSchema_js__WEBPACK_IMPORTED_MODULE_39__.createSymbolSchema)(e, h);
    return o = (0,_support_cimSymbolUtils_js__WEBPACK_IMPORTED_MODULE_37__.expandSymbol)(l, n, a.resourceManager, s), this._hashToExpandedSymbolPromise.set(i, o), o.then(e => (this._hashToExpandedSymbol.set(i, e), this._hashToExpandedSymbolPromise.delete(i), e)), o;
  }
  _getSymbolResources(e, t) {
    var _this3 = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(_this3._controller.signal);
      return _this3.container.stage ? _this3._getSymbolForGraphic(e, t).then(i => {
        if (!i) return null;
        const r = i.hash();
        return _this3._getCIMSymbol(i, r, t).then(a => null == a ? null : _this3._expandCIMSymbol(a, e, r, t).then(e => {
          const t = e.layers.filter(e => "text" === e.type && "string" == typeof e.text);
          if (t && t.length > 0) {
            const a = new Array(t.length);
            for (let e = 0; e < t.length; e++) {
              const r = t[e],
                o = [],
                [n] = (0,_core_BidiText_js__WEBPACK_IMPORTED_MODULE_4__.bidiText)(r.text);
              r.text = n, "text" === i.type && (r.lineWidth = i.lineWidth);
              for (let e = 0; e < n.length; e++) o.push(n.charCodeAt(e));
              a[e] = {
                symbol: r,
                id: e,
                glyphIds: o
              };
            }
            const n = new Map();
            return _this3.container.getMaterialItems(a).then(i => {
              (0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_7__.assertIsSome)(i);
              for (let e = 0; e < t.length; e++) {
                const s = t[e];
                n.set(s.cim, {
                  text: s.text,
                  mosaicItem: i[e].mosaicItem
                });
              }
              return {
                symbol: e,
                textInfo: n,
                hash: r
              };
            });
          }
          return {
            symbol: e,
            hash: r
          };
        }));
      }).catch(e => ((0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAbortError)(e), null)) : null;
    })();
  }
  _projectAndNormalizeGeometry(e, t) {
    var _this4 = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if ((0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(_this4._controller.signal), null == e.geometry || "mesh" === e.geometry.type) return null;
      let i = e.geometry;
      if ((0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isPolygon)(i)) {
        const e = i.rings;
        i.rings = e;
      } else if ((0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isPolyline)(i)) {
        const e = i.paths;
        i.paths = e;
      } else if ((0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isExtent)(i)) {
        const s = yield _this4._getSymbolForGraphic(e, t);
        if ((0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(_this4._controller.signal), s && ((0,_graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.isMarkerSymbol)(s.type) || (0,_graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.isTextSymbol)(s.type))) {
          i = i.center;
        } else i = (0,_graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.polygonFromExtent)(i);
      }
      yield (0,_layers_graphics_data_projectionSupport_js__WEBPACK_IMPORTED_MODULE_19__.checkProjectionSupport)(i.spatialReference, _this4.view.spatialReference);
      const s = (0,_geometry_support_normalizeUtilsSync_js__WEBPACK_IMPORTED_MODULE_17__.normalizeCentralMeridianForDisplay)(i),
        r = (0,_layers_graphics_data_projectionSupport_js__WEBPACK_IMPORTED_MODULE_19__.project)(s, i.spatialReference, _this4.view.spatialReference);
      return r && (0,_geometry_support_coordsUtils_js__WEBPACK_IMPORTED_MODULE_15__.closeRingsAndFixWinding)(r), r;
    })();
  }
  _onTileUpdate(e) {
    const t = (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_18__.getInfo)(this.view.spatialReference);
    if (e.added && e.added.length > 0) for (const i of e.added) this._addNewTile(i, t);
    if (e.removed && e.removed.length > 0) for (const i of e.removed) this._removeTile(i.key);
  }
  _addGraphic(e) {
    var _this5 = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this5._abortProcessingGraphic(e.uid), (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(_this5._controller.signal);
      const t = new AbortController();
      _this5._graphicIdToAbortController.set(e.uid, t);
      const i = {
        signal: t.signal
      };
      try {
        yield _this5._addOrUpdateGraphic(e, i), (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(_this5._controller.signal), _this5._graphicIdToAbortController.delete(e.uid);
      } catch (s) {
        if (_this5._graphicIdToAbortController.delete(e.uid), !(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.isAbortError)(s)) throw s;
      }
    })();
  }
  _updateGraphic(e, t) {
    (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(this._controller.signal);
    const i = this._projectAndNormalizeGeometry(e, t),
      s = this._getSymbolResources(e, t);
    return Promise.all([i, s]).then(([t, i]) => {
      (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(this._controller.signal), this._graphicStore.addOrModify(e, i, t);
    });
  }
  _addOrUpdateGraphic(e, t) {
    (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(this._controller.signal);
    const i = this._projectAndNormalizeGeometry(e, t),
      s = this._getSymbolResources(e, t);
    return Promise.all([i, s]).then(([t, i]) => {
      (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.throwIfAborted)(this._controller.signal), this._graphicsSet.has(e) && this._graphicStore.addOrModify(e, i, t);
    });
  }
  _addTile(e) {
    const t = this.view.featuresTilingScheme.getTileBounds((0,_geometry_support_aaBoundingRect_js__WEBPACK_IMPORTED_MODULE_14__.create)(), e),
      i = this.view.featuresTilingScheme.getTileResolution(e.level),
      s = new _engine_webgl_GraphicTile_js__WEBPACK_IMPORTED_MODULE_24__.GraphicTile(e, i, t[0], t[3]);
    return this._tiles.set(e, s), this.container.addChild(s), s;
  }
  _addNewTile(e, t) {
    var _this6 = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const i = _this6._addTile(e.key),
        s = _this6._graphicStore.queryTileData(_this6._templateStore, e);
      if (0 === s.length) return;
      if (t) {
        const i = Math.round((t.valid[1] - t.valid[0]) / e.resolution);
        for (const e of s) e.geometry && ((0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isPoint)(e.geometry) || (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isMultipoint)(e.geometry)) && _this6._wrapPoints(e, i);
      }
      const r = e.key;
      _this6._tileUpdateSet.add(e.key), _this6.notifyChange("updating");
      try {
        const t = {
          type: "update",
          clear: !1,
          addOrUpdate: yield _this6._processGraphics(e, s),
          remove: [],
          end: !0,
          sort: !1
        };
        i.patch(t), _this6._tileUpdateSet.delete(r), _this6.notifyChange("updating");
      } catch (o) {
        if (_this6._tileUpdateSet.delete(r), _this6.notifyChange("updating"), !(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_8__.isAbortError)(o)) throw o;
      }
    })();
  }
  _removeTile(e) {
    if (!this._tiles.has(e)) return;
    const t = this._tiles.get(e);
    this.container.removeChild(t), t.destroy(), this._tiles.delete(e);
  }
  _setFilterState(e, t) {
    const i = this._displayIds.get(e),
      s = this._attributeStore.getHighlightFlag(e);
    this._attributeStore.setData(i, 0, 0, s | (t ? _engine_webgl_definitions_js__WEBPACK_IMPORTED_MODULE_22__.filterFlag0 : 0));
  }
  _getGraphicsData(e, t, i) {
    const s = this.view,
      r = (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_18__.getInfo)(s.spatialReference),
      o = this._graphicStore.getGraphicsData(e, t, i);
    if (r) {
      const e = Math.round((r.valid[1] - r.valid[0]) / t.resolution);
      for (const t of o) t.geometry && ((0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isPoint)(t.geometry) || (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isMultipoint)(t.geometry)) && this._wrapPoints(t, e);
    }
    return o;
  }
  _wrapPoints(e, t) {
    const i = e.geometry;
    (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isMultipoint)(i) ? this._wrapMultipoint(i, t) : this._wrapPoint(e, t);
  }
  _wrapMultipoint(e, t) {
    const i = e.points,
      s = [];
    let r = 0,
      o = 0;
    for (const [a, n] of i) {
      if (s.push([a + r, n]), r = 0, t === _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.tileSize) {
        const e = 5 * _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.pixelBuffer;
        a + o < e ? (s.push([t, 0]), r = -t) : a + o > _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.tileSize - e && (s.push([-t, 0]), r = t);
      } else a + o < -_graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.pixelBuffer ? (s.push([t, 0]), r = -t) : a + o > _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.tileSize + _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.pixelBuffer && (s.push([-t, 0]), r = t);
      o += a;
    }
    e.points = s;
  }
  _wrapPoint(e, t) {
    const i = e.geometry;
    if (t === _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.tileSize) {
      const s = 5 * _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.pixelBuffer;
      i.x < s ? e.geometry = {
        points: [[i.x, i.y], [t, 0]]
      } : i.x > _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.tileSize - s && (e.geometry = {
        points: [[i.x, i.y], [-t, 0]]
      });
    } else i.x < -_graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.pixelBuffer ? e.geometry = {
      points: [[i.x, i.y], [t, 0]]
    } : i.x > _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.tileSize + _graphicsUtils_js__WEBPACK_IMPORTED_MODULE_36__.pixelBuffer && (e.geometry = {
      points: [[i.x, i.y], [-t, 0]]
    });
  }
  _processGraphics(e, t, i) {
    if (!(t && t.length) || !this._meshFactory) return Promise.resolve(null);
    const s = _features_support_GraphicsReader_js__WEBPACK_IMPORTED_MODULE_34__.GraphicsReader.from(t, this.uid, e.transform),
      r = this._meshFactory;
    return this._matcher.then(t => r.analyzeGraphics(s, this.container.stage.resourceManager, t, null, null, i).then(() => (this._attributeStore.sendUpdates(), this._processAnalyzedGraphics(e, s))));
  }
  _processAnalyzedGraphics(e, t) {
    const i = this._meshFactory,
      s = t.getSize(),
      r = t.getCursor(),
      o = {
        features: s,
        records: s,
        metrics: 0
      },
      a = new _engine_webgl_mesh_MeshData_js__WEBPACK_IMPORTED_MODULE_27__.MeshData(e.key.id, o, _engine_webgl_enums_js__WEBPACK_IMPORTED_MODULE_23__.WGLSymbologyType.DEFAULT, !1, !1),
      n = [];
    for (; r.next();) {
      const t = r.readGraphic();
      t.insertAfter = -1 === t.insertAfter ? -1 : this._displayIds.get(t.insertAfter), t.displayId = this._displayIds.get(t.attributes[this.uid]);
      const s = new _engine_webgl_WGLDisplayObject_js__WEBPACK_IMPORTED_MODULE_26__["default"](t.displayId);
      s.insertAfter = t.insertAfter, n.push(s), i.writeGraphic(a, r, e.level, this.container.stage.resourceManager);
    }
    const h = e.tileInfoView.tileInfo.isWrappable,
      l = a.serialize(h);
    if (1 !== l.length) return new _engine_webgl_TileData_js__WEBPACK_IMPORTED_MODULE_25__.TileData();
    const d = l[0].message;
    return _engine_webgl_TileData_js__WEBPACK_IMPORTED_MODULE_25__.TileData.fromVertexData(d, n);
  }
  _abortProcessingGraphic(e) {
    this._graphicIdToAbortController.get(e)?.abort();
  }
  _getNullSymbol(e) {
    const t = e.geometry;
    return (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isPolyline)(t) ? _symbols_support_defaults_js__WEBPACK_IMPORTED_MODULE_21__.errorPolylineSymbol2D : (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isPolygon)(t) || (0,_geometry_support_jsonUtils_js__WEBPACK_IMPORTED_MODULE_16__.isExtent)(t) ? _symbols_support_defaults_js__WEBPACK_IMPORTED_MODULE_21__.errorPolygonSymbol2D : this.defaultPointSymbolEnabled ? _symbols_support_defaults_js__WEBPACK_IMPORTED_MODULE_21__.errorPointSymbol2D : null;
  }
  _flipUpdatingGraphics() {
    this._updatingGraphicsTimer && clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = setTimeout(() => {
      this._updatingGraphicsTimer = null, this.notifyChange("updating");
    }, 160), this.notifyChange("updating");
  }
};
(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)()], se.prototype, "_effectiveRenderer", null), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)({
  constructOnly: !0
})], se.prototype, "requestUpdateCallback", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)()], se.prototype, "container", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)({
  constructOnly: !0
})], se.prototype, "graphics", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)()], se.prototype, "renderer", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)()], se.prototype, "updating", null), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)()], se.prototype, "view", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)()], se.prototype, "updateRequested", void 0), (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_10__.property)()], se.prototype, "defaultPointSymbolEnabled", void 0), se = (0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_1__._)([(0,_core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_12__.subclass)("esri.views.2d.layers.support.GraphicsView2D")], se);
const re = se;


/***/ })

}]);
//# sourceMappingURL=default-node_modules_arcgis_core_chunks_vec3f32_js-node_modules_arcgis_core_views_2d_layers_g-7d7670.js.map