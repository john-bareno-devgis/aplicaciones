"use strict";
(self["webpackChunkrealgis"] = self["webpackChunkrealgis"] || []).push([["default-node_modules_arcgis_core_smartMapping_statistics_support_utils_js"],{

/***/ 19515:
/*!****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/smartMapping/statistics/support/utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateHeatmapStats": () => (/* binding */ x),
/* harmony export */   "getDataValues": () => (/* binding */ b),
/* harmony export */   "getRangeExpr": () => (/* binding */ N),
/* harmony export */   "getSQLFilterForNormalization": () => (/* binding */ F),
/* harmony export */   "getSumOfAttributesExpr": () => (/* binding */ R),
/* harmony export */   "mergeWhereClauses": () => (/* binding */ U),
/* harmony export */   "quantizeFeatures": () => (/* binding */ j),
/* harmony export */   "timeOnlyToMilliseconds": () => (/* binding */ w),
/* harmony export */   "verifyBasicFieldValidity": () => (/* binding */ T),
/* harmony export */   "verifyFieldType": () => (/* binding */ v),
/* harmony export */   "verifyFilterValidty": () => (/* binding */ M),
/* harmony export */   "verifyNumericField": () => (/* binding */ E)
/* harmony export */ });
/* harmony import */ var _home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _geometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry.js */ 6010);
/* harmony import */ var _core_Error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/Error.js */ 32995);
/* harmony import */ var _core_screenUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/screenUtils.js */ 55798);
/* harmony import */ var _core_timeUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/timeUtils.js */ 82588);
/* harmony import */ var _geometry_SpatialReference_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../geometry/SpatialReference.js */ 68230);
/* harmony import */ var _geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../geometry/support/quantizationUtils.js */ 6099);
/* harmony import */ var _geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../geometry/support/spatialReferenceUtils.js */ 53492);
/* harmony import */ var _layers_support_fieldUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../layers/support/fieldUtils.js */ 32746);
/* harmony import */ var _renderers_support_heatmapUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../renderers/support/heatmapUtils.js */ 45811);
/* harmony import */ var _support_utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../support/utils.js */ 70052);
/* harmony import */ var _statistics_utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../statistics/utils.js */ 48067);
/* harmony import */ var _support_arcadeOnDemand_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../support/arcadeOnDemand.js */ 77238);
/* harmony import */ var _geometry_Point_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../geometry/Point.js */ 72062);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/













let $ = null;
const g = /^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;
function I(e, t, n) {
  return e.x < 0 ? e.x += t : e.x > n && (e.x -= t), e;
}
function j(e, t, n, r) {
  const l = (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_7__.isWrappable)(n) ? (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_7__.getInfo)(n) : null,
    u = l ? Math.round((l.valid[1] - l.valid[0]) / t.scale[0]) : null;
  return e.map(e => {
    const n = new _geometry_Point_js__WEBPACK_IMPORTED_MODULE_13__["default"](e.geometry);
    return (0,_geometry_support_quantizationUtils_js__WEBPACK_IMPORTED_MODULE_6__.quantizePoint)(t, n, n, n.hasZ, n.hasM), e.geometry = l ? I(n, u ?? 0, r[0]) : n, e;
  });
}
function x(e, n = 18, r, o, i, s) {
  const l = new Float64Array(i * s);
  n = Math.round((0,_core_screenUtils_js__WEBPACK_IMPORTED_MODULE_3__.pt2px)(n));
  let u = Number.POSITIVE_INFINITY,
    a = Number.NEGATIVE_INFINITY,
    c = 0,
    d = 0,
    p = 0,
    h = 0;
  const y = (0,_renderers_support_heatmapUtils_js__WEBPACK_IMPORTED_MODULE_9__.createValueFunction)(o, r);
  for (const {
    geometry: t,
    attributes: m
  } of e) {
    const {
        x: e,
        y: r
      } = t,
      o = Math.max(0, e - n),
      $ = Math.max(0, r - n),
      g = Math.min(s, r + n),
      I = Math.min(i, e + n),
      j = +y(m);
    for (let t = $; t < g; t++) for (let s = o; s < I; s++) {
      const o = t * i + s,
        m = (0,_renderers_support_heatmapUtils_js__WEBPACK_IMPORTED_MODULE_9__.evaluateDensityKernel)(s - e, t - r, n),
        y = l[o];
      c = l[o] += m * j;
      const $ = c - y;
      d += $, p += $ * $, c < u && (u = c), c > a && (a = c), h++;
    }
  }
  if (!h) return {
    mean: 0,
    stddev: 0,
    min: 0,
    max: 0,
    mid: 0,
    count: 0
  };
  const $ = (a - u) / 2;
  return {
    mean: d / h,
    stdDev: Math.sqrt((p - d * d / h) / h),
    min: u,
    max: a,
    mid: $,
    count: h
  };
}
function w(e) {
  const t = g.exec(e);
  if (!t) return null;
  const {
    hh: r,
    mm: o,
    ss: i,
    ms: s
  } = t.groups;
  return Number(r) * _core_timeUtils_js__WEBPACK_IMPORTED_MODULE_4__.millisecondsPerTimeUnit.hours + Number(o) * _core_timeUtils_js__WEBPACK_IMPORTED_MODULE_4__.millisecondsPerTimeUnit.minutes + Number(i) * _core_timeUtils_js__WEBPACK_IMPORTED_MODULE_4__.millisecondsPerTimeUnit.seconds + Number(s || 0);
}
function b(_x, _x2) {
  return _b.apply(this, arguments);
}
function _b() {
  _b = (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (e, t, n = !0) {
    if (!t) return [];
    const {
        field: o,
        field2: i,
        field3: s,
        fieldDelimiter: u,
        fieldInfos: a,
        timeZone: f
      } = e,
      m = o && a?.find(e => e.name.toLowerCase() === o.toLowerCase()),
      y = !!m && (0,_layers_support_fieldUtils_js__WEBPACK_IMPORTED_MODULE_8__.isTimeOnlyField)(m),
      g = !!m && (0,_support_utils_js__WEBPACK_IMPORTED_MODULE_10__.isAnyDateField)(m),
      I = e.valueExpression,
      j = e.normalizationType,
      x = e.normalizationField,
      b = e.normalizationTotal,
      F = [],
      N = e.viewInfoParams;
    let v = null,
      E = null;
    if (I) {
      if (!$) {
        const {
          arcadeUtils: e
        } = yield (0,_support_arcadeOnDemand_js__WEBPACK_IMPORTED_MODULE_12__.loadArcade)();
        $ = e;
      }
      $.hasGeometryOperations(I) && (yield $.enableGeometryOperations()), v = $.createFunction(I), E = N ? $.getViewInfo({
        viewingMode: N.viewingMode,
        scale: N.scale,
        spatialReference: new _geometry_SpatialReference_js__WEBPACK_IMPORTED_MODULE_5__["default"](N.spatialReference)
      }) : null;
    }
    const U = e.fieldInfos,
      M = !(t[0] && "declaredClass" in t[0] && "esri.Graphic" === t[0].declaredClass) && U ? {
        fields: U
      } : null;
    return t.forEach(e => {
      const t = e.attributes;
      let r;
      if (I) {
        const t = M ? {
            ...e,
            layer: M
          } : e,
          n = $.createExecContext(t, E, f);
        r = $.executeFunction(v, n);
      } else t && (r = t[o], i ? (r = `${(0,_statistics_utils_js__WEBPACK_IMPORTED_MODULE_11__.processNullValue)(r)}${u}${(0,_statistics_utils_js__WEBPACK_IMPORTED_MODULE_11__.processNullValue)(t[i])}`, s && (r = `${r}${u}${(0,_statistics_utils_js__WEBPACK_IMPORTED_MODULE_11__.processNullValue)(t[s])}`)) : "string" == typeof r && n && (g ? r = r ? new Date(r).getTime() : null : y && (r = r ? w(r) : null)));
      if (j && "number" == typeof r && isFinite(r)) {
        const e = t && parseFloat(t[x]);
        r = (0,_statistics_utils_js__WEBPACK_IMPORTED_MODULE_11__.getNormalizedValue)(r, j, e, b);
      }
      F.push(r);
    }), F;
  });
  return _b.apply(this, arguments);
}
function F(e) {
  const t = e.field,
    n = e.normalizationType,
    r = e.normalizationField;
  let o;
  return "field" === n ? o = "(NOT " + r + " = 0)" : "log" !== n && "natural-log" !== n && "square-root" !== n || (o = `(${t} > 0)`), o;
}
function N(e, t, n) {
  const r = null != t ? e + " >= " + t : "",
    o = null != n ? e + " <= " + n : "";
  let i = "";
  return i = r && o ? U(r, o) : r || o, i ? "(" + i + ")" : "";
}
function v(t, n, r, o) {
  let i;
  return n ? n.name !== t.objectIdField && o.includes(n.type) || (i = new _core_Error_js__WEBPACK_IMPORTED_MODULE_2__["default"](r, "'field' should be one of these types: " + o.join(","))) : i = new _core_Error_js__WEBPACK_IMPORTED_MODULE_2__["default"](r, "'field' is not defined in the layer schema"), i;
}
function E(t, n, r) {
  let o;
  return n ? n.name !== t.objectIdField && (0,_layers_support_fieldUtils_js__WEBPACK_IMPORTED_MODULE_8__.isNumericField)(n) || (o = new _core_Error_js__WEBPACK_IMPORTED_MODULE_2__["default"](r, "'field' should be one of these numeric types: " + _layers_support_fieldUtils_js__WEBPACK_IMPORTED_MODULE_8__.numericTypes.join(","))) : o = new _core_Error_js__WEBPACK_IMPORTED_MODULE_2__["default"](r, "'field' is not defined in the layer schema"), o;
}
function U(e, t) {
  let n = null != e ? e : "";
  return null != t && t && (n = n ? "(" + n + ") AND (" + t + ")" : t), n;
}
function M(t, n) {
  if (t && "intersects" !== t.spatialRelationship) return new _core_Error_js__WEBPACK_IMPORTED_MODULE_2__["default"](n, "Only 'intersects' spatialRelationship is supported for featureFilter");
}
function T(t, n, r) {
  const o = z({
    layer: t,
    fields: n
  });
  if (o.length) return new _core_Error_js__WEBPACK_IMPORTED_MODULE_2__["default"](r, "Unknown fields: " + o.join(", ") + ". You can only use fields defined in the layer schema");
  const i = O({
    layer: t,
    fields: n
  });
  return i.length ? new _core_Error_js__WEBPACK_IMPORTED_MODULE_2__["default"](r, "Unsupported fields: " + i.join(", ") + ". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true") : void 0;
}
function z(e) {
  const t = e.layer;
  return e.fields.filter(e => !t.getField(e));
}
function O(e) {
  const t = e.layer;
  return e.fields.filter(e => {
    const n = t.getFieldUsageInfo(e);
    return !n || !n.supportsStatistics;
  });
}
function R(e, t, n) {
  const r = [],
    o = [],
    i = [],
    s = [],
    l = [];
  e.forEach((e, t) => {
    const u = e.field ? "field" : "expression",
      a = e.field || e.valueExpression;
    e.field ? (l.push(a), o.push(`var ${u}${t} = Number($feature["${a}"]);`)) : (r.push(`function getValueForExpr${t}() {\n  ${a} \n}`), o.push(`var ${u}${t} = Number(getValueForExpr${t}());`)), n || i.push(`${u}${t} = IIf(${u}${t} < 0, 0, ${u}${t});`), s.push(`${u}${t}`);
  });
  let u = "return sum;";
  const a = r.length ? null : l.reduce((e, t) => `${e} + ${t}`);
  let f = null;
  t || n ? t ? n || (u = "return IIf(sum >= 0, sum, null);", a && (f = `(( ${a} ) >= 0)`)) : (u = "return IIf(sum != 0, sum, null);", a && (f = `(( ${a} ) <> 0)`)) : (u = "return IIf(sum > 0, sum, null);", a && (f = `(( ${a} ) > 0)`));
  return {
    valueExpression: [r.length ? r.join("\n") : "", o.join("\n"), i.join("\n"), `var sum = ${s.join(" + ")};`, u].filter(Boolean).join("\n\n"),
    sqlExpression: a,
    sqlWhere: f
  };
}


/***/ }),

/***/ 48067:
/*!*******************************************************!*\
  !*** ./node_modules/@arcgis/core/statistics/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateClassBreaks": () => (/* binding */ E),
/* harmony export */   "calculateHistogram": () => (/* binding */ U),
/* harmony export */   "calculatePercentile": () => (/* binding */ v),
/* harmony export */   "calculateStatistics": () => (/* binding */ p),
/* harmony export */   "calculateStringStatistics": () => (/* binding */ d),
/* harmony export */   "calculateUniqueValuesCount": () => (/* binding */ k),
/* harmony export */   "createClassBreaksDefinition": () => (/* binding */ q),
/* harmony export */   "createUVResult": () => (/* binding */ $),
/* harmony export */   "getAttributeComparator": () => (/* binding */ T),
/* harmony export */   "getEqualIntervalBins": () => (/* binding */ j),
/* harmony export */   "getNormalizedValue": () => (/* binding */ B),
/* harmony export */   "isNullCountSupported": () => (/* binding */ f),
/* harmony export */   "processNullValue": () => (/* binding */ c),
/* harmony export */   "processSummaryStatisticsResult": () => (/* binding */ C),
/* harmony export */   "resolveCBResult": () => (/* binding */ P),
/* harmony export */   "statisticTypes": () => (/* binding */ m)
/* harmony export */ });
/* harmony import */ var _rest_support_ClassBreaksDefinition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rest/support/ClassBreaksDefinition.js */ 71062);
/* harmony import */ var _rest_support_generateRendererUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rest/support/generateRendererUtils.js */ 76171);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/


const t = "<Null>",
  l = "equal-interval",
  i = 1,
  a = 5,
  o = 10,
  r = /\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,
  u = new Set(["esriFieldTypeDate", "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeLong", "esriFieldTypeOID", "esriFieldTypeBigInteger"]),
  s = new Set(["esriFieldTypeTimeOnly", "esriFieldTypeDateOnly"]),
  m = ["min", "max", "avg", "stddev", "count", "sum", "variance", "nullcount", "median"];
function c(n) {
  return null == n || "string" == typeof n && !n ? t : n;
}
function f(n) {
  const e = null != n.normalizationField || null != n.normalizationType,
    t = null != n.minValue || null != n.maxValue,
    l = !!n.sqlExpression && n.supportsSQLExpression;
  return !e && !t && !l;
}
function d(n) {
  const e = n.returnDistinct ? [...new Set(n.values)] : n.values,
    t = e.filter(n => null != n).sort(),
    l = t.length,
    i = {
      count: l,
      min: t[0],
      max: t[l - 1]
    };
  return n.supportsNullCount && (i.nullcount = e.length - l), n.percentileParams && (i.median = v(e, n.percentileParams)), i;
}
function p(n) {
  const {
    values: e,
    useSampleStdDev: t,
    supportsNullCount: l
  } = n;
  let i = Number.POSITIVE_INFINITY,
    a = Number.NEGATIVE_INFINITY,
    o = null,
    r = null,
    u = null,
    s = null,
    m = 0;
  const c = null == n.minValue ? -1 / 0 : n.minValue,
    f = null == n.maxValue ? 1 / 0 : n.maxValue;
  for (const p of e) Number.isFinite(p) ? p >= c && p <= f && (o = null === o ? p : o + p, i = Math.min(i, p), a = Math.max(a, p), m++) : "string" == typeof p && m++;
  if (m && null != o) {
    r = o / m;
    let n = 0;
    for (const t of e) Number.isFinite(t) && t >= c && t <= f && (n += (t - r) ** 2);
    s = t ? m > 1 ? n / (m - 1) : 0 : m > 0 ? n / m : 0, u = Math.sqrt(s);
  } else i = null, a = null;
  const d = {
    avg: r,
    count: m,
    max: a,
    min: i,
    stddev: u,
    sum: o,
    variance: s
  };
  return l && (d.nullcount = e.length - m), n.percentileParams && (d.median = v(e, n.percentileParams)), d;
}
function v(n, e) {
  const {
      fieldType: t,
      value: l,
      orderBy: i,
      isDiscrete: a
    } = e,
    o = T(t, "desc" === i);
  if (0 === (n = [...n].filter(n => null != n).sort((n, e) => o(n, e))).length) return null;
  if (l <= 0) return n[0];
  if (l >= 1) return n[n.length - 1];
  const r = (n.length - 1) * l,
    u = Math.floor(r),
    s = u + 1,
    m = r % 1,
    c = n[u],
    f = n[s];
  return s >= n.length || a || "string" == typeof c || "string" == typeof f ? c : c * (1 - m) + f * m;
}
function T(n, e) {
  if (n) {
    if (u.has(n)) return S(e);
    if (s.has(n)) return z(e, !1);
    if ("esriFieldTypeTimestampOffset" === n) return x(e);
    const t = z(e, !0);
    if ("esriFieldTypeString" === n) return t;
    if ("esriFieldTypeGUID" === n || "esriFieldTypeGlobalID" === n) return (n, e) => t(M(n), M(e));
  }
  const t = e ? 1 : -1,
    l = S(e),
    i = z(e, !0);
  return (n, e) => "number" == typeof n && "number" == typeof e ? l(n, e) : "string" == typeof n && "string" == typeof e ? i(n, e) : t;
}
const g = (n, e) => null == n ? null == e ? 0 : 1 : null == e ? -1 : null,
  h = (n, e) => null == n ? null == e ? 0 : -1 : null == e ? 1 : null;
function V(n) {
  return n ? g : h;
}
const b = (n, e) => h(n, e) ?? (n === e ? 0 : new Date(n).getTime() - new Date(e).getTime()),
  y = (n, e) => g(n, e) ?? (n === e ? 0 : new Date(e).getTime() - new Date(n).getTime());
function x(n) {
  return n ? y : b;
}
const F = (n, e) => h(n, e) ?? (n === e ? 0 : n < e ? -1 : 1),
  D = (n, e) => g(n, e) ?? (n === e ? 0 : n < e ? 1 : -1);
function z(n, e) {
  if (!e) return n ? D : F;
  const t = V(n);
  return n ? (n, e) => {
    const l = t(n, e);
    return null != l ? l : (n = n.toUpperCase()) > (e = e.toUpperCase()) ? -1 : n < e ? 1 : 0;
  } : (n, e) => {
    const l = t(n, e);
    return null != l ? l : (n = n.toUpperCase()) < (e = e.toUpperCase()) ? -1 : n > e ? 1 : 0;
  };
}
const I = (n, e) => g(n, e) ?? e - n,
  N = (n, e) => h(n, e) ?? n - e;
function S(n) {
  return n ? I : N;
}
function M(n) {
  return n.substr(24, 12) + n.substr(19, 4) + n.substr(16, 2) + n.substr(14, 2) + n.substr(11, 2) + n.substr(9, 2) + n.substr(6, 2) + n.substr(4, 2) + n.substr(2, 2) + n.substr(0, 2);
}
function C(n, e) {
  let t;
  for (t in n) m.includes(t) && (Number.isFinite(n[t]) || (n[t] = null));
  return e ? (["avg", "stddev", "variance"].forEach(e => {
    null != n[e] && (n[e] = Math.ceil(n[e] ?? 0));
  }), n) : n;
}
function k(n) {
  const e = {};
  for (let t of n) (null == t || "string" == typeof t && "" === t.trim()) && (t = null), null == e[t] ? e[t] = {
    count: 1,
    data: t
  } : e[t].count++;
  return {
    count: e
  };
}
function w(n) {
  return "coded-value" !== n?.type ? [] : n.codedValues.map(n => n.code);
}
function $(n, e, t, l) {
  const i = n.count,
    a = [];
  if (t && e) {
    const n = [],
      t = w(e[0]);
    for (const i of t) if (e[1]) {
      const t = w(e[1]);
      for (const a of t) if (e[2]) {
        const t = w(e[2]);
        for (const e of t) n.push(`${c(i)}${l}${c(a)}${l}${c(e)}`);
      } else n.push(`${c(i)}${l}${c(a)}`);
    } else n.push(i);
    for (const e of n) i.hasOwnProperty(e) || (i[e] = {
      data: e,
      count: 0
    });
  }
  for (const o in i) {
    const n = i[o];
    a.push({
      value: n.data,
      count: n.count,
      label: n.label
    });
  }
  return {
    uniqueValueInfos: a
  };
}
function B(n, e, t, l) {
  let i = null;
  switch (e) {
    case "log":
      0 !== n && (i = Math.log(n) * Math.LOG10E);
      break;
    case "percent-of-total":
      Number.isFinite(l) && 0 !== l && (i = n / l * 100);
      break;
    case "field":
      Number.isFinite(t) && 0 !== t && (i = n / t);
      break;
    case "natural-log":
      n > 0 && (i = Math.log(n));
      break;
    case "square-root":
      n > 0 && (i = n ** .5);
  }
  return i;
}
function E(n, t) {
  const l = q({
    field: t.field,
    normalizationType: t.normalizationType,
    normalizationField: t.normalizationField,
    classificationMethod: t.classificationMethod,
    standardDeviationInterval: t.standardDeviationInterval,
    breakCount: t.numClasses || a
  });
  return n = O(n, t.minValue, t.maxValue), (0,_rest_support_generateRendererUtils_js__WEBPACK_IMPORTED_MODULE_1__.createGenerateRendererClassBreaks)({
    definition: l,
    values: n,
    normalizationTotal: t.normalizationTotal
  });
}
function O(n, e, t) {
  const l = e ?? -1 / 0,
    i = t ?? 1 / 0;
  return n.filter(n => Number.isFinite(n) && n >= l && n <= i);
}
function q(e) {
  const {
      breakCount: t,
      field: a,
      normalizationField: o,
      normalizationType: r
    } = e,
    u = e.classificationMethod || l,
    s = "standard-deviation" === u ? e.standardDeviationInterval || i : void 0;
  return new _rest_support_ClassBreaksDefinition_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
    breakCount: t,
    classificationField: a,
    classificationMethod: u,
    normalizationField: "field" === r ? o : void 0,
    normalizationType: r,
    standardDeviationInterval: s
  });
}
function P(n, e) {
  let t = n.classBreaks;
  const l = t.length,
    i = t[0]?.minValue,
    a = t[l - 1]?.maxValue,
    o = "standard-deviation" === e,
    u = r;
  return t = t.map(n => {
    const e = n.label,
      t = {
        minValue: n.minValue,
        maxValue: n.maxValue,
        label: e
      };
    if (o && e) {
      const n = e.match(u),
        l = n?.map(n => +n.trim()) ?? [];
      2 === l.length ? (t.minStdDev = l[0], t.maxStdDev = l[1], l[0] < 0 && l[1] > 0 && (t.hasAvg = !0)) : 1 === l.length && (e.includes("<") ? (t.minStdDev = null, t.maxStdDev = l[0]) : e.includes(">") && (t.minStdDev = l[0], t.maxStdDev = null));
    }
    return t;
  }), {
    minValue: i,
    maxValue: a,
    classBreakInfos: t,
    normalizationTotal: n.normalizationTotal
  };
}
function U(n, e) {
  const t = G(n, e);
  if (null == t.min && null == t.max) return {
    bins: [],
    minValue: t.min,
    maxValue: t.max,
    normalizationTotal: e.normalizationTotal
  };
  const l = t.intervals,
    i = t.min ?? 0,
    a = t.max ?? 0,
    o = l.map((n, e) => ({
      minValue: l[e][0],
      maxValue: l[e][1],
      count: 0
    }));
  for (const r of n) if (null != r && r >= i && r <= a) {
    const n = L(l, r);
    n > -1 && o[n].count++;
  }
  return {
    bins: o,
    minValue: i,
    maxValue: a,
    normalizationTotal: e.normalizationTotal
  };
}
function G(n, e) {
  const {
      field: t,
      classificationMethod: l,
      standardDeviationInterval: i,
      normalizationType: a,
      normalizationField: r,
      normalizationTotal: u,
      minValue: s,
      maxValue: m
    } = e,
    c = e.numBins || o;
  let d = null,
    v = null,
    T = null;
  if ((!l || "equal-interval" === l) && !a) {
    if (null != s && null != m) d = s, v = m;else {
      const e = p({
        values: n,
        minValue: s,
        maxValue: m,
        useSampleStdDev: !a,
        supportsNullCount: f({
          normalizationType: a,
          normalizationField: r,
          minValue: s,
          maxValue: m
        })
      });
      d = e.min ?? null, v = e.max ?? null;
    }
    T = j(d ?? 0, v ?? 0, c);
  } else {
    const {
      classBreaks: e
    } = E(n, {
      field: t,
      normalizationType: a,
      normalizationField: r,
      normalizationTotal: u,
      classificationMethod: l,
      standardDeviationInterval: i,
      minValue: s,
      maxValue: m,
      numClasses: c
    });
    d = e[0].minValue, v = e[e.length - 1].maxValue, T = e.map(n => [n.minValue, n.maxValue]);
  }
  return {
    min: d,
    max: v,
    intervals: T
  };
}
function L(n, e) {
  let t = -1;
  for (let l = n.length - 1; l >= 0; l--) {
    if (e >= n[l][0]) {
      t = l;
      break;
    }
  }
  return t;
}
function j(n, e, t) {
  const l = (e - n) / t,
    i = [];
  let a,
    o = n;
  for (let r = 1; r <= t; r++) a = o + l, a = Number(a.toFixed(16)), i.push([o, r === t ? e : a]), o = a;
  return i;
}


/***/ })

}]);
//# sourceMappingURL=default-node_modules_arcgis_core_smartMapping_statistics_support_utils_js.js.map