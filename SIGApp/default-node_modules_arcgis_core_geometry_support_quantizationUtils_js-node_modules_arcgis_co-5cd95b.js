"use strict";
(self["webpackChunkrealgis"] = self["webpackChunkrealgis"] || []).push([["default-node_modules_arcgis_core_geometry_support_quantizationUtils_js-node_modules_arcgis_co-5cd95b"],{

/***/ 17409:
/*!*********************************************************************!*\
  !*** ./node_modules/@arcgis/core/geometry/geometryAdapters/json.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jsonAdapter": () => (/* binding */ t)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
const t = {
  convertToGEGeometry: s,
  exportPoint: n,
  exportPolygon: o,
  exportPolyline: a,
  exportMultipoint: c,
  exportExtent: m
};
function s(t, s) {
  return null == s ? null : t.convertJSONToGeometry(s);
}
class i {
  constructor(t, s, i) {
    this.x = t, this.y = s, this.spatialReference = i, this.z = void 0, this.m = void 0;
  }
}
function n(t, s, n) {
  const e = new i(t.getPointX(s), t.getPointY(s), n),
    o = t.hasZ(s),
    h = t.hasM(s);
  return o && (e.z = t.getPointZ(s)), h && (e.m = t.getPointM(s)), e;
}
class e {
  constructor(t, s, i, n) {
    this.rings = t, this.spatialReference = s, this.hasZ = void 0, this.hasM = void 0, i && (this.hasZ = i), n && (this.hasM = n);
  }
}
function o(t, s, i) {
  return new e(t.exportPaths(s), i, t.hasZ(s), t.hasM(s));
}
class h {
  constructor(t, s, i, n) {
    this.paths = t, this.spatialReference = s, this.hasZ = void 0, this.hasM = void 0, i && (this.hasZ = i), n && (this.hasM = n);
  }
}
function a(t, s, i) {
  return new h(t.exportPaths(s), i, t.hasZ(s), t.hasM(s));
}
class r {
  constructor(t, s, i, n) {
    this.points = t, this.spatialReference = s, this.hasZ = void 0, this.hasM = void 0, i && (this.hasZ = i), n && (this.hasM = n);
  }
}
function c(t, s, i) {
  return new r(t.exportPoints(s), i, t.hasZ(s), t.hasM(s));
}
class x {
  constructor(t, s, i, n, e) {
    this.xmin = t, this.ymin = s, this.xmax = i, this.ymax = n, this.spatialReference = e, this.zmin = void 0, this.zmax = void 0, this.mmin = void 0, this.mmax = void 0;
  }
}
function m(t, s, i) {
  const n = t.hasZ(s),
    e = t.hasM(s),
    o = new x(t.getXMin(s), t.getYMin(s), t.getXMax(s), t.getYMax(s), i);
  if (n) {
    const i = t.getZExtent(s);
    o.zmin = i.vmin, o.zmax = i.vmax;
  }
  if (e) {
    const i = t.getMExtent(s);
    o.mmin = i.vmin, o.mmax = i.vmax;
  }
  return o;
}


/***/ }),

/***/ 6099:
/*!*************************************************************************!*\
  !*** ./node_modules/@arcgis/core/geometry/support/quantizationUtils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equals": () => (/* binding */ c),
/* harmony export */   "getQuantizedBoundsCoordsArray": () => (/* binding */ F),
/* harmony export */   "getQuantizedBoundsCoordsArrayArray": () => (/* binding */ V),
/* harmony export */   "getQuantizedBoundsPaths": () => (/* binding */ _),
/* harmony export */   "getQuantizedBoundsPoints": () => (/* binding */ Y),
/* harmony export */   "getQuantizedBoundsRings": () => (/* binding */ A),
/* harmony export */   "quantizeBounds": () => (/* binding */ h),
/* harmony export */   "quantizeExtent": () => (/* binding */ w),
/* harmony export */   "quantizeGeometry": () => (/* binding */ d),
/* harmony export */   "quantizeMultipoint": () => (/* binding */ G),
/* harmony export */   "quantizePaths": () => (/* binding */ N),
/* harmony export */   "quantizePoint": () => (/* binding */ L),
/* harmony export */   "quantizePoints": () => (/* binding */ I),
/* harmony export */   "quantizePolygon": () => (/* binding */ O),
/* harmony export */   "quantizePolyline": () => (/* binding */ S),
/* harmony export */   "quantizeRings": () => (/* binding */ g),
/* harmony export */   "quantizeX": () => (/* binding */ s),
/* harmony export */   "quantizeY": () => (/* binding */ f),
/* harmony export */   "toQuantizationTransform": () => (/* binding */ m),
/* harmony export */   "unquantizeBounds": () => (/* binding */ M),
/* harmony export */   "unquantizeCoordsArray": () => (/* binding */ z),
/* harmony export */   "unquantizeCoordsArrayArray": () => (/* binding */ T),
/* harmony export */   "unquantizeExtent": () => (/* binding */ j),
/* harmony export */   "unquantizeMultipoint": () => (/* binding */ U),
/* harmony export */   "unquantizePaths": () => (/* binding */ P),
/* harmony export */   "unquantizePoint": () => (/* binding */ k),
/* harmony export */   "unquantizePoints": () => (/* binding */ E),
/* harmony export */   "unquantizePolygon": () => (/* binding */ q),
/* harmony export */   "unquantizePolyline": () => (/* binding */ v),
/* harmony export */   "unquantizeRings": () => (/* binding */ b),
/* harmony export */   "unquantizeX": () => (/* binding */ p),
/* harmony export */   "unquantizeY": () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var _jsonUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jsonUtils.js */ 71182);
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/

function l(n) {
  return n && "upperLeft" === n.originPosition;
}
const i = (n, t, e) => [t, e],
  o = (n, t, e) => [t, e, n[2]],
  a = (n, t, e) => [t, e, n[2], n[3]];
function m(n) {
  if (!n) return null;
  return {
    originPosition: "upper-left" === n.originPosition ? "upperLeft" : "lower-left" === n.originPosition ? "lowerLeft" : n.originPosition,
    scale: n.tolerance ? [n.tolerance, n.tolerance] : [1, 1],
    translate: null != n.extent ? [n.extent.xmin, n.extent.ymax] : [0, 0]
  };
}
function c(n, t) {
  if (n === t || null == n && null == t) return !0;
  if (null == n || null == t) return !1;
  let e, r, u, i, o, a;
  return l(n) ? (e = n.translate[0], r = n.translate[1], u = n.scale[0]) : (e = null != n.extent ? n.extent.xmin : 0, r = null != n.extent ? n.extent.ymax : 0, u = n.tolerance), l(t) ? (i = t.translate[0], o = t.translate[1], a = t.scale[0]) : (i = null != t.extent ? t.extent.xmin : 0, o = null != t.extent ? t.extent.ymax : 0, a = t.tolerance), e === i && r === o && u === a;
}
function s({
  scale: n,
  translate: t
}, e) {
  return Math.round((e - t[0]) / n[0]);
}
function f({
  scale: n,
  translate: t
}, e) {
  return Math.round((t[1] - e) / n[1]);
}
function x(n, t, e) {
  const r = [];
  let u, l, i, o;
  for (let a = 0; a < e.length; a++) {
    const m = e[a];
    a > 0 ? (i = s(n, m[0]), o = f(n, m[1]), i === u && o === l || (r.push(t(m, i - u, o - l)), u = i, l = o)) : (u = s(n, m[0]), l = f(n, m[1]), r.push(t(m, u, l)));
  }
  return r.length > 0 ? r : null;
}
function h(n, t, e) {
  return t[0] = s(n, e[0]), t[3] = f(n, e[1]), t[2] = s(n, e[2]), t[1] = f(n, e[3]), t;
}
function I(n, t, e, r) {
  return x(n, e ? r ? a : o : r ? o : i, t);
}
function g(n, t, e, r) {
  const u = [],
    l = e ? r ? a : o : r ? o : i;
  for (let i = 0; i < t.length; i++) {
    const e = x(n, l, t[i]);
    e && e.length >= 3 && u.push(e);
  }
  return u.length ? u : null;
}
function N(n, t, e, r) {
  const u = [],
    l = e ? r ? a : o : r ? o : i;
  for (let i = 0; i < t.length; i++) {
    const e = x(n, l, t[i]);
    e && e.length >= 2 && u.push(e);
  }
  return u.length ? u : null;
}
function p({
  scale: n,
  translate: t
}, e) {
  return e * n[0] + t[0];
}
function y({
  scale: n,
  translate: t
}, e) {
  return t[1] - e * n[1];
}
function z(n, t, e) {
  const r = new Array(e.length);
  if (!e.length) return r;
  const [u, l] = n.scale;
  let i = p(n, e[0][0]),
    o = y(n, e[0][1]);
  r[0] = t(e[0], i, o);
  for (let a = 1; a < e.length; a++) {
    const n = e[a];
    i += n[0] * u, o -= n[1] * l, r[a] = t(n, i, o);
  }
  return r;
}
function T(n, t, e) {
  const r = new Array(e.length);
  for (let u = 0; u < e.length; u++) r[u] = z(n, t, e[u]);
  return r;
}
function M(n, t, e) {
  return e ? (t[0] = p(n, e[0]), t[1] = y(n, e[3]), t[2] = p(n, e[2]), t[3] = y(n, e[1]), t) : [p(n, t[0]), y(n, t[3]), p(n, t[2]), y(n, t[1])];
}
function E(n, t, e, r) {
  return z(n, e ? r ? a : o : r ? o : i, t);
}
function P(n, t, e, r) {
  return T(n, e ? r ? a : o : r ? o : i, t);
}
function b(n, t, e, r) {
  return T(n, e ? r ? a : o : r ? o : i, t);
}
function F(n, t, e) {
  let [r, u] = e[0],
    l = Math.min(r, t[0]),
    i = Math.min(u, t[1]),
    o = Math.max(r, t[2]),
    a = Math.max(u, t[3]);
  for (let m = 1; m < e.length; m++) {
    const [n, t] = e[m];
    r += n, u += t, n < 0 && (l = Math.min(l, r)), n > 0 && (o = Math.max(o, r)), t < 0 ? i = Math.min(i, u) : t > 0 && (a = Math.max(a, u));
  }
  return n[0] = l, n[1] = i, n[2] = o, n[3] = a, n;
}
function V(n, t) {
  if (!t.length) return null;
  n[0] = n[1] = Number.POSITIVE_INFINITY, n[2] = n[3] = Number.NEGATIVE_INFINITY;
  for (let e = 0; e < t.length; e++) F(n, n, t[e]);
  return n;
}
function Y(n) {
  const t = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
  return F(t, t, n);
}
function _(n) {
  return V([0, 0, 0, 0], n);
}
function A(n) {
  return V([0, 0, 0, 0], n);
}
function w(n, t, e, r, u) {
  return t.xmin = s(n, e.xmin), t.ymin = f(n, e.ymin), t.xmax = s(n, e.xmax), t.ymax = f(n, e.ymax), t !== e && (r && (t.zmin = e.zmin, t.zmax = e.zmax), u && (t.mmin = e.mmin, t.mmax = e.mmax)), t;
}
function G(n, t, e, r, u) {
  return t.points = I(n, e.points, r, u) ?? [], t;
}
function L(n, t, e, r, u) {
  return t.x = s(n, e.x), t.y = f(n, e.y), t !== e && (r && (t.z = e.z), u && (t.m = e.m)), t;
}
function O(n, t, e, r, u) {
  const l = g(n, e.rings, r, u);
  return l ? (t.rings = l, t) : null;
}
function S(n, t, e, r, u) {
  const l = N(n, e.paths, r, u);
  return l ? (t.paths = l, t) : null;
}
function d(l, i) {
  return l && i ? (0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_0__.isPoint)(i) ? L(l, {}, i, !1, !1) : (0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_0__.isPolyline)(i) ? S(l, {}, i, !1, !1) : (0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_0__.isPolygon)(i) ? O(l, {}, i, !1, !1) : (0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_0__.isMultipoint)(i) ? G(l, {}, i, !1, !1) : (0,_jsonUtils_js__WEBPACK_IMPORTED_MODULE_0__.isExtent)(i) ? w(l, {}, i, !1, !1) : null : null;
}
function j(n, t, e, r, u) {
  return t.xmin = p(n, e.xmin), t.ymin = y(n, e.ymin), t.xmax = p(n, e.xmax), t.ymax = y(n, e.ymax), t !== e && (r && (t.zmin = e.zmin, t.zmax = e.zmax), u && (t.mmin = e.mmin, t.mmax = e.mmax)), t;
}
function U(n, t, e, r, u) {
  return null != e && (t.points = E(n, e.points, r, u)), t;
}
function k(n, t, e, r, u) {
  return null == e || (t.x = p(n, e.x), t.y = y(n, e.y), t !== e && (r && (t.z = e.z), u && (t.m = e.m))), t;
}
function q(n, t, e, r, u) {
  return null != e && (t.rings = b(n, e.rings, r, u)), t;
}
function v(n, t, e, r, u) {
  return null != e && (t.paths = P(n, e.paths, r, u)), t;
}


/***/ }),

/***/ 19482:
/*!*****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/layers/graphics/data/projectionSupport.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkProjectionSupport": () => (/* binding */ x),
/* harmony export */   "project": () => (/* binding */ j),
/* harmony export */   "projectMany": () => (/* binding */ b)
/* harmony export */ });
/* harmony import */ var _home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/arrayUtils.js */ 19420);
/* harmony import */ var _core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/promiseUtils.js */ 30801);
/* harmony import */ var _geometry_projection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../geometry/projection.js */ 89487);
/* harmony import */ var _geometry_geometryAdapters_json_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../geometry/geometryAdapters/json.js */ 17409);
/* harmony import */ var _geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../geometry/support/spatialReferenceUtils.js */ 53492);
/* harmony import */ var _geometry_support_webMercatorUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../geometry/support/webMercatorUtils.js */ 83550);

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/






const c = [0, 0];
function h(s, t) {
  if (!t) return null;
  if ("x" in t) {
    const e = {
      x: 0,
      y: 0
    };
    return [e.x, e.y] = s(t.x, t.y, c), null != t.z && (e.z = t.z), null != t.m && (e.m = t.m), e;
  }
  if ("xmin" in t) {
    const e = {
      xmin: 0,
      ymin: 0,
      xmax: 0,
      ymax: 0
    };
    return [e.xmin, e.ymin] = s(t.xmin, t.ymin, c), [e.xmax, e.ymax] = s(t.xmax, t.ymax, c), t.hasZ && (e.zmin = t.zmin, e.zmax = t.zmax, e.hasZ = !0), t.hasM && (e.mmin = t.mmin, e.mmax = t.mmax, e.hasM = !0), e;
  }
  return "rings" in t ? {
    rings: l(t.rings, s),
    hasM: t.hasM,
    hasZ: t.hasZ
  } : "paths" in t ? {
    paths: l(t.paths, s),
    hasM: t.hasM,
    hasZ: t.hasZ
  } : "points" in t ? {
    points: f(t.points, s),
    hasM: t.hasM,
    hasZ: t.hasZ
  } : null;
}
function l(s, t) {
  const e = [];
  for (const n of s) e.push(f(n, t));
  return e;
}
function f(s, t) {
  const e = [];
  for (const n of s) {
    const s = t(n[0], n[1], [0, 0]);
    e.push(s), n.length > 2 && s.push(n[2]), n.length > 3 && s.push(n[3]);
  }
  return e;
}
function x(_x, _x2) {
  return _x3.apply(this, arguments);
}
function _x3() {
  _x3 = (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (t, n) {
    if (!t || !n) return;
    const r = Array.isArray(t) ? t.map(s => null != s.geometry ? s.geometry.spatialReference : null).filter(_core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_1__.isSome) : [t];
    yield (0,_geometry_projection_js__WEBPACK_IMPORTED_MODULE_3__.initializeProjection)(r.map(s => ({
      source: s,
      dest: n
    })));
  });
  return _x3.apply(this, arguments);
}
const y = h.bind(null, _geometry_support_webMercatorUtils_js__WEBPACK_IMPORTED_MODULE_6__.lngLatToXY),
  g = h.bind(null, _geometry_support_webMercatorUtils_js__WEBPACK_IMPORTED_MODULE_6__.xyToLngLat);
function j(s, t, e, m) {
  if (!s) return s;
  if (e || (e = t, t = s.spatialReference), !(0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__.isValid)(t) || !(0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__.isValid)(e) || (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__.equals)(t, e)) return s;
  if ((0,_geometry_support_webMercatorUtils_js__WEBPACK_IMPORTED_MODULE_6__.canProject)(t, e)) {
    const t = (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__.isWebMercator)(e) ? y(s) : g(s);
    return t.spatialReference = e, t;
  }
  return (0,_geometry_projection_js__WEBPACK_IMPORTED_MODULE_3__.projectMany)(_geometry_geometryAdapters_json_js__WEBPACK_IMPORTED_MODULE_4__.jsonAdapter, [s], t, e, null, m)[0];
}
class _ {
  constructor() {
    this._jobs = [], this._timer = null, this._process = this._process.bind(this);
  }
  push(s, e, n, r) {
    var _this = this;
    return (0,_home_ohnj_Documentos_realG4Life_1_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!s?.length || !e || !n || (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__.equals)(e, n)) return s;
      const i = {
        geometries: s,
        inSpatialReference: e,
        outSpatialReference: n,
        geographicTransformation: r,
        resolve: (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_2__.createResolver)()
      };
      return _this._jobs.push(i), _this._timer ??= setTimeout(_this._process, 10), i.resolve.promise;
    })();
  }
  _process() {
    this._timer = null;
    const s = this._jobs.shift();
    if (!s) return;
    const {
      geometries: t,
      inSpatialReference: e,
      outSpatialReference: i,
      resolve: o,
      geographicTransformation: m
    } = s;
    (0,_geometry_support_webMercatorUtils_js__WEBPACK_IMPORTED_MODULE_6__.canProject)(e, i) ? (0,_geometry_support_spatialReferenceUtils_js__WEBPACK_IMPORTED_MODULE_5__.isWebMercator)(i) ? o(t.map(y)) : o(t.map(g)) : o((0,_geometry_projection_js__WEBPACK_IMPORTED_MODULE_3__.projectMany)(_geometry_geometryAdapters_json_js__WEBPACK_IMPORTED_MODULE_4__.jsonAdapter, t, e, i, m, null)), this._jobs.length > 0 && (this._timer = setTimeout(this._process, 10));
  }
}
const M = new _();
function b(s, t, e, n) {
  return M.push(s, t, e, n);
}


/***/ })

}]);
//# sourceMappingURL=default-node_modules_arcgis_core_geometry_support_quantizationUtils_js-node_modules_arcgis_co-5cd95b.js.map